Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id E11A927C02E
	for <lists+alsa-devel@lfdr.de>; Tue, 29 Sep 2020 10:56:35 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id EC2991871;
	Tue, 29 Sep 2020 10:55:44 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz EC2991871
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1601369795;
	bh=LwwAyaXURA9gR4n9eZY0yBFd24zClSGA99ReKitdF5E=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=dg7vOAUaZ81Wvwz6YcN4NkhcpXLa5+WMR7NJZ2jJwO/VXHdo1INhVTOgYv/njh2yn
	 4fu//Bt3aH2XDa8mm3xsSOumFwBY/xsp+62UBC1EwxTiVN1hwbL0GTTFgntxzWklI1
	 UiNe6luugco97RaPvsuRQJH7NhxNSyS7pKkDS0/g=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 1B3C8F800DD;
	Tue, 29 Sep 2020 10:54:54 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id D2703F801F5; Tue, 29 Sep 2020 10:54:51 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=RCVD_IN_MSPIKE_H3,
 RCVD_IN_MSPIKE_WL,SPF_HELO_NONE,SPF_PASS,URIBL_BLOCKED autolearn=disabled
 version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 75189F800DD
 for <alsa-devel@alsa-project.org>; Tue, 29 Sep 2020 10:54:40 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 75189F800DD
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id 0BFD2AE64;
 Tue, 29 Sep 2020 08:54:40 +0000 (UTC)
Date: Tue, 29 Sep 2020 10:54:39 +0200
Message-ID: <s5heemlklo0.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: "Gyeongtaek Lee" <gt82.lee@samsung.com>
Subject: Re: [PATCH] ALSA: compress: allow pause and resume during draining
In-Reply-To: <000001d6963c$3cc53690$b64fa3b0$@samsung.com>
References: <CGME20200929084051epcas2p35fb2228ed1bdfce6a7ddf5b37c944823@epcas2p3.samsung.com>
 <000001d6963c$3cc53690$b64fa3b0$@samsung.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: alsa-devel@alsa-project.org, khw0178.kim@samsung.com, lgirdwood@gmail.com,
 kimty@samsung.com,
 'Pierre-Louis Bossart' <pierre-louis.bossart@linux.intel.com>, tiwai@suse.com,
 vkoul@kernel.org, hmseo@samsung.com, tkjung@samsung.com,
 pilsun.jang@samsung.com, s47.kang@samsung.com
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Tue, 29 Sep 2020 10:40:51 +0200,
Gyeongtaek Lee wrote:
> 
> On 9/29/20 04:13 PM, Takashi Iwai wrote:
> >On Tue, 29 Sep 2020 03:51:35 +0200,
> >Gyeongtaek Lee wrote:
> >> 
> >> On 9/28/20 11:35 PM, Pierre-Louis Bossart wrote:
> >> >On 9/28/20 6:13 AM, Jaroslav Kysela wrote:
> >> >> Dne 28. 09. 20 v 12:50 Gyeongtaek Lee napsal(a):
> >> >>> With a stream with low bitrate, user can't pause or resume the stream
> >> >>> near the end of the stream because current ALSA doesn't allow it.
> >> >>> If the stream has very low bitrate enough to store whole stream into
> >> >>> the buffer, user can't do anything except stop the stream and then
> >> >>> restart it from the first.
> >> >>> If pause and resume is allowed during draining, user experience can be
> >> >>> enhanced.
> >> >> 
> >> >> It seems that we need a new state to handle the pause + drain condition for
> >> >> this case.
> >> >> 
> >> >> With this proposed change, the pause state in drain is invisible.
> >> >
> >> >Indeed it's be much nicer to have a new state, e..g 
> >> >SNDRV_PCM_STATE_DRAINING_PAUSED.
> >> Ok. I will add the new state.
> >> >
> >> >One concern is that states are defined in uapi/sound/asoc.h, so wouldn't 
> >> >this have impacts on userspace as well? We'd change the value of 
> >> >SNDRV_PCM_STATE_LAST.
> >> >
> >> I also agree that adding new state and increase LAST value in the header of uapi
> >> could be dangerous. So, I added it to comress_offload.h for now.
> >> It could be merged into snd_pcm_state_t in someday with big changes.
> >> Could you review the fixed patch below?
> >
> >Hrm, this resulted in rather more complex changes than the original
> >patch.  It shows that introducing yet another state is no good idea
> >for this particular case.
> >
> >Since the possible application's behavior after this pause is as same
> >as the normal pause (i.e. either resuming pause or dropping), I find
> >it OK to take the original approach.
> Thank you for the review.
> I think that I should resend the original patch.

Let's wait a bit for other opinions.  We may add rather a new flag
instead of introducing a new state, too, for example.

Also, I'm not sure about any side-effect to drivers that expect the
pause only during the running state.  We might need some check for a
capability flag?

In anyway, the timing is bad; it's too late for 5.10 to apply such a
core change.  Can we postpone this for 5.11?


thanks,

Takashi


> Am I right?
> >
> >
> >thanks,
> >
> >Takashi
> >
> >> With a stream with low bitrate, user can't pause or resume the stream
> >> near the end of the stream because current ALSA doesn't allow it.
> >> If the stream has very low bitrate enough to store whole stream into
> >> the buffer, user can't do anything except stop the stream and then
> >> restart it from first.
> >> If pause, resume are allowed during draining, user experience can be
> >> enhanced.
> >> 
> >> New state for pause during draining is defined in compress_offload.h for
> >> now. If PCM_STATEs in uapi/sound/asound.h is changed, pcm libraries and
> >> userspace application will be affected.
> >> 
> >> Signed-off-by: Gyeongtaek Lee <gt82.lee@samsung.com>
> >> Cc: stable@vger.kernel.org
> >> ---
> >>  include/uapi/sound/compress_offload.h |  3 ++
> >>  sound/core/compress_offload.c         | 47 ++++++++++++++++++++++-----
> >>  2 files changed, 41 insertions(+), 9 deletions(-)
> >> 
> >> diff --git a/include/uapi/sound/compress_offload.h b/include/uapi/sound/compress_offload.h
> >> index 7184265c0b0d..f30b9851d1d7 100644
> >> --- a/include/uapi/sound/compress_offload.h
> >> +++ b/include/uapi/sound/compress_offload.h
> >> @@ -189,4 +189,7 @@ struct snd_compr_metadata {
> >>  #define SND_COMPR_TRIGGER_DRAIN 7 /*FIXME move this to pcm.h */
> >>  #define SND_COMPR_TRIGGER_NEXT_TRACK 8
> >>  #define SND_COMPR_TRIGGER_PARTIAL_DRAIN 9
> >> +
> >> +/* FIXME move this to asound.h */
> >> +#define	SNDRV_PCM_STATE_DRAINING_PAUSED	(SNDRV_PCM_STATE_LAST + 1)
> >>  #endif
> >> diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c
> >> index 0e53f6f31916..58fbe0d99431 100644
> >> --- a/sound/core/compress_offload.c
> >> +++ b/sound/core/compress_offload.c
> >> @@ -151,6 +151,7 @@ static int snd_compr_free(struct inode *inode, struct file *f)
> >>  	case SNDRV_PCM_STATE_RUNNING:
> >>  	case SNDRV_PCM_STATE_DRAINING:
> >>  	case SNDRV_PCM_STATE_PAUSED:
> >> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
> >>  		data->stream.ops->trigger(&data->stream, SNDRV_PCM_TRIGGER_STOP);
> >>  		break;
> >>  	default:
> >> @@ -431,6 +432,7 @@ static __poll_t snd_compr_poll(struct file *f, poll_table *wait)
> >>  	case SNDRV_PCM_STATE_RUNNING:
> >>  	case SNDRV_PCM_STATE_PREPARED:
> >>  	case SNDRV_PCM_STATE_PAUSED:
> >> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
> >>  		if (avail >= stream->runtime->fragment_size)
> >>  			retval = snd_compr_get_poll(stream);
> >>  		break;
> >> @@ -708,11 +710,23 @@ static int snd_compr_pause(struct snd_compr_stream *stream)
> >>  {
> >>  	int retval;
> >>  
> >> -	if (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)
> >> +	switch (stream->runtime->state) {
> >> +	case SNDRV_PCM_STATE_RUNNING:
> >> +		retval = stream->ops->trigger(stream,
> >> +			SNDRV_PCM_TRIGGER_PAUSE_PUSH);
> >> +		if (!retval)
> >> +			stream->runtime->state = SNDRV_PCM_STATE_PAUSED;
> >> +		break;
> >> +	case SNDRV_PCM_STATE_DRAINING:
> >> +		retval = stream->ops->trigger(stream,
> >> +			SNDRV_PCM_TRIGGER_PAUSE_PUSH);
> >> +		if (!retval)
> >> +			stream->runtime->state =
> >> +				SNDRV_PCM_STATE_DRAINING_PAUSED;
> >> +		break;
> >> +	default:
> >>  		return -EPERM;
> >> -	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);
> >> -	if (!retval)
> >> -		stream->runtime->state = SNDRV_PCM_STATE_PAUSED;
> >> +	}
> >>  	return retval;
> >>  }
> >>  
> >> @@ -720,11 +734,22 @@ static int snd_compr_resume(struct snd_compr_stream *stream)
> >>  {
> >>  	int retval;
> >>  
> >> -	if (stream->runtime->state != SNDRV_PCM_STATE_PAUSED)
> >> +	switch (stream->runtime->state) {
> >> +	case SNDRV_PCM_STATE_PAUSED:
> >> +		retval = stream->ops->trigger(stream,
> >> +			SNDRV_PCM_TRIGGER_PAUSE_RELEASE);
> >> +		if (!retval)
> >> +			stream->runtime->state = SNDRV_PCM_STATE_RUNNING;
> >> +		break;
> >> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
> >> +		retval = stream->ops->trigger(stream,
> >> +			SNDRV_PCM_TRIGGER_PAUSE_RELEASE);
> >> +		if (!retval)
> >> +			stream->runtime->state = SNDRV_PCM_STATE_DRAINING;
> >> +		break;
> >> +	default:
> >>  		return -EPERM;
> >> -	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_RELEASE);
> >> -	if (!retval)
> >> -		stream->runtime->state = SNDRV_PCM_STATE_RUNNING;
> >> +	}
> >>  	return retval;
> >>  }
> >>  
> >> @@ -835,7 +860,9 @@ static int snd_compress_wait_for_drain(struct snd_compr_stream *stream)
> >>  	 */
> >>  
> >>  	ret = wait_event_interruptible(stream->runtime->sleep,
> >> -			(stream->runtime->state != SNDRV_PCM_STATE_DRAINING));
> >> +			(stream->runtime->state != SNDRV_PCM_STATE_DRAINING) &&
> >> +			(stream->runtime->state !=
> >> +				SNDRV_PCM_STATE_DRAINING_PAUSED));
> >>  	if (ret == -ERESTARTSYS)
> >>  		pr_debug("wait aborted by a signal\n");
> >>  	else if (ret)
> >> @@ -857,6 +884,7 @@ static int snd_compr_drain(struct snd_compr_stream *stream)
> >>  	case SNDRV_PCM_STATE_SETUP:
> >>  	case SNDRV_PCM_STATE_PREPARED:
> >>  	case SNDRV_PCM_STATE_PAUSED:
> >> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
> >>  		return -EPERM;
> >>  	case SNDRV_PCM_STATE_XRUN:
> >>  		return -EPIPE;
> >> @@ -909,6 +937,7 @@ static int snd_compr_partial_drain(struct snd_compr_stream *stream)
> >>  	case SNDRV_PCM_STATE_SETUP:
> >>  	case SNDRV_PCM_STATE_PREPARED:
> >>  	case SNDRV_PCM_STATE_PAUSED:
> >> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
> >>  		return -EPERM;
> >>  	case SNDRV_PCM_STATE_XRUN:
> >>  		return -EPIPE;
> >> 
> >> base-commit: a1b8638ba1320e6684aa98233c15255eb803fac7
> >> -- 
> >> 2.21.0
> >> 
> >> 
> >
> 
