Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id A8F4E3263FF
	for <lists+alsa-devel@lfdr.de>; Fri, 26 Feb 2021 15:25:15 +0100 (CET)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id 3BC311657;
	Fri, 26 Feb 2021 15:24:25 +0100 (CET)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz 3BC311657
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1614349515;
	bh=rx4lrCmSAE9Hl3qNyvSOFD1ZfZYt6Xluv/n96S/MNRc=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=d69FYRBonzViauOAmOGonmpwzgiPNV2N89wfK5i7ztXgpLg2+8HP/ewdqah2mmM3g
	 xGowHjc6s8oGlxHR0q1/GApNXy+j4K2/tvsy5N9EbKzgskKwyiiVXFiDTV+0lUXPwb
	 4GOLpgbjfVszaTzdQisUQx9Un/R1ShAIMnVeXbUk=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 84F69F8022B;
	Fri, 26 Feb 2021 15:23:44 +0100 (CET)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 07BEAF8016C; Fri, 26 Feb 2021 15:23:41 +0100 (CET)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=SPF_HELO_NONE,SPF_NONE
 autolearn=disabled version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 0E0A6F80159
 for <alsa-devel@alsa-project.org>; Fri, 26 Feb 2021 15:23:38 +0100 (CET)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 0E0A6F80159
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id DEAC9ADFB;
 Fri, 26 Feb 2021 14:23:37 +0000 (UTC)
Date: Fri, 26 Feb 2021 15:23:37 +0100
Message-ID: <s5ha6rqnc0m.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Anton Yakovlev <anton.yakovlev@opensynergy.com>
Subject: Re: [PATCH v5 6/9] ALSA: virtio: PCM substream operators
In-Reply-To: <0a9f6dea-ed75-16eb-9fc2-84148fa820be@opensynergy.com>
References: <20210222153444.348390-1-anton.yakovlev@opensynergy.com>
 <20210222153444.348390-7-anton.yakovlev@opensynergy.com>
 <s5h35xkquvj.wl-tiwai@suse.de>
 <d9b6e8fa-7356-1cbf-029b-6f7c8bad4994@opensynergy.com>
 <s5hlfbcpayj.wl-tiwai@suse.de>
 <20210225135951-mutt-send-email-mst@kernel.org>
 <s5hblc7opok.wl-tiwai@suse.de>
 <0a9f6dea-ed75-16eb-9fc2-84148fa820be@opensynergy.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: virtio-dev@lists.oasis-open.org, alsa-devel@alsa-project.org,
 "Michael S. Tsirkin" <mst@redhat.com>, linux-kernel@vger.kernel.org,
 Takashi Iwai <tiwai@suse.com>, virtualization@lists.linux-foundation.org
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Thu, 25 Feb 2021 23:19:31 +0100,
Anton Yakovlev wrote:
> 
> On 25.02.2021 21:30, Takashi Iwai wrote:> On Thu, 25 Feb 2021 20:02:50
> +0100,
> > Michael S. Tsirkin wrote:
> >>
> >> On Thu, Feb 25, 2021 at 01:51:16PM +0100, Takashi Iwai wrote:
> >>> On Thu, 25 Feb 2021 13:14:37 +0100,
> >>> Anton Yakovlev wrote:
> 
> 
> [snip]
> 
> 
> >> Takashi given I was in my tree for a while and I planned to merge
> >> it this merge window.
> >
> > Hmm, that's too quick, I'm afraid.  I see still a few rough edges in
> > the code.  e.g. the reset work should be canceled at the driver
> > removal, but it's missing right now.  And that'll become tricky
> > because the reset work itself unbinds the device, hence it'll get
> > stuck if calling cancel_work_sync() at remove callback.
> 
> Yes, you made a good point here! In this case, we need some external
> mutex for synchronization. This is just a rough idea, but maybe
> something like this might work:
> 
> struct reset_work {
>     struct mutex mutex;
>     struct work_struct work;
>     struct virtio_snd *snd;
>     bool resetting;
> };
> 
> static struct reset_work reset_works[SNDRV_CARDS];
> 
> init()
>     // init mutexes and workers
> 
> 
> virtsnd_probe()
>     snd_card_new(snd->card)
>     reset_works[snd->card->number].snd = snd;
> 
> 
> virtsnd_remove()
>     mutex_lock(reset_works[snd->card->number].mutex)
>     reset_works[snd->card->number].snd = NULL;
>     resetting = reset_works[snd->card->number].resetting;
>     mutex_unlock(reset_works[snd->card->number].mutex)
> 
>     if (!resetting)
>         // cancel worker reset_works[snd->card->number].work
>     // remove device
> 
> 
> virtsnd_reset_fn(work)
>     mutex_lock(work->mutex)
>     if (!work->snd)
>         // do nothing and take an exit path
>     work->resetting = true;
>     mutex_unlock(work->mutex)
> 
>     device_reprobe()
> 
>     work->resetting = false;
> 
> 
> interrupt_handler()
>     schedule_work(reset_works[snd->card->number].work);
> 
> 
> What do you think?

I think it's still somehow racy.  Suppose that the reset_work is
already running right before entering virtsnd_remove(): it sets
reset_works[].resetting flag, virtsnd_remove() skips canceling, and
both reset work and virtsnd_remove() perform at the very same time.
(I don't know whether this may happen, but I assume it's possible.)

In that case, maybe a better check is to check current_work(), and
perform cancel_work_sync() unless it's &reset_works[].work itself.
Then the recursive cancel call can be avoided.

After that point, the reset must be completed, and we can (again)
process the rest release procedure.  (But also snd object itself might
have been changed again, so it needs to be re-evaluated.)

One remaining concern is that the card number of the sound instance
may change after reprobe.  That is, we may want to another persistent
object instead of accessing via an array index of sound card number.
So, we might need reset_works[] associated with virtio_snd object
instead.

In anyway, this is damn complex.  I sincerely hope that we can avoid
this kind of things.  Wouldn't it be better to shift the reset stuff
up to the virtio core layer?  Or drop the feature in the first
version.  Shooting itself (and revival) is a dangerous magic spell,
after all.


thanks,

Takashi
