Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 4A71B282A1C
	for <lists+alsa-devel@lfdr.de>; Sun,  4 Oct 2020 12:06:09 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id 2D6AC1895;
	Sun,  4 Oct 2020 12:05:17 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz 2D6AC1895
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1601805967;
	bh=fHKgug+gbXGoH4MskPPdEo24g7KYW0uAm9L7BvMMgD8=;
	h=From:To:Subject:Date:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=UcTw/ACXrXWNpGgvJTBT3F5TyPl6XA9jQw2ZwlpHNCRWMD4ZtEGs8dudy6b1YG8MF
	 nJGwTbchADk21Mw0f6SIyaIVVs35YBeAg71ejO+9ClnfwB+nNJ2zptFCW9tFFiC6pn
	 1QZugEJeoCa+pIa76y+wOIFZSfam9Xfh09w47ENY=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 1BDCAF80305;
	Sun,  4 Oct 2020 12:02:25 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 2B53EF802EA; Sun,  4 Oct 2020 12:02:16 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.2 required=5.0 tests=PRX_BODY_76, RCVD_IN_MSPIKE_H3,
 RCVD_IN_MSPIKE_WL,SPF_HELO_NONE,SPF_PASS,URIBL_BLOCKED autolearn=disabled
 version=3.4.0
Received: from mga02.intel.com (mga02.intel.com [134.134.136.20])
 (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id D60A4F800C9
 for <alsa-devel@alsa-project.org>; Sun,  4 Oct 2020 12:01:45 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz D60A4F800C9
IronPort-SDR: uAfkOzSNiKYXfNEs2U3i1gLs7Kt0CwoNbVb4+zbdjPau2Ml/uOQqzlslGnxD2/k3t2n7RYwL+f
 XX929n1gdZdw==
X-IronPort-AV: E=McAfee;i="6000,8403,9763"; a="150905745"
X-IronPort-AV: E=Sophos;i="5.77,335,1596524400"; d="scan'208";a="150905745"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from fmsmga004.fm.intel.com ([10.253.24.48])
 by orsmga101.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 04 Oct 2020 03:01:42 -0700
IronPort-SDR: 9XOtn6unyNg2bsHGz+B5zexpf3RjAm9ihTbqoa4ZjdCXpll8GHfwl31CBkzlxBrlDSTxc+ytQP
 OH7t24+NYkZQ==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="5.77,335,1596524400"; d="scan'208";a="340527839"
Received: from crojewsk-ctrl.igk.intel.com ([10.102.9.28])
 by fmsmga004.fm.intel.com with ESMTP; 04 Oct 2020 03:01:37 -0700
From: Cezary Rojewski <cezary.rojewski@intel.com>
To: alsa-devel@alsa-project.org
Subject: [PATCH 01/13] ASoC: Intel: Remove haswell solution
Date: Sun,  4 Oct 2020 12:01:16 +0200
Message-Id: <20201004100128.5842-2-cezary.rojewski@intel.com>
X-Mailer: git-send-email 2.17.1
In-Reply-To: <20201004100128.5842-1-cezary.rojewski@intel.com>
References: <20201004100128.5842-1-cezary.rojewski@intel.com>
Cc: pierre-louis.bossart@linux.intel.com,
 Cezary Rojewski <cezary.rojewski@intel.com>, andriy.shevchenko@linux.intel.com,
 filip.kaczmarski@intel.com, harshapriya.n@intel.com, marcin.barlik@intel.com,
 zwisler@google.com, lgirdwood@gmail.com, tiwai@suse.com,
 filip.proborszcz@intel.com, broonie@kernel.org,
 amadeuszx.slawinski@linux.intel.com, michal.wasko@intel.com,
 cujomalainey@chromium.org, krzysztof.hejmowski@intel.com,
 ppapierkowski@habana.ai, vamshi.krishna.gopal@intel.com
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

Newly added catpt solution found in sound/soc/intel/catpt is a direct
replacement to sound/soc/intel/haswell. It covers all features supported
by it and more - by aligning to recommended flows and requirement list
based on Windows driver equivalent. No harm is done to userspace as
catpt - similarly to haswell - loads no extenal topology files while
sharing the exact same ADSP firmware binary.

Given the above, existing haswell code is redundant so remove it.

Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
---
 include/trace/events/hswadsp.h            |  385 ----
 sound/soc/intel/haswell/Makefile          |    5 -
 sound/soc/intel/haswell/sst-haswell-dsp.c |  705 -------
 sound/soc/intel/haswell/sst-haswell-ipc.c | 2222 ---------------------
 sound/soc/intel/haswell/sst-haswell-ipc.h |  527 -----
 sound/soc/intel/haswell/sst-haswell-pcm.c | 1369 -------------
 6 files changed, 5213 deletions(-)
 delete mode 100644 include/trace/events/hswadsp.h
 delete mode 100644 sound/soc/intel/haswell/Makefile
 delete mode 100644 sound/soc/intel/haswell/sst-haswell-dsp.c
 delete mode 100644 sound/soc/intel/haswell/sst-haswell-ipc.c
 delete mode 100644 sound/soc/intel/haswell/sst-haswell-ipc.h
 delete mode 100644 sound/soc/intel/haswell/sst-haswell-pcm.c

diff --git a/include/trace/events/hswadsp.h b/include/trace/events/hswadsp.h
deleted file mode 100644
index 939d7a09d73f..000000000000
--- a/include/trace/events/hswadsp.h
+++ /dev/null
@@ -1,385 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#undef TRACE_SYSTEM
-#define TRACE_SYSTEM hswadsp
-
-#if !defined(_TRACE_HSWADSP_H) || defined(TRACE_HEADER_MULTI_READ)
-#define _TRACE_HSWADSP_H
-
-#include <linux/types.h>
-#include <linux/ktime.h>
-#include <linux/tracepoint.h>
-
-struct sst_hsw;
-struct sst_hsw_stream;
-struct sst_hsw_ipc_stream_free_req;
-struct sst_hsw_ipc_volume_req;
-struct sst_hsw_ipc_stream_alloc_req;
-struct sst_hsw_audio_data_format_ipc;
-struct sst_hsw_ipc_stream_info_reply;
-struct sst_hsw_ipc_device_config_req;
-
-DECLARE_EVENT_CLASS(sst_irq,
-
-	TP_PROTO(uint32_t status, uint32_t mask),
-
-	TP_ARGS(status, mask),
-
-	TP_STRUCT__entry(
-		__field(	unsigned int,	status		)
-		__field(	unsigned int,	mask		)
-	),
-
-	TP_fast_assign(
-		__entry->status = status;
-		__entry->mask = mask;
-	),
-
-	TP_printk("status 0x%8.8x mask 0x%8.8x",
-		(unsigned int)__entry->status, (unsigned int)__entry->mask)
-);
-
-DEFINE_EVENT(sst_irq, sst_irq_busy,
-
-	TP_PROTO(unsigned int status, unsigned int mask),
-
-	TP_ARGS(status, mask)
-
-);
-
-DEFINE_EVENT(sst_irq, sst_irq_done,
-
-	TP_PROTO(unsigned int status, unsigned int mask),
-
-	TP_ARGS(status, mask)
-
-);
-
-DECLARE_EVENT_CLASS(ipc,
-
-	TP_PROTO(const char *name, int val),
-
-	TP_ARGS(name, val),
-
-	TP_STRUCT__entry(
-		__string(	name,	name		)
-		__field(	unsigned int,	val	)
-	),
-
-	TP_fast_assign(
-		__assign_str(name, name);
-		__entry->val = val;
-	),
-
-	TP_printk("%s 0x%8.8x", __get_str(name), (unsigned int)__entry->val)
-
-);
-
-DEFINE_EVENT(ipc, ipc_request,
-
-	TP_PROTO(const char *name, int val),
-
-	TP_ARGS(name, val)
-
-);
-
-DEFINE_EVENT(ipc, ipc_reply,
-
-	TP_PROTO(const char *name, int val),
-
-	TP_ARGS(name, val)
-
-);
-
-DEFINE_EVENT(ipc, ipc_pending_reply,
-
-	TP_PROTO(const char *name, int val),
-
-	TP_ARGS(name, val)
-
-);
-
-DEFINE_EVENT(ipc, ipc_notification,
-
-	TP_PROTO(const char *name, int val),
-
-	TP_ARGS(name, val)
-
-);
-
-DEFINE_EVENT(ipc, ipc_error,
-
-	TP_PROTO(const char *name, int val),
-
-	TP_ARGS(name, val)
-
-);
-
-DECLARE_EVENT_CLASS(stream_position,
-
-	TP_PROTO(unsigned int id, unsigned int pos),
-
-	TP_ARGS(id, pos),
-
-	TP_STRUCT__entry(
-		__field(	unsigned int,	id		)
-		__field(	unsigned int,	pos		)
-	),
-
-	TP_fast_assign(
-		__entry->id = id;
-		__entry->pos = pos;
-	),
-
-	TP_printk("id %d position 0x%x",
-		(unsigned int)__entry->id, (unsigned int)__entry->pos)
-);
-
-DEFINE_EVENT(stream_position, stream_read_position,
-
-	TP_PROTO(unsigned int id, unsigned int pos),
-
-	TP_ARGS(id, pos)
-
-);
-
-DEFINE_EVENT(stream_position, stream_write_position,
-
-	TP_PROTO(unsigned int id, unsigned int pos),
-
-	TP_ARGS(id, pos)
-
-);
-
-TRACE_EVENT(hsw_stream_buffer,
-
-	TP_PROTO(struct sst_hsw_stream *stream),
-
-	TP_ARGS(stream),
-
-	TP_STRUCT__entry(
-		__field(	int,	id	)
-		__field(	int,	pt_addr	)
-		__field(	int,	num_pages	)
-		__field(	int,	ring_size	)
-		__field(	int,	ring_offset	)
-		__field(	int,	first_pfn	)
-	),
-
-	TP_fast_assign(
-		__entry->id = stream->host_id;
-		__entry->pt_addr = stream->request.ringinfo.ring_pt_address;
-		__entry->num_pages = stream->request.ringinfo.num_pages;
-		__entry->ring_size = stream->request.ringinfo.ring_size;
-		__entry->ring_offset = stream->request.ringinfo.ring_offset;
-		__entry->first_pfn = stream->request.ringinfo.ring_first_pfn;
-	),
-
-	TP_printk("stream %d ring addr 0x%x pages %d size 0x%x offset 0x%x PFN 0x%x",
-		(int) __entry->id,  (int)__entry->pt_addr,
-		(int)__entry->num_pages, (int)__entry->ring_size,
-		(int)__entry->ring_offset, (int)__entry->first_pfn)
-);
-
-TRACE_EVENT(hsw_stream_alloc_reply,
-
-	TP_PROTO(struct sst_hsw_stream *stream),
-
-	TP_ARGS(stream),
-
-	TP_STRUCT__entry(
-		__field(	int,	id	)
-		__field(	int,	stream_id	)
-		__field(	int,	mixer_id	)
-		__field(	int,	peak0	)
-		__field(	int,	peak1	)
-		__field(	int,	vol0	)
-		__field(	int,	vol1	)
-	),
-
-	TP_fast_assign(
-		__entry->id = stream->host_id;
-		__entry->stream_id = stream->reply.stream_hw_id;
-		__entry->mixer_id = stream->reply.mixer_hw_id;
-		__entry->peak0 = stream->reply.peak_meter_register_address[0];
-		__entry->peak1 = stream->reply.peak_meter_register_address[1];
-		__entry->vol0 = stream->reply.volume_register_address[0];
-		__entry->vol1 = stream->reply.volume_register_address[1];
-	),
-
-	TP_printk("stream %d hw id %d mixer %d peak 0x%x:0x%x vol 0x%x,0x%x",
-		(int) __entry->id, (int) __entry->stream_id, (int)__entry->mixer_id,
-		(int)__entry->peak0, (int)__entry->peak1,
-		(int)__entry->vol0, (int)__entry->vol1)
-);
-
-TRACE_EVENT(hsw_mixer_info_reply,
-
-	TP_PROTO(struct sst_hsw_ipc_stream_info_reply *reply),
-
-	TP_ARGS(reply),
-
-	TP_STRUCT__entry(
-		__field(	int,	mixer_id	)
-		__field(	int,	peak0	)
-		__field(	int,	peak1	)
-		__field(	int,	vol0	)
-		__field(	int,	vol1	)
-	),
-
-	TP_fast_assign(
-		__entry->mixer_id = reply->mixer_hw_id;
-		__entry->peak0 = reply->peak_meter_register_address[0];
-		__entry->peak1 = reply->peak_meter_register_address[1];
-		__entry->vol0 = reply->volume_register_address[0];
-		__entry->vol1 = reply->volume_register_address[1];
-	),
-
-	TP_printk("mixer id %d peak 0x%x:0x%x vol 0x%x,0x%x",
-		(int)__entry->mixer_id,
-		(int)__entry->peak0, (int)__entry->peak1,
-		(int)__entry->vol0, (int)__entry->vol1)
-);
-
-TRACE_EVENT(hsw_stream_data_format,
-
-	TP_PROTO(struct sst_hsw_stream *stream,
-		struct sst_hsw_audio_data_format_ipc *req),
-
-	TP_ARGS(stream, req),
-
-	TP_STRUCT__entry(
-		__field(	uint32_t,	id	)
-		__field(	uint32_t,	frequency	)
-		__field(	uint32_t,	bitdepth	)
-		__field(	uint32_t,	map	)
-		__field(	uint32_t,	config	)
-		__field(	uint32_t,	style	)
-		__field(	uint8_t,	ch_num	)
-		__field(	uint8_t,	valid_bit	)
-	),
-
-	TP_fast_assign(
-		__entry->id = stream->host_id;
-		__entry->frequency = req->frequency;
-		__entry->bitdepth = req->bitdepth;
-		__entry->map = req->map;
-		__entry->config = req->config;
-		__entry->style = req->style;
-		__entry->ch_num = req->ch_num;
-		__entry->valid_bit = req->valid_bit;
-	),
-
-	TP_printk("stream %d freq %d depth %d map 0x%x config 0x%x style 0x%x ch %d bits %d",
-		(int) __entry->id, (uint32_t)__entry->frequency,
-		(uint32_t)__entry->bitdepth, (uint32_t)__entry->map,
-		(uint32_t)__entry->config, (uint32_t)__entry->style,
-		(uint8_t)__entry->ch_num, (uint8_t)__entry->valid_bit)
-);
-
-TRACE_EVENT(hsw_stream_alloc_request,
-
-	TP_PROTO(struct sst_hsw_stream *stream,
-		struct sst_hsw_ipc_stream_alloc_req *req),
-
-	TP_ARGS(stream, req),
-
-	TP_STRUCT__entry(
-		__field(	uint32_t,	id	)
-		__field(	uint8_t,	path_id	)
-		__field(	uint8_t,	stream_type	)
-		__field(	uint8_t,	format_id	)
-	),
-
-	TP_fast_assign(
-		__entry->id = stream->host_id;
-		__entry->path_id = req->path_id;
-		__entry->stream_type = req->stream_type;
-		__entry->format_id = req->format_id;
-	),
-
-	TP_printk("stream %d path %d type %d format %d",
-		(int) __entry->id, (uint8_t)__entry->path_id,
-		(uint8_t)__entry->stream_type, (uint8_t)__entry->format_id)
-);
-
-TRACE_EVENT(hsw_stream_free_req,
-
-	TP_PROTO(struct sst_hsw_stream *stream,
-		struct sst_hsw_ipc_stream_free_req *req),
-
-	TP_ARGS(stream, req),
-
-	TP_STRUCT__entry(
-		__field(	int,	id	)
-		__field(	int,	stream_id	)
-	),
-
-	TP_fast_assign(
-		__entry->id = stream->host_id;
-		__entry->stream_id = req->stream_id;
-	),
-
-	TP_printk("stream %d hw id %d",
-		(int) __entry->id, (int) __entry->stream_id)
-);
-
-TRACE_EVENT(hsw_volume_req,
-
-	TP_PROTO(struct sst_hsw_stream *stream,
-		struct sst_hsw_ipc_volume_req *req),
-
-	TP_ARGS(stream, req),
-
-	TP_STRUCT__entry(
-		__field(	int,	id	)
-		__field(	uint32_t,	channel	)
-		__field(	uint32_t,	target_volume	)
-		__field(	uint64_t,	curve_duration	)
-		__field(	uint32_t,	curve_type	)
-	),
-
-	TP_fast_assign(
-		__entry->id = stream->host_id;
-		__entry->channel = req->channel;
-		__entry->target_volume = req->target_volume;
-		__entry->curve_duration = req->curve_duration;
-		__entry->curve_type = req->curve_type;
-	),
-
-	TP_printk("stream %d chan 0x%x vol %d duration %llu type %d",
-		(int) __entry->id, (uint32_t) __entry->channel,
-		(uint32_t)__entry->target_volume,
-		(uint64_t)__entry->curve_duration,
-		(uint32_t)__entry->curve_type)
-);
-
-TRACE_EVENT(hsw_device_config_req,
-
-	TP_PROTO(struct sst_hsw_ipc_device_config_req *req),
-
-	TP_ARGS(req),
-
-	TP_STRUCT__entry(
-		__field(	uint32_t,	ssp	)
-		__field(	uint32_t,	clock_freq	)
-		__field(	uint32_t,	mode	)
-		__field(	uint16_t,	clock_divider	)
-	),
-
-	TP_fast_assign(
-		__entry->ssp = req->ssp_interface;
-		__entry->clock_freq = req->clock_frequency;
-		__entry->mode = req->mode;
-		__entry->clock_divider = req->clock_divider;
-	),
-
-	TP_printk("SSP %d Freq %d mode %d div %d",
-		(uint32_t)__entry->ssp,
-		(uint32_t)__entry->clock_freq, (uint32_t)__entry->mode,
-		(uint32_t)__entry->clock_divider)
-);
-
-#endif /* _TRACE_HSWADSP_H */
-
-/* This part must be outside protection */
-#include <trace/define_trace.h>
diff --git a/sound/soc/intel/haswell/Makefile b/sound/soc/intel/haswell/Makefile
deleted file mode 100644
index ad2341aea8ae..000000000000
--- a/sound/soc/intel/haswell/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-snd-soc-sst-haswell-pcm-objs := \
-	        sst-haswell-ipc.o sst-haswell-pcm.o sst-haswell-dsp.o
-
-obj-$(CONFIG_SND_SOC_INTEL_HASWELL) += snd-soc-sst-haswell-pcm.o
diff --git a/sound/soc/intel/haswell/sst-haswell-dsp.c b/sound/soc/intel/haswell/sst-haswell-dsp.c
deleted file mode 100644
index 88c3f63bded9..000000000000
--- a/sound/soc/intel/haswell/sst-haswell-dsp.c
+++ /dev/null
@@ -1,705 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Intel Haswell SST DSP driver
- *
- * Copyright (C) 2013, Intel Corporation. All rights reserved.
- */
-
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/sched.h>
-#include <linux/export.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-#include <linux/pci.h>
-#include <linux/firmware.h>
-#include <linux/pm_runtime.h>
-
-#include "../common/sst-dsp.h"
-#include "../common/sst-dsp-priv.h"
-#include "../haswell/sst-haswell-ipc.h"
-
-#include <trace/events/hswadsp.h>
-
-#define SST_HSW_FW_SIGNATURE_SIZE	4
-#define SST_HSW_FW_SIGN			"$SST"
-#define SST_HSW_FW_LIB_SIGN		"$LIB"
-
-#define SST_WPT_SHIM_OFFSET	0xFB000
-#define SST_LP_SHIM_OFFSET	0xE7000
-#define SST_WPT_IRAM_OFFSET	0xA0000
-#define SST_LP_IRAM_OFFSET	0x80000
-#define SST_WPT_DSP_DRAM_OFFSET	0x400000
-#define SST_WPT_DSP_IRAM_OFFSET	0x00000
-#define SST_LPT_DSP_DRAM_OFFSET	0x400000
-#define SST_LPT_DSP_IRAM_OFFSET	0x00000
-
-#define SST_SHIM_PM_REG		0x84
-
-#define SST_HSW_IRAM	1
-#define SST_HSW_DRAM	2
-#define SST_HSW_REGS	3
-
-struct dma_block_info {
-	__le32 type;		/* IRAM/DRAM */
-	__le32 size;		/* Bytes */
-	__le32 ram_offset;	/* Offset in I/DRAM */
-	__le32 rsvd;		/* Reserved field */
-} __attribute__((packed));
-
-struct fw_module_info {
-	__le32 persistent_size;
-	__le32 scratch_size;
-} __attribute__((packed));
-
-struct fw_header {
-	unsigned char signature[SST_HSW_FW_SIGNATURE_SIZE]; /* FW signature */
-	__le32 file_size;		/* size of fw minus this header */
-	__le32 modules;		/*  # of modules */
-	__le32 file_format;	/* version of header format */
-	__le32 reserved[4];
-} __attribute__((packed));
-
-struct fw_module_header {
-	unsigned char signature[SST_HSW_FW_SIGNATURE_SIZE]; /* module signature */
-	__le32 mod_size;	/* size of module */
-	__le32 blocks;	/* # of blocks */
-	__le16 padding;
-	__le16 type;	/* codec type, pp lib */
-	__le32 entry_point;
-	struct fw_module_info info;
-} __attribute__((packed));
-
-static void hsw_free(struct sst_dsp *sst);
-
-static int hsw_parse_module(struct sst_dsp *dsp, struct sst_fw *fw,
-	struct fw_module_header *module)
-{
-	struct dma_block_info *block;
-	struct sst_module *mod;
-	struct sst_module_template template;
-	int count, ret;
-	void __iomem *ram;
-	int type = le16_to_cpu(module->type);
-	int entry_point = le32_to_cpu(module->entry_point);
-
-	/* TODO: allowed module types need to be configurable */
-	if (type != SST_HSW_MODULE_BASE_FW &&
-	    type != SST_HSW_MODULE_PCM_SYSTEM &&
-	    type != SST_HSW_MODULE_PCM &&
-	    type != SST_HSW_MODULE_PCM_REFERENCE &&
-	    type != SST_HSW_MODULE_PCM_CAPTURE &&
-	    type != SST_HSW_MODULE_WAVES &&
-	    type != SST_HSW_MODULE_LPAL)
-		return 0;
-
-	dev_dbg(dsp->dev, "new module sign 0x%s size 0x%x blocks 0x%x type 0x%x\n",
-		module->signature, module->mod_size,
-		module->blocks, type);
-	dev_dbg(dsp->dev, " entrypoint 0x%x\n", entry_point);
-	dev_dbg(dsp->dev, " persistent 0x%x scratch 0x%x\n",
-		module->info.persistent_size, module->info.scratch_size);
-
-	memset(&template, 0, sizeof(template));
-	template.id = type;
-	template.entry = entry_point - 4;
-	template.persistent_size = le32_to_cpu(module->info.persistent_size);
-	template.scratch_size = le32_to_cpu(module->info.scratch_size);
-
-	mod = sst_module_new(fw, &template, NULL);
-	if (mod == NULL)
-		return -ENOMEM;
-
-	block = (void *)module + sizeof(*module);
-
-	for (count = 0; count < le32_to_cpu(module->blocks); count++) {
-
-		if (le32_to_cpu(block->size) <= 0) {
-			dev_err(dsp->dev,
-				"error: block %d size invalid\n", count);
-			sst_module_free(mod);
-			return -EINVAL;
-		}
-
-		switch (le32_to_cpu(block->type)) {
-		case SST_HSW_IRAM:
-			ram = dsp->addr.lpe;
-			mod->offset = le32_to_cpu(block->ram_offset) +
-				dsp->addr.iram_offset;
-			mod->type = SST_MEM_IRAM;
-			break;
-		case SST_HSW_DRAM:
-		case SST_HSW_REGS:
-			ram = dsp->addr.lpe;
-			mod->offset = le32_to_cpu(block->ram_offset);
-			mod->type = SST_MEM_DRAM;
-			break;
-		default:
-			dev_err(dsp->dev, "error: bad type 0x%x for block 0x%x\n",
-				block->type, count);
-			sst_module_free(mod);
-			return -EINVAL;
-		}
-
-		mod->size = le32_to_cpu(block->size);
-		mod->data = (void *)block + sizeof(*block);
-		mod->data_offset = mod->data - fw->dma_buf;
-
-		dev_dbg(dsp->dev, "module block %d type 0x%x "
-			"size 0x%x ==> ram %p offset 0x%x\n",
-			count, mod->type, block->size, ram,
-			block->ram_offset);
-
-		ret = sst_module_alloc_blocks(mod);
-		if (ret < 0) {
-			dev_err(dsp->dev, "error: could not allocate blocks for module %d\n",
-				count);
-			sst_module_free(mod);
-			return ret;
-		}
-
-		block = (void *)block + sizeof(*block) +
-			le32_to_cpu(block->size);
-	}
-	mod->state = SST_MODULE_STATE_LOADED;
-
-	return 0;
-}
-
-static int hsw_parse_fw_image(struct sst_fw *sst_fw)
-{
-	struct fw_header *header;
-	struct fw_module_header *module;
-	struct sst_dsp *dsp = sst_fw->dsp;
-	int ret, count;
-
-	/* Read the header information from the data pointer */
-	header = (struct fw_header *)sst_fw->dma_buf;
-
-	/* verify FW */
-	if ((strncmp(header->signature, SST_HSW_FW_SIGN, 4) != 0) ||
-	    (sst_fw->size !=
-	     le32_to_cpu(header->file_size) + sizeof(*header))) {
-		dev_err(dsp->dev, "error: invalid fw sign/filesize mismatch\n");
-		return -EINVAL;
-	}
-
-	dev_dbg(dsp->dev, "header size=0x%x modules=0x%x fmt=0x%x size=%zu\n",
-		header->file_size, header->modules,
-		header->file_format, sizeof(*header));
-
-	/* parse each module */
-	module = (void *)sst_fw->dma_buf + sizeof(*header);
-	for (count = 0; count < le32_to_cpu(header->modules); count++) {
-
-		/* module */
-		ret = hsw_parse_module(dsp, sst_fw, module);
-		if (ret < 0) {
-			dev_err(dsp->dev, "error: invalid module %d\n", count);
-			return ret;
-		}
-		module = (void *)module + sizeof(*module) +
-			le32_to_cpu(module->mod_size);
-	}
-
-	return 0;
-}
-
-static irqreturn_t hsw_irq(int irq, void *context)
-{
-	struct sst_dsp *sst = (struct sst_dsp *) context;
-	u32 isr;
-	int ret = IRQ_NONE;
-
-	spin_lock(&sst->spinlock);
-
-	/* Interrupt arrived, check src */
-	isr = sst_dsp_shim_read_unlocked(sst, SST_ISRX);
-	if (isr & SST_ISRX_DONE) {
-		trace_sst_irq_done(isr,
-			sst_dsp_shim_read_unlocked(sst, SST_IMRX));
-
-		/* Mask Done interrupt before return */
-		sst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,
-			SST_IMRX_DONE, SST_IMRX_DONE);
-		ret = IRQ_WAKE_THREAD;
-	}
-
-	if (isr & SST_ISRX_BUSY) {
-		trace_sst_irq_busy(isr,
-			sst_dsp_shim_read_unlocked(sst, SST_IMRX));
-
-		/* Mask Busy interrupt before return */
-		sst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,
-			SST_IMRX_BUSY, SST_IMRX_BUSY);
-		ret = IRQ_WAKE_THREAD;
-	}
-
-	spin_unlock(&sst->spinlock);
-	return ret;
-}
-
-static void hsw_set_dsp_D3(struct sst_dsp *sst)
-{
-	u32 val;
-	u32 reg;
-
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg &= ~(SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE);
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	/* enable power gating and switch off DRAM & IRAM blocks */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
-	val |= SST_VDRTCL0_DSRAMPGE_MASK |
-		SST_VDRTCL0_ISRAMPGE_MASK;
-	val &= ~(SST_VDRTCL0_D3PGD | SST_VDRTCL0_D3SRAMPGD);
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL0);
-
-	/* switch off audio PLL */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val |= SST_VDRTCL2_APLLSE_MASK;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	/* disable MCLK(clkctl.smos = 0) */
-	sst_dsp_shim_update_bits_unlocked(sst, SST_CLKCTL,
-		SST_CLKCTL_MASK, 0);
-
-	/* Set D3 state, delay 50 us */
-	val = readl(sst->addr.pci_cfg + SST_PMCS);
-	val |= SST_PMCS_PS_MASK;
-	writel(val, sst->addr.pci_cfg + SST_PMCS);
-	udelay(50);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg |= SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
-}
-
-static void hsw_reset(struct sst_dsp *sst)
-{
-	/* put DSP into reset and stall */
-	sst_dsp_shim_update_bits_unlocked(sst, SST_CSR,
-		SST_CSR_RST | SST_CSR_STALL,
-		SST_CSR_RST | SST_CSR_STALL);
-
-	/* keep in reset for 10ms */
-	mdelay(10);
-
-	/* take DSP out of reset and keep stalled for FW loading */
-	sst_dsp_shim_update_bits_unlocked(sst, SST_CSR,
-		SST_CSR_RST | SST_CSR_STALL, SST_CSR_STALL);
-}
-
-static int hsw_set_dsp_D0(struct sst_dsp *sst)
-{
-	int tries = 10;
-	u32 reg, fw_dump_bit;
-
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg &= ~(SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE);
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	/* Disable D3PG (VDRTCTL0.D3PGD = 1) */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
-	reg |= SST_VDRTCL0_D3PGD;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL0);
-
-	/* Set D0 state */
-	reg = readl(sst->addr.pci_cfg + SST_PMCS);
-	reg &= ~SST_PMCS_PS_MASK;
-	writel(reg, sst->addr.pci_cfg + SST_PMCS);
-
-	/* check that ADSP shim is enabled */
-	while (tries--) {
-		reg = readl(sst->addr.pci_cfg + SST_PMCS) & SST_PMCS_PS_MASK;
-		if (reg == 0)
-			goto finish;
-
-		msleep(1);
-	}
-
-	return -ENODEV;
-
-finish:
-	/* select SSP1 19.2MHz base clock, SSP clock 0, turn off Low Power Clock */
-	sst_dsp_shim_update_bits_unlocked(sst, SST_CSR,
-		SST_CSR_S1IOCS | SST_CSR_SBCS1 | SST_CSR_LPCS, 0x0);
-
-	/* stall DSP core, set clk to 192/96Mhz */
-	sst_dsp_shim_update_bits_unlocked(sst,
-		SST_CSR, SST_CSR_STALL | SST_CSR_DCS_MASK,
-		SST_CSR_STALL | SST_CSR_DCS(4));
-
-	/* Set 24MHz MCLK, prevent local clock gating, enable SSP0 clock */
-	sst_dsp_shim_update_bits_unlocked(sst, SST_CLKCTL,
-		SST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0,
-		SST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0);
-
-	/* Stall and reset core, set CSR */
-	hsw_reset(sst);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg |= SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
-	/* switch on audio PLL */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg &= ~SST_VDRTCL2_APLLSE_MASK;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	/* set default power gating control, enable power gating control for all blocks. that is,
-	can't be accessed, please enable each block before accessing. */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
-	reg |= SST_VDRTCL0_DSRAMPGE_MASK | SST_VDRTCL0_ISRAMPGE_MASK;
-	/* for D0, always enable the block(DSRAM[0]) used for FW dump */
-	fw_dump_bit = 1 << SST_VDRTCL0_DSRAMPGE_SHIFT;
-	writel(reg & ~fw_dump_bit, sst->addr.pci_cfg + SST_VDRTCTL0);
-
-
-	/* disable DMA finish function for SSP0 & SSP1 */
-	sst_dsp_shim_update_bits_unlocked(sst, SST_CSR2, SST_CSR2_SDFD_SSP1,
-		SST_CSR2_SDFD_SSP1);
-
-	/* set on-demond mode on engine 0,1 for all channels */
-	sst_dsp_shim_update_bits(sst, SST_HMDC,
-			SST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH,
-			SST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH);
-
-	/* Enable Interrupt from both sides */
-	sst_dsp_shim_update_bits(sst, SST_IMRX, (SST_IMRX_BUSY | SST_IMRX_DONE),
-				 0x0);
-	sst_dsp_shim_update_bits(sst, SST_IMRD, (SST_IMRD_DONE | SST_IMRD_BUSY |
-				SST_IMRD_SSP0 | SST_IMRD_DMAC), 0x0);
-
-	/* clear IPC registers */
-	sst_dsp_shim_write(sst, SST_IPCX, 0x0);
-	sst_dsp_shim_write(sst, SST_IPCD, 0x0);
-	sst_dsp_shim_write(sst, 0x80, 0x6);
-	sst_dsp_shim_write(sst, 0xe0, 0x300a);
-
-	return 0;
-}
-
-static void hsw_boot(struct sst_dsp *sst)
-{
-	/* set oportunistic mode on engine 0,1 for all channels */
-	sst_dsp_shim_update_bits(sst, SST_HMDC,
-			SST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH, 0);
-
-	/* set DSP to RUN */
-	sst_dsp_shim_update_bits_unlocked(sst, SST_CSR, SST_CSR_STALL, 0x0);
-}
-
-static void hsw_stall(struct sst_dsp *sst)
-{
-	/* stall DSP */
-	sst_dsp_shim_update_bits(sst, SST_CSR,
-		SST_CSR_24MHZ_LPCS | SST_CSR_STALL,
-		SST_CSR_STALL | SST_CSR_24MHZ_LPCS);
-}
-
-static void hsw_sleep(struct sst_dsp *sst)
-{
-	dev_dbg(sst->dev, "HSW_PM dsp runtime suspend\n");
-
-	/* put DSP into reset and stall */
-	sst_dsp_shim_update_bits(sst, SST_CSR,
-		SST_CSR_24MHZ_LPCS | SST_CSR_RST | SST_CSR_STALL,
-		SST_CSR_RST | SST_CSR_STALL | SST_CSR_24MHZ_LPCS);
-
-	hsw_set_dsp_D3(sst);
-	dev_dbg(sst->dev, "HSW_PM dsp runtime suspend exit\n");
-}
-
-static int hsw_wake(struct sst_dsp *sst)
-{
-	int ret;
-
-	dev_dbg(sst->dev, "HSW_PM dsp runtime resume\n");
-
-	ret = hsw_set_dsp_D0(sst);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(sst->dev, "HSW_PM dsp runtime resume exit\n");
-
-	return 0;
-}
-
-struct sst_adsp_memregion {
-	u32 start;
-	u32 end;
-	int blocks;
-	enum sst_mem_type type;
-};
-
-/* lynx point ADSP mem regions */
-static const struct sst_adsp_memregion lp_region[] = {
-	{0x00000, 0x40000, 8, SST_MEM_DRAM}, /* D-SRAM0 - 8 * 32kB */
-	{0x40000, 0x80000, 8, SST_MEM_DRAM}, /* D-SRAM1 - 8 * 32kB */
-	{0x80000, 0xE0000, 12, SST_MEM_IRAM}, /* I-SRAM - 12 * 32kB */
-};
-
-/* wild cat point ADSP mem regions */
-static const struct sst_adsp_memregion wpt_region[] = {
-	{0x00000, 0xA0000, 20, SST_MEM_DRAM}, /* D-SRAM0,D-SRAM1,D-SRAM2 - 20 * 32kB */
-	{0xA0000, 0xF0000, 10, SST_MEM_IRAM}, /* I-SRAM - 10 * 32kB */
-};
-
-static int hsw_acpi_resource_map(struct sst_dsp *sst, struct sst_pdata *pdata)
-{
-	/* ADSP DRAM & IRAM */
-	sst->addr.lpe_base = pdata->lpe_base;
-	sst->addr.lpe = ioremap(pdata->lpe_base, pdata->lpe_size);
-	if (!sst->addr.lpe)
-		return -ENODEV;
-
-	/* ADSP PCI MMIO config space */
-	sst->addr.pci_cfg = ioremap(pdata->pcicfg_base, pdata->pcicfg_size);
-	if (!sst->addr.pci_cfg) {
-		iounmap(sst->addr.lpe);
-		return -ENODEV;
-	}
-
-	/* SST Shim */
-	sst->addr.shim = sst->addr.lpe + sst->addr.shim_offset;
-	return 0;
-}
-
-struct sst_sram_shift {
-	u32 dev_id;	/* SST Device IDs  */
-	u32 iram_shift;
-	u32 dram_shift;
-};
-
-static const struct sst_sram_shift sram_shift[] = {
-	{SST_DEV_ID_LYNX_POINT, 6, 16}, /* lp */
-	{SST_DEV_ID_WILDCAT_POINT, 2, 12}, /* wpt */
-};
-
-static u32 hsw_block_get_bit(struct sst_mem_block *block)
-{
-	u32 bit = 0, shift = 0, index;
-	struct sst_dsp *sst = block->dsp;
-
-	for (index = 0; index < ARRAY_SIZE(sram_shift); index++) {
-		if (sram_shift[index].dev_id == sst->id)
-			break;
-	}
-
-	if (index < ARRAY_SIZE(sram_shift)) {
-		switch (block->type) {
-		case SST_MEM_DRAM:
-			shift = sram_shift[index].dram_shift;
-			break;
-		case SST_MEM_IRAM:
-			shift = sram_shift[index].iram_shift;
-			break;
-		default:
-			shift = 0;
-		}
-	} else
-		shift = 0;
-
-	bit = 1 << (block->index + shift);
-
-	return bit;
-}
-
-/*dummy read a SRAM block.*/
-static void sst_mem_block_dummy_read(struct sst_mem_block *block)
-{
-	u32 size;
-	u8 tmp_buf[4];
-	struct sst_dsp *sst = block->dsp;
-
-	size = block->size > 4 ? 4 : block->size;
-	memcpy_fromio(tmp_buf, sst->addr.lpe + block->offset, size);
-}
-
-/* enable 32kB memory block - locks held by caller */
-static int hsw_block_enable(struct sst_mem_block *block)
-{
-	struct sst_dsp *sst = block->dsp;
-	u32 bit, val;
-
-	if (block->users++ > 0)
-		return 0;
-
-	dev_dbg(block->dsp->dev, " enabled block %d:%d at offset 0x%x\n",
-		block->type, block->index, block->offset);
-
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val &= ~SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
-	bit = hsw_block_get_bit(block);
-	writel(val & ~bit, sst->addr.pci_cfg + SST_VDRTCTL0);
-
-	/* wait 18 DSP clock ticks */
-	udelay(10);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val |= SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
-	/*add a dummy read before the SRAM block is written, otherwise the writing may miss bytes sometimes.*/
-	sst_mem_block_dummy_read(block);
-	return 0;
-}
-
-/* disable 32kB memory block - locks held by caller */
-static int hsw_block_disable(struct sst_mem_block *block)
-{
-	struct sst_dsp *sst = block->dsp;
-	u32 bit, val;
-
-	if (--block->users > 0)
-		return 0;
-
-	dev_dbg(block->dsp->dev, " disabled block %d:%d at offset 0x%x\n",
-		block->type, block->index, block->offset);
-
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val &= ~SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
-	bit = hsw_block_get_bit(block);
-	/* don't disable DSRAM[0], keep it always enable for FW dump*/
-	if (bit != (1 << SST_VDRTCL0_DSRAMPGE_SHIFT))
-		writel(val | bit, sst->addr.pci_cfg + SST_VDRTCTL0);
-
-	/* wait 18 DSP clock ticks */
-	udelay(10);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val |= SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
-	return 0;
-}
-
-static const struct sst_block_ops sst_hsw_ops = {
-	.enable = hsw_block_enable,
-	.disable = hsw_block_disable,
-};
-
-static int hsw_init(struct sst_dsp *sst, struct sst_pdata *pdata)
-{
-	const struct sst_adsp_memregion *region;
-	struct device *dev;
-	int ret = -ENODEV, i, j, region_count;
-	u32 offset, size, fw_dump_bit;
-
-	dev = sst->dma_dev;
-
-	switch (sst->id) {
-	case SST_DEV_ID_LYNX_POINT:
-		region = lp_region;
-		region_count = ARRAY_SIZE(lp_region);
-		sst->addr.iram_offset = SST_LP_IRAM_OFFSET;
-		sst->addr.dsp_iram_offset = SST_LPT_DSP_IRAM_OFFSET;
-		sst->addr.dsp_dram_offset = SST_LPT_DSP_DRAM_OFFSET;
-		sst->addr.shim_offset = SST_LP_SHIM_OFFSET;
-		break;
-	case SST_DEV_ID_WILDCAT_POINT:
-		region = wpt_region;
-		region_count = ARRAY_SIZE(wpt_region);
-		sst->addr.iram_offset = SST_WPT_IRAM_OFFSET;
-		sst->addr.dsp_iram_offset = SST_WPT_DSP_IRAM_OFFSET;
-		sst->addr.dsp_dram_offset = SST_WPT_DSP_DRAM_OFFSET;
-		sst->addr.shim_offset = SST_WPT_SHIM_OFFSET;
-		break;
-	default:
-		dev_err(dev, "error: failed to get mem resources\n");
-		return ret;
-	}
-
-	ret = hsw_acpi_resource_map(sst, pdata);
-	if (ret < 0) {
-		dev_err(dev, "error: failed to map resources\n");
-		return ret;
-	}
-
-	/* enable the DSP SHIM */
-	ret = hsw_set_dsp_D0(sst);
-	if (ret < 0) {
-		dev_err(dev, "error: failed to set DSP D0 and reset SHIM\n");
-		return ret;
-	}
-
-	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(31));
-	if (ret)
-		return ret;
-
-
-	/* register DSP memory blocks - ideally we should get this from ACPI */
-	for (i = 0; i < region_count; i++) {
-		offset = region[i].start;
-		size = (region[i].end - region[i].start) / region[i].blocks;
-
-		/* register individual memory blocks */
-		for (j = 0; j < region[i].blocks; j++) {
-			sst_mem_block_register(sst, offset, size,
-				region[i].type, &sst_hsw_ops, j, sst);
-			offset += size;
-		}
-	}
-
-	/* always enable the block(DSRAM[0]) used for FW dump */
-	fw_dump_bit = 1 << SST_VDRTCL0_DSRAMPGE_SHIFT;
-	/* set default power gating control, enable power gating control for all blocks. that is,
-	can't be accessed, please enable each block before accessing. */
-	writel(0xffffffff & ~fw_dump_bit, sst->addr.pci_cfg + SST_VDRTCTL0);
-
-	return 0;
-}
-
-static void hsw_free(struct sst_dsp *sst)
-{
-	sst_mem_block_unregister_all(sst);
-	iounmap(sst->addr.lpe);
-	iounmap(sst->addr.pci_cfg);
-}
-
-struct sst_ops haswell_ops = {
-	.reset = hsw_reset,
-	.boot = hsw_boot,
-	.stall = hsw_stall,
-	.wake = hsw_wake,
-	.sleep = hsw_sleep,
-	.write = sst_shim32_write,
-	.read = sst_shim32_read,
-	.write64 = sst_shim32_write64,
-	.read64 = sst_shim32_read64,
-	.ram_read = sst_memcpy_fromio_32,
-	.ram_write = sst_memcpy_toio_32,
-	.irq_handler = hsw_irq,
-	.init = hsw_init,
-	.free = hsw_free,
-	.parse_fw = hsw_parse_fw_image,
-};
diff --git a/sound/soc/intel/haswell/sst-haswell-ipc.c b/sound/soc/intel/haswell/sst-haswell-ipc.c
deleted file mode 100644
index 95a50265dff6..000000000000
--- a/sound/soc/intel/haswell/sst-haswell-ipc.c
+++ /dev/null
@@ -1,2222 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- *  Intel SST Haswell/Broadwell IPC Support
- *
- * Copyright (C) 2013, Intel Corporation. All rights reserved.
- */
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/device.h>
-#include <linux/wait.h>
-#include <linux/spinlock.h>
-#include <linux/workqueue.h>
-#include <linux/export.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-#include <linux/dma-mapping.h>
-#include <linux/debugfs.h>
-#include <linux/pm_runtime.h>
-#include <sound/asound.h>
-
-#include "sst-haswell-ipc.h"
-#include "../common/sst-dsp.h"
-#include "../common/sst-dsp-priv.h"
-#include "../common/sst-ipc.h"
-
-/* Global Message - Generic */
-#define IPC_GLB_TYPE_SHIFT	24
-#define IPC_GLB_TYPE_MASK	(0x1f << IPC_GLB_TYPE_SHIFT)
-#define IPC_GLB_TYPE(x)		(x << IPC_GLB_TYPE_SHIFT)
-
-/* Global Message - Reply */
-#define IPC_GLB_REPLY_SHIFT	0
-#define IPC_GLB_REPLY_MASK	(0x1f << IPC_GLB_REPLY_SHIFT)
-#define IPC_GLB_REPLY_TYPE(x)	(x << IPC_GLB_REPLY_TYPE_SHIFT)
-
-/* Stream Message - Generic */
-#define IPC_STR_TYPE_SHIFT	20
-#define IPC_STR_TYPE_MASK	(0xf << IPC_STR_TYPE_SHIFT)
-#define IPC_STR_TYPE(x)		(x << IPC_STR_TYPE_SHIFT)
-#define IPC_STR_ID_SHIFT	16
-#define IPC_STR_ID_MASK		(0xf << IPC_STR_ID_SHIFT)
-#define IPC_STR_ID(x)		(x << IPC_STR_ID_SHIFT)
-
-/* Stream Message - Reply */
-#define IPC_STR_REPLY_SHIFT	0
-#define IPC_STR_REPLY_MASK	(0x1f << IPC_STR_REPLY_SHIFT)
-
-/* Stream Stage Message - Generic */
-#define IPC_STG_TYPE_SHIFT	12
-#define IPC_STG_TYPE_MASK	(0xf << IPC_STG_TYPE_SHIFT)
-#define IPC_STG_TYPE(x)		(x << IPC_STG_TYPE_SHIFT)
-#define IPC_STG_ID_SHIFT	10
-#define IPC_STG_ID_MASK		(0x3 << IPC_STG_ID_SHIFT)
-#define IPC_STG_ID(x)		(x << IPC_STG_ID_SHIFT)
-
-/* Stream Stage Message - Reply */
-#define IPC_STG_REPLY_SHIFT	0
-#define IPC_STG_REPLY_MASK	(0x1f << IPC_STG_REPLY_SHIFT)
-
-/* Debug Log Message - Generic */
-#define IPC_LOG_OP_SHIFT	20
-#define IPC_LOG_OP_MASK		(0xf << IPC_LOG_OP_SHIFT)
-#define IPC_LOG_OP_TYPE(x)	(x << IPC_LOG_OP_SHIFT)
-#define IPC_LOG_ID_SHIFT	16
-#define IPC_LOG_ID_MASK		(0xf << IPC_LOG_ID_SHIFT)
-#define IPC_LOG_ID(x)		(x << IPC_LOG_ID_SHIFT)
-
-/* Module Message */
-#define IPC_MODULE_OPERATION_SHIFT	20
-#define IPC_MODULE_OPERATION_MASK	(0xf << IPC_MODULE_OPERATION_SHIFT)
-#define IPC_MODULE_OPERATION(x)	(x << IPC_MODULE_OPERATION_SHIFT)
-
-#define IPC_MODULE_ID_SHIFT	16
-#define IPC_MODULE_ID_MASK	(0xf << IPC_MODULE_ID_SHIFT)
-#define IPC_MODULE_ID(x)	(x << IPC_MODULE_ID_SHIFT)
-
-/* IPC message timeout (msecs) */
-#define IPC_TIMEOUT_MSECS	300
-#define IPC_BOOT_MSECS		200
-#define IPC_MSG_WAIT		0
-#define IPC_MSG_NOWAIT		1
-
-/* Firmware Ready Message */
-#define IPC_FW_READY		(0x1 << 29)
-#define IPC_STATUS_MASK		(0x3 << 30)
-
-#define IPC_EMPTY_LIST_SIZE	8
-#define IPC_MAX_STREAMS		4
-
-/* Mailbox */
-#define IPC_MAX_MAILBOX_BYTES	256
-
-#define INVALID_STREAM_HW_ID	0xffffffff
-
-/* Global Message - Types and Replies */
-enum ipc_glb_type {
-	IPC_GLB_GET_FW_VERSION = 0,		/* Retrieves firmware version */
-	IPC_GLB_PERFORMANCE_MONITOR = 1,	/* Performance monitoring actions */
-	IPC_GLB_ALLOCATE_STREAM = 3,		/* Request to allocate new stream */
-	IPC_GLB_FREE_STREAM = 4,		/* Request to free stream */
-	IPC_GLB_GET_FW_CAPABILITIES = 5,	/* Retrieves firmware capabilities */
-	IPC_GLB_STREAM_MESSAGE = 6,		/* Message directed to stream or its stages */
-	/* Request to store firmware context during D0->D3 transition */
-	IPC_GLB_REQUEST_DUMP = 7,
-	/* Request to restore firmware context during D3->D0 transition */
-	IPC_GLB_RESTORE_CONTEXT = 8,
-	IPC_GLB_GET_DEVICE_FORMATS = 9,		/* Set device format */
-	IPC_GLB_SET_DEVICE_FORMATS = 10,	/* Get device format */
-	IPC_GLB_SHORT_REPLY = 11,
-	IPC_GLB_ENTER_DX_STATE = 12,
-	IPC_GLB_GET_MIXER_STREAM_INFO = 13,	/* Request mixer stream params */
-	IPC_GLB_DEBUG_LOG_MESSAGE = 14,		/* Message to or from the debug logger. */
-	IPC_GLB_MODULE_OPERATION = 15,		/* Message to loadable fw module */
-	IPC_GLB_REQUEST_TRANSFER = 16, 		/* < Request Transfer for host */
-	IPC_GLB_MAX_IPC_MESSAGE_TYPE = 17,	/* Maximum message number */
-};
-
-enum ipc_glb_reply {
-	IPC_GLB_REPLY_SUCCESS = 0,		/* The operation was successful. */
-	IPC_GLB_REPLY_ERROR_INVALID_PARAM = 1,	/* Invalid parameter was passed. */
-	IPC_GLB_REPLY_UNKNOWN_MESSAGE_TYPE = 2,	/* Uknown message type was resceived. */
-	IPC_GLB_REPLY_OUT_OF_RESOURCES = 3,	/* No resources to satisfy the request. */
-	IPC_GLB_REPLY_BUSY = 4,			/* The system or resource is busy. */
-	IPC_GLB_REPLY_PENDING = 5,		/* The action was scheduled for processing.  */
-	IPC_GLB_REPLY_FAILURE = 6,		/* Critical error happened. */
-	IPC_GLB_REPLY_INVALID_REQUEST = 7,	/* Request can not be completed. */
-	IPC_GLB_REPLY_STAGE_UNINITIALIZED = 8,	/* Processing stage was uninitialized. */
-	IPC_GLB_REPLY_NOT_FOUND = 9,		/* Required resource can not be found. */
-	IPC_GLB_REPLY_SOURCE_NOT_STARTED = 10,	/* Source was not started. */
-};
-
-enum ipc_module_operation {
-	IPC_MODULE_NOTIFICATION = 0,
-	IPC_MODULE_ENABLE = 1,
-	IPC_MODULE_DISABLE = 2,
-	IPC_MODULE_GET_PARAMETER = 3,
-	IPC_MODULE_SET_PARAMETER = 4,
-	IPC_MODULE_GET_INFO = 5,
-	IPC_MODULE_MAX_MESSAGE
-};
-
-/* Stream Message - Types */
-enum ipc_str_operation {
-	IPC_STR_RESET = 0,
-	IPC_STR_PAUSE = 1,
-	IPC_STR_RESUME = 2,
-	IPC_STR_STAGE_MESSAGE = 3,
-	IPC_STR_NOTIFICATION = 4,
-	IPC_STR_MAX_MESSAGE
-};
-
-/* Stream Stage Message Types */
-enum ipc_stg_operation {
-	IPC_STG_GET_VOLUME = 0,
-	IPC_STG_SET_VOLUME,
-	IPC_STG_SET_WRITE_POSITION,
-	IPC_STG_SET_FX_ENABLE,
-	IPC_STG_SET_FX_DISABLE,
-	IPC_STG_SET_FX_GET_PARAM,
-	IPC_STG_SET_FX_SET_PARAM,
-	IPC_STG_SET_FX_GET_INFO,
-	IPC_STG_MUTE_LOOPBACK,
-	IPC_STG_MAX_MESSAGE
-};
-
-/* Stream Stage Message Types For Notification*/
-enum ipc_stg_operation_notify {
-	IPC_POSITION_CHANGED = 0,
-	IPC_STG_GLITCH,
-	IPC_STG_MAX_NOTIFY
-};
-
-enum ipc_glitch_type {
-	IPC_GLITCH_UNDERRUN = 1,
-	IPC_GLITCH_DECODER_ERROR,
-	IPC_GLITCH_DOUBLED_WRITE_POS,
-	IPC_GLITCH_MAX
-};
-
-/* Debug Control */
-enum ipc_debug_operation {
-	IPC_DEBUG_ENABLE_LOG = 0,
-	IPC_DEBUG_DISABLE_LOG = 1,
-	IPC_DEBUG_REQUEST_LOG_DUMP = 2,
-	IPC_DEBUG_NOTIFY_LOG_DUMP = 3,
-	IPC_DEBUG_MAX_DEBUG_LOG
-};
-
-/* Firmware Ready */
-struct sst_hsw_ipc_fw_ready {
-	u32 inbox_offset;
-	u32 outbox_offset;
-	u32 inbox_size;
-	u32 outbox_size;
-	u32 fw_info_size;
-	u8 fw_info[IPC_MAX_MAILBOX_BYTES - 5 * sizeof(u32)];
-} __attribute__((packed));
-
-struct sst_hsw_stream;
-struct sst_hsw;
-
-/* Stream infomation */
-struct sst_hsw_stream {
-	/* configuration */
-	struct sst_hsw_ipc_stream_alloc_req request;
-	struct sst_hsw_ipc_stream_alloc_reply reply;
-	struct sst_hsw_ipc_stream_free_req free_req;
-
-	/* Mixer info */
-	u32 mute_volume[SST_HSW_NO_CHANNELS];
-	u32 mute[SST_HSW_NO_CHANNELS];
-
-	/* runtime info */
-	struct sst_hsw *hsw;
-	int host_id;
-	bool commited;
-	bool running;
-
-	/* Notification work */
-	struct work_struct notify_work;
-	u32 header;
-
-	/* Position info from DSP */
-	struct sst_hsw_ipc_stream_set_position wpos;
-	struct sst_hsw_ipc_stream_get_position rpos;
-	struct sst_hsw_ipc_stream_glitch_position glitch;
-
-	/* Volume info */
-	struct sst_hsw_ipc_volume_req vol_req;
-
-	/* driver callback */
-	u32 (*notify_position)(struct sst_hsw_stream *stream, void *data);
-	void *pdata;
-
-	/* record the fw read position when playback */
-	snd_pcm_uframes_t old_position;
-	bool play_silence;
-	struct list_head node;
-};
-
-/* FW log ring information */
-struct sst_hsw_log_stream {
-	dma_addr_t dma_addr;
-	unsigned char *dma_area;
-	unsigned char *ring_descr;
-	int pages;
-	int size;
-
-	/* Notification work */
-	struct work_struct notify_work;
-	wait_queue_head_t readers_wait_q;
-	struct mutex rw_mutex;
-
-	u32 last_pos;
-	u32 curr_pos;
-	u32 reader_pos;
-
-	/* fw log config */
-	u32 config[SST_HSW_FW_LOG_CONFIG_DWORDS];
-
-	struct sst_hsw *hsw;
-};
-
-/* SST Haswell IPC data */
-struct sst_hsw {
-	struct device *dev;
-	struct sst_dsp *dsp;
-	struct platform_device *pdev_pcm;
-
-	/* FW config */
-	struct sst_hsw_ipc_fw_ready fw_ready;
-	struct sst_hsw_ipc_fw_version version;
-	bool fw_done;
-	struct sst_fw *sst_fw;
-
-	/* stream */
-	struct list_head stream_list;
-
-	/* global mixer */
-	struct sst_hsw_ipc_stream_info_reply mixer_info;
-	enum sst_hsw_volume_curve curve_type;
-	u32 curve_duration;
-	u32 mute[SST_HSW_NO_CHANNELS];
-	u32 mute_volume[SST_HSW_NO_CHANNELS];
-
-	/* DX */
-	struct sst_hsw_ipc_dx_reply dx;
-	void *dx_context;
-	dma_addr_t dx_context_paddr;
-	enum sst_hsw_device_id dx_dev;
-	enum sst_hsw_device_mclk dx_mclk;
-	enum sst_hsw_device_mode dx_mode;
-	u32 dx_clock_divider;
-
-	/* boot */
-	wait_queue_head_t boot_wait;
-	bool boot_complete;
-	bool shutdown;
-
-	/* IPC messaging */
-	struct sst_generic_ipc ipc;
-
-	/* FW log stream */
-	struct sst_hsw_log_stream log_stream;
-
-	/* flags bit field to track module state when resume from RTD3,
-	 * each bit represent state (enabled/disabled) of single module */
-	u32 enabled_modules_rtd3;
-
-	/* buffer to store parameter lines */
-	u32 param_idx_w;	/* write index */
-	u32 param_idx_r;	/* read index */
-	u8 param_buf[WAVES_PARAM_LINES][WAVES_PARAM_COUNT];
-};
-
-#define CREATE_TRACE_POINTS
-#include <trace/events/hswadsp.h>
-
-static inline u32 msg_get_global_type(u32 msg)
-{
-	return (msg & IPC_GLB_TYPE_MASK) >> IPC_GLB_TYPE_SHIFT;
-}
-
-static inline u32 msg_get_global_reply(u32 msg)
-{
-	return (msg & IPC_GLB_REPLY_MASK) >> IPC_GLB_REPLY_SHIFT;
-}
-
-static inline u32 msg_get_stream_type(u32 msg)
-{
-	return (msg & IPC_STR_TYPE_MASK) >>  IPC_STR_TYPE_SHIFT;
-}
-
-static inline u32 msg_get_stream_id(u32 msg)
-{
-	return (msg & IPC_STR_ID_MASK) >>  IPC_STR_ID_SHIFT;
-}
-
-static inline u32 msg_get_notify_reason(u32 msg)
-{
-	return (msg & IPC_STG_TYPE_MASK) >> IPC_STG_TYPE_SHIFT;
-}
-
-static inline u32 msg_get_module_operation(u32 msg)
-{
-	return (msg & IPC_MODULE_OPERATION_MASK) >> IPC_MODULE_OPERATION_SHIFT;
-}
-
-static inline u32 msg_get_module_id(u32 msg)
-{
-	return (msg & IPC_MODULE_ID_MASK) >> IPC_MODULE_ID_SHIFT;
-}
-
-u32 create_channel_map(enum sst_hsw_channel_config config)
-{
-	switch (config) {
-	case SST_HSW_CHANNEL_CONFIG_MONO:
-		return (0xFFFFFFF0 | SST_HSW_CHANNEL_CENTER);
-	case SST_HSW_CHANNEL_CONFIG_STEREO:
-		return (0xFFFFFF00 | SST_HSW_CHANNEL_LEFT
-			| (SST_HSW_CHANNEL_RIGHT << 4));
-	case SST_HSW_CHANNEL_CONFIG_2_POINT_1:
-		return (0xFFFFF000 | SST_HSW_CHANNEL_LEFT
-			| (SST_HSW_CHANNEL_RIGHT << 4)
-			| (SST_HSW_CHANNEL_LFE << 8 ));
-	case SST_HSW_CHANNEL_CONFIG_3_POINT_0:
-		return (0xFFFFF000 | SST_HSW_CHANNEL_LEFT
-			| (SST_HSW_CHANNEL_CENTER << 4)
-			| (SST_HSW_CHANNEL_RIGHT << 8));
-	case SST_HSW_CHANNEL_CONFIG_3_POINT_1:
-		return (0xFFFF0000 | SST_HSW_CHANNEL_LEFT
-			| (SST_HSW_CHANNEL_CENTER << 4)
-			| (SST_HSW_CHANNEL_RIGHT << 8)
-			| (SST_HSW_CHANNEL_LFE << 12));
-	case SST_HSW_CHANNEL_CONFIG_QUATRO:
-		return (0xFFFF0000 | SST_HSW_CHANNEL_LEFT
-			| (SST_HSW_CHANNEL_RIGHT << 4)
-			| (SST_HSW_CHANNEL_LEFT_SURROUND << 8)
-			| (SST_HSW_CHANNEL_RIGHT_SURROUND << 12));
-	case SST_HSW_CHANNEL_CONFIG_4_POINT_0:
-		return (0xFFFF0000 | SST_HSW_CHANNEL_LEFT
-			| (SST_HSW_CHANNEL_CENTER << 4)
-			| (SST_HSW_CHANNEL_RIGHT << 8)
-			| (SST_HSW_CHANNEL_CENTER_SURROUND << 12));
-	case SST_HSW_CHANNEL_CONFIG_5_POINT_0:
-		return (0xFFF00000 | SST_HSW_CHANNEL_LEFT
-			| (SST_HSW_CHANNEL_CENTER << 4)
-			| (SST_HSW_CHANNEL_RIGHT << 8)
-			| (SST_HSW_CHANNEL_LEFT_SURROUND << 12)
-			| (SST_HSW_CHANNEL_RIGHT_SURROUND << 16));
-	case SST_HSW_CHANNEL_CONFIG_5_POINT_1:
-		return (0xFF000000 | SST_HSW_CHANNEL_CENTER
-			| (SST_HSW_CHANNEL_LEFT << 4)
-			| (SST_HSW_CHANNEL_RIGHT << 8)
-			| (SST_HSW_CHANNEL_LEFT_SURROUND << 12)
-			| (SST_HSW_CHANNEL_RIGHT_SURROUND << 16)
-			| (SST_HSW_CHANNEL_LFE << 20));
-	case SST_HSW_CHANNEL_CONFIG_DUAL_MONO:
-		return (0xFFFFFF00 | SST_HSW_CHANNEL_LEFT
-			| (SST_HSW_CHANNEL_LEFT << 4));
-	default:
-		return 0xFFFFFFFF;
-	}
-}
-
-static struct sst_hsw_stream *get_stream_by_id(struct sst_hsw *hsw,
-	int stream_id)
-{
-	struct sst_hsw_stream *stream;
-
-	list_for_each_entry(stream, &hsw->stream_list, node) {
-		if (stream->reply.stream_hw_id == stream_id)
-			return stream;
-	}
-
-	return NULL;
-}
-
-static void hsw_fw_ready(struct sst_hsw *hsw, u32 header)
-{
-	struct sst_hsw_ipc_fw_ready fw_ready;
-	u32 offset;
-	u8 fw_info[IPC_MAX_MAILBOX_BYTES - 5 * sizeof(u32)];
-	char *tmp[5], *pinfo;
-	int i;
-
-	offset = (header & 0x1FFFFFFF) << 3;
-
-	dev_dbg(hsw->dev, "ipc: DSP is ready 0x%8.8x offset %d\n",
-		header, offset);
-
-	/* copy data from the DSP FW ready offset */
-	sst_dsp_read(hsw->dsp, &fw_ready, offset, sizeof(fw_ready));
-
-	sst_dsp_mailbox_init(hsw->dsp, fw_ready.inbox_offset,
-		fw_ready.inbox_size, fw_ready.outbox_offset,
-		fw_ready.outbox_size);
-
-	hsw->boot_complete = true;
-	wake_up(&hsw->boot_wait);
-
-	dev_dbg(hsw->dev, " mailbox upstream 0x%x - size 0x%x\n",
-		fw_ready.inbox_offset, fw_ready.inbox_size);
-	dev_dbg(hsw->dev, " mailbox downstream 0x%x - size 0x%x\n",
-		fw_ready.outbox_offset, fw_ready.outbox_size);
-	if (fw_ready.fw_info_size < sizeof(fw_ready.fw_info)) {
-		fw_ready.fw_info[fw_ready.fw_info_size] = 0;
-		dev_dbg(hsw->dev, " Firmware info: %s \n", fw_ready.fw_info);
-
-		/* log the FW version info got from the mailbox here. */
-		memcpy(fw_info, fw_ready.fw_info, fw_ready.fw_info_size);
-		pinfo = &fw_info[0];
-		for (i = 0; i < ARRAY_SIZE(tmp); i++)
-			tmp[i] = strsep(&pinfo, " ");
-		dev_info(hsw->dev, "FW loaded, mailbox readback FW info: type %s, - "
-			"version: %s.%s, build %s, source commit id: %s\n",
-			tmp[0], tmp[1], tmp[2], tmp[3], tmp[4]);
-	}
-}
-
-static void hsw_notification_work(struct work_struct *work)
-{
-	struct sst_hsw_stream *stream = container_of(work,
-			struct sst_hsw_stream, notify_work);
-	struct sst_hsw_ipc_stream_glitch_position *glitch = &stream->glitch;
-	struct sst_hsw_ipc_stream_get_position *pos = &stream->rpos;
-	struct sst_hsw *hsw = stream->hsw;
-	u32 reason;
-
-	reason = msg_get_notify_reason(stream->header);
-
-	switch (reason) {
-	case IPC_STG_GLITCH:
-		trace_ipc_notification("DSP stream under/overrun",
-			stream->reply.stream_hw_id);
-		sst_dsp_inbox_read(hsw->dsp, glitch, sizeof(*glitch));
-
-		dev_err(hsw->dev, "glitch %d pos 0x%x write pos 0x%x\n",
-			glitch->glitch_type, glitch->present_pos,
-			glitch->write_pos);
-		break;
-
-	case IPC_POSITION_CHANGED:
-		trace_ipc_notification("DSP stream position changed for",
-			stream->reply.stream_hw_id);
-		sst_dsp_inbox_read(hsw->dsp, pos, sizeof(*pos));
-
-		if (stream->notify_position)
-			stream->notify_position(stream, stream->pdata);
-
-		break;
-	default:
-		dev_err(hsw->dev, "error: unknown notification 0x%x\n",
-			stream->header);
-		break;
-	}
-
-	/* tell DSP that notification has been handled */
-	sst_dsp_shim_update_bits(hsw->dsp, SST_IPCD,
-		SST_IPCD_BUSY | SST_IPCD_DONE, SST_IPCD_DONE);
-
-	/* unmask busy interrupt */
-	sst_dsp_shim_update_bits(hsw->dsp, SST_IMRX, SST_IMRX_BUSY, 0);
-}
-
-static void hsw_stream_update(struct sst_hsw *hsw, struct ipc_message *msg)
-{
-	struct sst_hsw_stream *stream;
-	u32 header = msg->tx.header & ~(IPC_STATUS_MASK | IPC_GLB_REPLY_MASK);
-	u32 stream_id = msg_get_stream_id(header);
-	u32 stream_msg = msg_get_stream_type(header);
-
-	stream = get_stream_by_id(hsw, stream_id);
-	if (stream == NULL)
-		return;
-
-	switch (stream_msg) {
-	case IPC_STR_STAGE_MESSAGE:
-	case IPC_STR_NOTIFICATION:
-		break;
-	case IPC_STR_RESET:
-		trace_ipc_notification("stream reset", stream->reply.stream_hw_id);
-		break;
-	case IPC_STR_PAUSE:
-		stream->running = false;
-		trace_ipc_notification("stream paused",
-			stream->reply.stream_hw_id);
-		break;
-	case IPC_STR_RESUME:
-		stream->running = true;
-		trace_ipc_notification("stream running",
-			stream->reply.stream_hw_id);
-		break;
-	}
-}
-
-static int hsw_process_reply(struct sst_hsw *hsw, u32 header)
-{
-	struct ipc_message *msg;
-	u32 reply = msg_get_global_reply(header);
-
-	trace_ipc_reply("processing -->", header);
-
-	msg = sst_ipc_reply_find_msg(&hsw->ipc, header);
-	if (msg == NULL) {
-		trace_ipc_error("error: can't find message header", header);
-		return -EIO;
-	}
-
-	msg->rx.header = header;
-	/* first process the header */
-	switch (reply) {
-	case IPC_GLB_REPLY_PENDING:
-		trace_ipc_pending_reply("received", header);
-		msg->pending = true;
-		hsw->ipc.pending = true;
-		return 1;
-	case IPC_GLB_REPLY_SUCCESS:
-		if (msg->pending) {
-			trace_ipc_pending_reply("completed", header);
-			sst_dsp_inbox_read(hsw->dsp, msg->rx.data,
-				msg->rx.size);
-			hsw->ipc.pending = false;
-		} else {
-			/* copy data from the DSP */
-			sst_dsp_outbox_read(hsw->dsp, msg->rx.data,
-				msg->rx.size);
-		}
-		break;
-	/* these will be rare - but useful for debug */
-	case IPC_GLB_REPLY_UNKNOWN_MESSAGE_TYPE:
-		trace_ipc_error("error: unknown message type", header);
-		msg->errno = -EBADMSG;
-		break;
-	case IPC_GLB_REPLY_OUT_OF_RESOURCES:
-		trace_ipc_error("error: out of resources", header);
-		msg->errno = -ENOMEM;
-		break;
-	case IPC_GLB_REPLY_BUSY:
-		trace_ipc_error("error: reply busy", header);
-		msg->errno = -EBUSY;
-		break;
-	case IPC_GLB_REPLY_FAILURE:
-		trace_ipc_error("error: reply failure", header);
-		msg->errno = -EINVAL;
-		break;
-	case IPC_GLB_REPLY_STAGE_UNINITIALIZED:
-		trace_ipc_error("error: stage uninitialized", header);
-		msg->errno = -EINVAL;
-		break;
-	case IPC_GLB_REPLY_NOT_FOUND:
-		trace_ipc_error("error: reply not found", header);
-		msg->errno = -EINVAL;
-		break;
-	case IPC_GLB_REPLY_SOURCE_NOT_STARTED:
-		trace_ipc_error("error: source not started", header);
-		msg->errno = -EINVAL;
-		break;
-	case IPC_GLB_REPLY_INVALID_REQUEST:
-		trace_ipc_error("error: invalid request", header);
-		msg->errno = -EINVAL;
-		break;
-	case IPC_GLB_REPLY_ERROR_INVALID_PARAM:
-		trace_ipc_error("error: invalid parameter", header);
-		msg->errno = -EINVAL;
-		break;
-	default:
-		trace_ipc_error("error: unknown reply", header);
-		msg->errno = -EINVAL;
-		break;
-	}
-
-	/* update any stream states */
-	if (msg_get_global_type(header) == IPC_GLB_STREAM_MESSAGE)
-		hsw_stream_update(hsw, msg);
-
-	/* wake up and return the error if we have waiters on this message ? */
-	list_del(&msg->list);
-	sst_ipc_tx_msg_reply_complete(&hsw->ipc, msg);
-
-	return 1;
-}
-
-static int hsw_module_message(struct sst_hsw *hsw, u32 header)
-{
-	u32 operation, module_id;
-	int handled = 0;
-
-	operation = msg_get_module_operation(header);
-	module_id = msg_get_module_id(header);
-	dev_dbg(hsw->dev, "received module message header: 0x%8.8x\n",
-			header);
-	dev_dbg(hsw->dev, "operation: 0x%8.8x module_id: 0x%8.8x\n",
-			operation, module_id);
-
-	switch (operation) {
-	case IPC_MODULE_NOTIFICATION:
-		dev_dbg(hsw->dev, "module notification received");
-		handled = 1;
-		break;
-	default:
-		handled = hsw_process_reply(hsw, header);
-		break;
-	}
-
-	return handled;
-}
-
-static int hsw_stream_message(struct sst_hsw *hsw, u32 header)
-{
-	u32 stream_msg, stream_id;
-	struct sst_hsw_stream *stream;
-	int handled = 0;
-
-	stream_msg = msg_get_stream_type(header);
-	stream_id = msg_get_stream_id(header);
-
-	stream = get_stream_by_id(hsw, stream_id);
-	if (stream == NULL)
-		return handled;
-
-	stream->header = header;
-
-	switch (stream_msg) {
-	case IPC_STR_STAGE_MESSAGE:
-		dev_err(hsw->dev, "error: stage msg not implemented 0x%8.8x\n",
-			header);
-		break;
-	case IPC_STR_NOTIFICATION:
-		schedule_work(&stream->notify_work);
-		break;
-	default:
-		/* handle pending message complete request */
-		handled = hsw_process_reply(hsw, header);
-		break;
-	}
-
-	return handled;
-}
-
-static int hsw_log_message(struct sst_hsw *hsw, u32 header)
-{
-	u32 operation = (header & IPC_LOG_OP_MASK) >>  IPC_LOG_OP_SHIFT;
-	struct sst_hsw_log_stream *stream = &hsw->log_stream;
-	int ret = 1;
-
-	if (operation != IPC_DEBUG_REQUEST_LOG_DUMP) {
-		dev_err(hsw->dev,
-			"error: log msg not implemented 0x%8.8x\n", header);
-		return 0;
-	}
-
-	mutex_lock(&stream->rw_mutex);
-	stream->last_pos = stream->curr_pos;
-	sst_dsp_inbox_read(
-		hsw->dsp, &stream->curr_pos, sizeof(stream->curr_pos));
-	mutex_unlock(&stream->rw_mutex);
-
-	schedule_work(&stream->notify_work);
-
-	return ret;
-}
-
-static int hsw_process_notification(struct sst_hsw *hsw)
-{
-	struct sst_dsp *sst = hsw->dsp;
-	u32 type, header;
-	int handled = 1;
-
-	header = sst_dsp_shim_read_unlocked(sst, SST_IPCD);
-	type = msg_get_global_type(header);
-
-	trace_ipc_request("processing -->", header);
-
-	/* FW Ready is a special case */
-	if (!hsw->boot_complete && header & IPC_FW_READY) {
-		hsw_fw_ready(hsw, header);
-		return handled;
-	}
-
-	switch (type) {
-	case IPC_GLB_GET_FW_VERSION:
-	case IPC_GLB_ALLOCATE_STREAM:
-	case IPC_GLB_FREE_STREAM:
-	case IPC_GLB_GET_FW_CAPABILITIES:
-	case IPC_GLB_REQUEST_DUMP:
-	case IPC_GLB_GET_DEVICE_FORMATS:
-	case IPC_GLB_SET_DEVICE_FORMATS:
-	case IPC_GLB_ENTER_DX_STATE:
-	case IPC_GLB_GET_MIXER_STREAM_INFO:
-	case IPC_GLB_MAX_IPC_MESSAGE_TYPE:
-	case IPC_GLB_RESTORE_CONTEXT:
-	case IPC_GLB_SHORT_REPLY:
-		dev_err(hsw->dev, "error: message type %d header 0x%x\n",
-			type, header);
-		break;
-	case IPC_GLB_STREAM_MESSAGE:
-		handled = hsw_stream_message(hsw, header);
-		break;
-	case IPC_GLB_DEBUG_LOG_MESSAGE:
-		handled = hsw_log_message(hsw, header);
-		break;
-	case IPC_GLB_MODULE_OPERATION:
-		handled = hsw_module_message(hsw, header);
-		break;
-	default:
-		dev_err(hsw->dev, "error: unexpected type %d hdr 0x%8.8x\n",
-			type, header);
-		break;
-	}
-
-	return handled;
-}
-
-static irqreturn_t hsw_irq_thread(int irq, void *context)
-{
-	struct sst_dsp *sst = (struct sst_dsp *) context;
-	struct sst_hsw *hsw = sst_dsp_get_thread_context(sst);
-	struct sst_generic_ipc *ipc = &hsw->ipc;
-	u32 ipcx, ipcd;
-	unsigned long flags;
-
-	spin_lock_irqsave(&sst->spinlock, flags);
-
-	ipcx = sst_dsp_ipc_msg_rx(hsw->dsp);
-	ipcd = sst_dsp_shim_read_unlocked(sst, SST_IPCD);
-
-	/* reply message from DSP */
-	if (ipcx & SST_IPCX_DONE) {
-
-		/* Handle Immediate reply from DSP Core */
-		hsw_process_reply(hsw, ipcx);
-
-		/* clear DONE bit - tell DSP we have completed */
-		sst_dsp_shim_update_bits_unlocked(sst, SST_IPCX,
-			SST_IPCX_DONE, 0);
-
-		/* unmask Done interrupt */
-		sst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,
-			SST_IMRX_DONE, 0);
-	}
-
-	/* new message from DSP */
-	if (ipcd & SST_IPCD_BUSY) {
-
-		/* Handle Notification and Delayed reply from DSP Core */
-		hsw_process_notification(hsw);
-
-		/* clear BUSY bit and set DONE bit - accept new messages */
-		sst_dsp_shim_update_bits_unlocked(sst, SST_IPCD,
-			SST_IPCD_BUSY | SST_IPCD_DONE, SST_IPCD_DONE);
-
-		/* unmask busy interrupt */
-		sst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,
-			SST_IMRX_BUSY, 0);
-	}
-
-	spin_unlock_irqrestore(&sst->spinlock, flags);
-
-	/* continue to send any remaining messages... */
-	schedule_work(&ipc->kwork);
-
-	return IRQ_HANDLED;
-}
-
-int sst_hsw_fw_get_version(struct sst_hsw *hsw,
-	struct sst_hsw_ipc_fw_version *version)
-{
-	struct sst_ipc_message request = {0}, reply = {0};
-	int ret;
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_GET_FW_VERSION);
-	reply.data = version;
-	reply.size = sizeof(*version);
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, &reply);
-	if (ret < 0)
-		dev_err(hsw->dev, "error: get version failed\n");
-
-	return ret;
-}
-
-/* Mixer Controls */
-int sst_hsw_stream_get_volume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u32 stage_id, u32 channel, u32 *volume)
-{
-	if (channel > 1)
-		return -EINVAL;
-
-	sst_dsp_read(hsw->dsp, volume,
-		stream->reply.volume_register_address[channel],
-		sizeof(*volume));
-
-	return 0;
-}
-
-/* stream volume */
-int sst_hsw_stream_set_volume(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 volume)
-{
-	struct sst_hsw_ipc_volume_req *req;
-	struct sst_ipc_message request;
-	int ret;
-
-	trace_ipc_request("set stream volume", stream->reply.stream_hw_id);
-
-	if (channel >= 2 && channel != SST_HSW_CHANNELS_ALL)
-		return -EINVAL;
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_STREAM_MESSAGE) |
-		IPC_STR_TYPE(IPC_STR_STAGE_MESSAGE);
-	request.header |= (stream->reply.stream_hw_id << IPC_STR_ID_SHIFT);
-	request.header |= (IPC_STG_SET_VOLUME << IPC_STG_TYPE_SHIFT);
-	request.header |= (stage_id << IPC_STG_ID_SHIFT);
-
-	req = &stream->vol_req;
-	req->target_volume = volume;
-
-	/* set both at same time ? */
-	if (channel == SST_HSW_CHANNELS_ALL) {
-		if (hsw->mute[0] && hsw->mute[1]) {
-			hsw->mute_volume[0] = hsw->mute_volume[1] = volume;
-			return 0;
-		} else if (hsw->mute[0])
-			req->channel = 1;
-		else if (hsw->mute[1])
-			req->channel = 0;
-		else
-			req->channel = SST_HSW_CHANNELS_ALL;
-	} else {
-		/* set only 1 channel */
-		if (hsw->mute[channel]) {
-			hsw->mute_volume[channel] = volume;
-			return 0;
-		}
-		req->channel = channel;
-	}
-
-	request.data = req;
-	request.size = sizeof(*req);
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, NULL);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: set stream volume failed\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-int sst_hsw_mixer_get_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
-	u32 *volume)
-{
-	if (channel > 1)
-		return -EINVAL;
-
-	sst_dsp_read(hsw->dsp, volume,
-		hsw->mixer_info.volume_register_address[channel],
-		sizeof(*volume));
-
-	return 0;
-}
-
-/* global mixer volume */
-int sst_hsw_mixer_set_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
-	u32 volume)
-{
-	struct sst_hsw_ipc_volume_req req;
-	struct sst_ipc_message request;
-	int ret;
-
-	trace_ipc_request("set mixer volume", volume);
-
-	if (channel >= 2 && channel != SST_HSW_CHANNELS_ALL)
-		return -EINVAL;
-
-	/* set both at same time ? */
-	if (channel == SST_HSW_CHANNELS_ALL) {
-		if (hsw->mute[0] && hsw->mute[1]) {
-			hsw->mute_volume[0] = hsw->mute_volume[1] = volume;
-			return 0;
-		} else if (hsw->mute[0])
-			req.channel = 1;
-		else if (hsw->mute[1])
-			req.channel = 0;
-		else
-			req.channel = SST_HSW_CHANNELS_ALL;
-	} else {
-		/* set only 1 channel */
-		if (hsw->mute[channel]) {
-			hsw->mute_volume[channel] = volume;
-			return 0;
-		}
-		req.channel = channel;
-	}
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_STREAM_MESSAGE) |
-		IPC_STR_TYPE(IPC_STR_STAGE_MESSAGE);
-	request.header |= (hsw->mixer_info.mixer_hw_id << IPC_STR_ID_SHIFT);
-	request.header |= (IPC_STG_SET_VOLUME << IPC_STG_TYPE_SHIFT);
-	request.header |= (stage_id << IPC_STG_ID_SHIFT);
-
-	req.curve_duration = hsw->curve_duration;
-	req.curve_type = hsw->curve_type;
-	req.target_volume = volume;
-
-	request.data = &req;
-	request.size = sizeof(req);
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, NULL);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: set mixer volume failed\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-/* Stream API */
-struct sst_hsw_stream *sst_hsw_stream_new(struct sst_hsw *hsw, int id,
-	u32 (*notify_position)(struct sst_hsw_stream *stream, void *data),
-	void *data)
-{
-	struct sst_hsw_stream *stream;
-	struct sst_dsp *sst = hsw->dsp;
-	unsigned long flags;
-
-	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
-	if (stream == NULL)
-		return NULL;
-
-	spin_lock_irqsave(&sst->spinlock, flags);
-	stream->reply.stream_hw_id = INVALID_STREAM_HW_ID;
-	list_add(&stream->node, &hsw->stream_list);
-	stream->notify_position = notify_position;
-	stream->pdata = data;
-	stream->hsw = hsw;
-	stream->host_id = id;
-
-	/* work to process notification messages */
-	INIT_WORK(&stream->notify_work, hsw_notification_work);
-	spin_unlock_irqrestore(&sst->spinlock, flags);
-
-	return stream;
-}
-
-int sst_hsw_stream_free(struct sst_hsw *hsw, struct sst_hsw_stream *stream)
-{
-	struct sst_ipc_message request;
-	int ret = 0;
-	struct sst_dsp *sst = hsw->dsp;
-	unsigned long flags;
-
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to free, ignore it.\n");
-		return 0;
-	}
-
-	/* dont free DSP streams that are not commited */
-	if (!stream->commited)
-		goto out;
-
-	trace_ipc_request("stream free", stream->host_id);
-
-	stream->free_req.stream_id = stream->reply.stream_hw_id;
-	request.header = IPC_GLB_TYPE(IPC_GLB_FREE_STREAM);
-	request.data = &stream->free_req;
-	request.size = sizeof(stream->free_req);
-
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, NULL);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: free stream %d failed\n",
-			stream->free_req.stream_id);
-		return -EAGAIN;
-	}
-
-	trace_hsw_stream_free_req(stream, &stream->free_req);
-
-out:
-	cancel_work_sync(&stream->notify_work);
-	spin_lock_irqsave(&sst->spinlock, flags);
-	list_del(&stream->node);
-	kfree(stream);
-	spin_unlock_irqrestore(&sst->spinlock, flags);
-
-	return ret;
-}
-
-int sst_hsw_stream_set_bits(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, enum sst_hsw_bitdepth bits)
-{
-	if (stream->commited) {
-		dev_err(hsw->dev, "error: stream committed for set bits\n");
-		return -EINVAL;
-	}
-
-	stream->request.format.bitdepth = bits;
-	return 0;
-}
-
-int sst_hsw_stream_set_channels(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, int channels)
-{
-	if (stream->commited) {
-		dev_err(hsw->dev, "error: stream committed for set channels\n");
-		return -EINVAL;
-	}
-
-	stream->request.format.ch_num = channels;
-	return 0;
-}
-
-int sst_hsw_stream_set_rate(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, int rate)
-{
-	if (stream->commited) {
-		dev_err(hsw->dev, "error: stream committed for set rate\n");
-		return -EINVAL;
-	}
-
-	stream->request.format.frequency = rate;
-	return 0;
-}
-
-int sst_hsw_stream_set_map_config(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 map,
-	enum sst_hsw_channel_config config)
-{
-	if (stream->commited) {
-		dev_err(hsw->dev, "error: stream committed for set map\n");
-		return -EINVAL;
-	}
-
-	stream->request.format.map = map;
-	stream->request.format.config = config;
-	return 0;
-}
-
-int sst_hsw_stream_set_style(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, enum sst_hsw_interleaving style)
-{
-	if (stream->commited) {
-		dev_err(hsw->dev, "error: stream committed for set style\n");
-		return -EINVAL;
-	}
-
-	stream->request.format.style = style;
-	return 0;
-}
-
-int sst_hsw_stream_set_valid(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 bits)
-{
-	if (stream->commited) {
-		dev_err(hsw->dev, "error: stream committed for set valid bits\n");
-		return -EINVAL;
-	}
-
-	stream->request.format.valid_bit = bits;
-	return 0;
-}
-
-/* Stream Configuration */
-int sst_hsw_stream_format(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	enum sst_hsw_stream_path_id path_id,
-	enum sst_hsw_stream_type stream_type,
-	enum sst_hsw_stream_format format_id)
-{
-	if (stream->commited) {
-		dev_err(hsw->dev, "error: stream committed for set format\n");
-		return -EINVAL;
-	}
-
-	stream->request.path_id = path_id;
-	stream->request.stream_type = stream_type;
-	stream->request.format_id = format_id;
-
-	trace_hsw_stream_alloc_request(stream, &stream->request);
-
-	return 0;
-}
-
-int sst_hsw_stream_buffer(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u32 ring_pt_address, u32 num_pages,
-	u32 ring_size, u32 ring_offset, u32 ring_first_pfn)
-{
-	if (stream->commited) {
-		dev_err(hsw->dev, "error: stream committed for buffer\n");
-		return -EINVAL;
-	}
-
-	stream->request.ringinfo.ring_pt_address = ring_pt_address;
-	stream->request.ringinfo.num_pages = num_pages;
-	stream->request.ringinfo.ring_size = ring_size;
-	stream->request.ringinfo.ring_offset = ring_offset;
-	stream->request.ringinfo.ring_first_pfn = ring_first_pfn;
-
-	trace_hsw_stream_buffer(stream);
-
-	return 0;
-}
-
-int sst_hsw_stream_set_module_info(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, struct sst_module_runtime *runtime)
-{
-	struct sst_hsw_module_map *map = &stream->request.map;
-	struct sst_dsp *dsp = sst_hsw_get_dsp(hsw);
-	struct sst_module *module = runtime->module;
-
-	if (stream->commited) {
-		dev_err(hsw->dev, "error: stream committed for set module\n");
-		return -EINVAL;
-	}
-
-	/* only support initial module atm */
-	map->module_entries_count = 1;
-	map->module_entries[0].module_id = module->id;
-	map->module_entries[0].entry_point = module->entry;
-
-	stream->request.persistent_mem.offset =
-		sst_dsp_get_offset(dsp, runtime->persistent_offset, SST_MEM_DRAM);
-	stream->request.persistent_mem.size = module->persistent_size;
-
-	stream->request.scratch_mem.offset =
-		sst_dsp_get_offset(dsp, dsp->scratch_offset, SST_MEM_DRAM);
-	stream->request.scratch_mem.size = dsp->scratch_size;
-
-	dev_dbg(hsw->dev, "module %d runtime %d using:\n", module->id,
-		runtime->id);
-	dev_dbg(hsw->dev, " persistent offset 0x%x bytes 0x%x\n",
-		stream->request.persistent_mem.offset,
-		stream->request.persistent_mem.size);
-	dev_dbg(hsw->dev, " scratch offset 0x%x bytes 0x%x\n",
-		stream->request.scratch_mem.offset,
-		stream->request.scratch_mem.size);
-
-	return 0;
-}
-
-int sst_hsw_stream_commit(struct sst_hsw *hsw, struct sst_hsw_stream *stream)
-{
-	struct sst_ipc_message request, reply = {0};
-	int ret;
-
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to commit, ignore it.\n");
-		return 0;
-	}
-
-	if (stream->commited) {
-		dev_warn(hsw->dev, "warning: stream is already committed, ignore it.\n");
-		return 0;
-	}
-
-	trace_ipc_request("stream alloc", stream->host_id);
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_ALLOCATE_STREAM);
-	request.data = &stream->request;
-	request.size = sizeof(stream->request);
-	reply.data = &stream->reply;
-	reply.size = sizeof(stream->reply);
-
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, &reply);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: stream commit failed\n");
-		return ret;
-	}
-
-	stream->commited = true;
-	trace_hsw_stream_alloc_reply(stream);
-
-	return 0;
-}
-
-snd_pcm_uframes_t sst_hsw_stream_get_old_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream)
-{
-	return stream->old_position;
-}
-
-void sst_hsw_stream_set_old_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, snd_pcm_uframes_t val)
-{
-	stream->old_position = val;
-}
-
-bool sst_hsw_stream_get_silence_start(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream)
-{
-	return stream->play_silence;
-}
-
-void sst_hsw_stream_set_silence_start(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, bool val)
-{
-	stream->play_silence = val;
-}
-
-/* Stream Information - these calls could be inline but we want the IPC
- ABI to be opaque to client PCM drivers to cope with any future ABI changes */
-int sst_hsw_mixer_get_info(struct sst_hsw *hsw)
-{
-	struct sst_ipc_message request = {0}, reply = {0};
-	int ret;
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_GET_MIXER_STREAM_INFO);
-	reply.data = &hsw->mixer_info;
-	reply.size = sizeof(hsw->mixer_info);
-
-	trace_ipc_request("get global mixer info", 0);
-
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, &reply);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: get stream info failed\n");
-		return ret;
-	}
-
-	trace_hsw_mixer_info_reply(&hsw->mixer_info);
-
-	return 0;
-}
-
-/* Send stream command */
-static int sst_hsw_stream_operations(struct sst_hsw *hsw, int type,
-	int stream_id, int wait)
-{
-	struct sst_ipc_message request = {0};
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_STREAM_MESSAGE);
-	request.header |= IPC_STR_TYPE(type) | (stream_id << IPC_STR_ID_SHIFT);
-
-	if (wait)
-		return sst_ipc_tx_message_wait(&hsw->ipc, request, NULL);
-	else
-		return sst_ipc_tx_message_nowait(&hsw->ipc, request);
-}
-
-/* Stream ALSA trigger operations */
-int sst_hsw_stream_pause(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	int wait)
-{
-	int ret;
-
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to pause, ignore it.\n");
-		return 0;
-	}
-
-	trace_ipc_request("stream pause", stream->reply.stream_hw_id);
-
-	ret = sst_hsw_stream_operations(hsw, IPC_STR_PAUSE,
-		stream->reply.stream_hw_id, wait);
-	if (ret < 0)
-		dev_err(hsw->dev, "error: failed to pause stream %d\n",
-			stream->reply.stream_hw_id);
-
-	return ret;
-}
-
-int sst_hsw_stream_resume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	int wait)
-{
-	int ret;
-
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to resume, ignore it.\n");
-		return 0;
-	}
-
-	trace_ipc_request("stream resume", stream->reply.stream_hw_id);
-
-	ret = sst_hsw_stream_operations(hsw, IPC_STR_RESUME,
-		stream->reply.stream_hw_id, wait);
-	if (ret < 0)
-		dev_err(hsw->dev, "error: failed to resume stream %d\n",
-			stream->reply.stream_hw_id);
-
-	return ret;
-}
-
-int sst_hsw_stream_reset(struct sst_hsw *hsw, struct sst_hsw_stream *stream)
-{
-	int ret, tries = 10;
-
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to reset, ignore it.\n");
-		return 0;
-	}
-
-	/* dont reset streams that are not commited */
-	if (!stream->commited)
-		return 0;
-
-	/* wait for pause to complete before we reset the stream */
-	while (stream->running && --tries)
-		msleep(1);
-	if (!tries) {
-		dev_err(hsw->dev, "error: reset stream %d still running\n",
-			stream->reply.stream_hw_id);
-		return -EINVAL;
-	}
-
-	trace_ipc_request("stream reset", stream->reply.stream_hw_id);
-
-	ret = sst_hsw_stream_operations(hsw, IPC_STR_RESET,
-		stream->reply.stream_hw_id, 1);
-	if (ret < 0)
-		dev_err(hsw->dev, "error: failed to reset stream %d\n",
-			stream->reply.stream_hw_id);
-	return ret;
-}
-
-/* Stream pointer positions */
-u32 sst_hsw_get_dsp_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream)
-{
-	u32 rpos;
-
-	sst_dsp_read(hsw->dsp, &rpos,
-		stream->reply.read_position_register_address, sizeof(rpos));
-
-	return rpos;
-}
-
-/* Stream presentation (monotonic) positions */
-u64 sst_hsw_get_dsp_presentation_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream)
-{
-	u64 ppos;
-
-	sst_dsp_read(hsw->dsp, &ppos,
-		stream->reply.presentation_position_register_address,
-		sizeof(ppos));
-
-	return ppos;
-}
-
-/* physical BE config */
-int sst_hsw_device_set_config(struct sst_hsw *hsw,
-	enum sst_hsw_device_id dev, enum sst_hsw_device_mclk mclk,
-	enum sst_hsw_device_mode mode, u32 clock_divider)
-{
-	struct sst_ipc_message request;
-	struct sst_hsw_ipc_device_config_req config;
-	int ret;
-
-	trace_ipc_request("set device config", dev);
-
-	hsw->dx_dev = config.ssp_interface = dev;
-	hsw->dx_mclk = config.clock_frequency = mclk;
-	hsw->dx_mode = config.mode = mode;
-	hsw->dx_clock_divider = config.clock_divider = clock_divider;
-	if (mode == SST_HSW_DEVICE_TDM_CLOCK_MASTER)
-		config.channels = 4;
-	else
-		config.channels = 2;
-
-	trace_hsw_device_config_req(&config);
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_SET_DEVICE_FORMATS);
-	request.data = &config;
-	request.size = sizeof(config);
-
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, NULL);
-	if (ret < 0)
-		dev_err(hsw->dev, "error: set device formats failed\n");
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(sst_hsw_device_set_config);
-
-/* DX Config */
-int sst_hsw_dx_set_state(struct sst_hsw *hsw,
-	enum sst_hsw_dx_state state, struct sst_hsw_ipc_dx_reply *dx)
-{
-	struct sst_ipc_message request, reply = {0};
-	u32 state_;
-	int ret, item;
-
-	state_ = state;
-	request.header = IPC_GLB_TYPE(IPC_GLB_ENTER_DX_STATE);
-	request.data = &state_;
-	request.size = sizeof(state_);
-	reply.data = dx;
-	reply.size = sizeof(*dx);
-
-	trace_ipc_request("PM enter Dx state", state);
-
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, &reply);
-	if (ret < 0) {
-		dev_err(hsw->dev, "ipc: error set dx state %d failed\n", state);
-		return ret;
-	}
-
-	for (item = 0; item < dx->entries_no; item++) {
-		dev_dbg(hsw->dev,
-			"Item[%d] offset[%x] - size[%x] - source[%x]\n",
-			item, dx->mem_info[item].offset,
-			dx->mem_info[item].size,
-			dx->mem_info[item].source);
-	}
-	dev_dbg(hsw->dev, "ipc: got %d entry numbers for state %d\n",
-		dx->entries_no, state);
-
-	return ret;
-}
-
-struct sst_module_runtime *sst_hsw_runtime_module_create(struct sst_hsw *hsw,
-	int mod_id, int offset)
-{
-	struct sst_dsp *dsp = hsw->dsp;
-	struct sst_module *module;
-	struct sst_module_runtime *runtime;
-	int err;
-
-	module = sst_module_get_from_id(dsp, mod_id);
-	if (module == NULL) {
-		dev_err(dsp->dev, "error: failed to get module %d for pcm\n",
-			mod_id);
-		return NULL;
-	}
-
-	runtime = sst_module_runtime_new(module, mod_id, NULL);
-	if (runtime == NULL) {
-		dev_err(dsp->dev, "error: failed to create module %d runtime\n",
-			mod_id);
-		return NULL;
-	}
-
-	err = sst_module_runtime_alloc_blocks(runtime, offset);
-	if (err < 0) {
-		dev_err(dsp->dev, "error: failed to alloc blocks for module %d runtime\n",
-			mod_id);
-		sst_module_runtime_free(runtime);
-		return NULL;
-	}
-
-	dev_dbg(dsp->dev, "runtime id %d created for module %d\n", runtime->id,
-		mod_id);
-	return runtime;
-}
-
-void sst_hsw_runtime_module_free(struct sst_module_runtime *runtime)
-{
-	sst_module_runtime_free_blocks(runtime);
-	sst_module_runtime_free(runtime);
-}
-
-#ifdef CONFIG_PM
-static int sst_hsw_dx_state_dump(struct sst_hsw *hsw)
-{
-	struct sst_dsp *sst = hsw->dsp;
-	u32 item, offset, size;
-	int ret = 0;
-
-	trace_ipc_request("PM state dump. Items #", SST_HSW_MAX_DX_REGIONS);
-
-	if (hsw->dx.entries_no > SST_HSW_MAX_DX_REGIONS) {
-		dev_err(hsw->dev,
-			"error: number of FW context regions greater than %d\n",
-			SST_HSW_MAX_DX_REGIONS);
-		memset(&hsw->dx, 0, sizeof(hsw->dx));
-		return -EINVAL;
-	}
-
-	ret = sst_dsp_dma_get_channel(sst, 0);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: can't allocate dma channel %d\n", ret);
-		return ret;
-	}
-
-	/* set on-demond mode on engine 0 channel 3 */
-	sst_dsp_shim_update_bits(sst, SST_HMDC,
-			SST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH,
-			SST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH);
-
-	for (item = 0; item < hsw->dx.entries_no; item++) {
-		if (hsw->dx.mem_info[item].source == SST_HSW_DX_TYPE_MEMORY_DUMP
-			&& hsw->dx.mem_info[item].offset > DSP_DRAM_ADDR_OFFSET
-			&& hsw->dx.mem_info[item].offset <
-			DSP_DRAM_ADDR_OFFSET + SST_HSW_DX_CONTEXT_SIZE) {
-
-			offset = hsw->dx.mem_info[item].offset
-					- DSP_DRAM_ADDR_OFFSET;
-			size = (hsw->dx.mem_info[item].size + 3) & (~3);
-
-			ret = sst_dsp_dma_copyfrom(sst, hsw->dx_context_paddr + offset,
-				sst->addr.lpe_base + offset, size);
-			if (ret < 0) {
-				dev_err(hsw->dev,
-					"error: FW context dump failed\n");
-				memset(&hsw->dx, 0, sizeof(hsw->dx));
-				goto out;
-			}
-		}
-	}
-
-out:
-	sst_dsp_dma_put_channel(sst);
-	return ret;
-}
-
-static int sst_hsw_dx_state_restore(struct sst_hsw *hsw)
-{
-	struct sst_dsp *sst = hsw->dsp;
-	u32 item, offset, size;
-	int ret;
-
-	for (item = 0; item < hsw->dx.entries_no; item++) {
-		if (hsw->dx.mem_info[item].source == SST_HSW_DX_TYPE_MEMORY_DUMP
-			&& hsw->dx.mem_info[item].offset > DSP_DRAM_ADDR_OFFSET
-			&& hsw->dx.mem_info[item].offset <
-			DSP_DRAM_ADDR_OFFSET + SST_HSW_DX_CONTEXT_SIZE) {
-
-			offset = hsw->dx.mem_info[item].offset
-					- DSP_DRAM_ADDR_OFFSET;
-			size = (hsw->dx.mem_info[item].size + 3) & (~3);
-
-			ret = sst_dsp_dma_copyto(sst, sst->addr.lpe_base + offset,
-				hsw->dx_context_paddr + offset, size);
-			if (ret < 0) {
-				dev_err(hsw->dev,
-					"error: FW context restore failed\n");
-				return ret;
-			}
-		}
-	}
-
-	return 0;
-}
-
-int sst_hsw_dsp_load(struct sst_hsw *hsw)
-{
-	struct sst_dsp *dsp = hsw->dsp;
-	struct sst_fw *sst_fw, *t;
-	int ret;
-
-	dev_dbg(hsw->dev, "loading audio DSP....");
-
-	ret = sst_dsp_wake(dsp);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: failed to wake audio DSP\n");
-		return -ENODEV;
-	}
-
-	ret = sst_dsp_dma_get_channel(dsp, 0);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: can't allocate dma channel %d\n", ret);
-		return ret;
-	}
-
-	list_for_each_entry_safe_reverse(sst_fw, t, &dsp->fw_list, list) {
-		ret = sst_fw_reload(sst_fw);
-		if (ret < 0) {
-			dev_err(hsw->dev, "error: SST FW reload failed\n");
-			sst_dsp_dma_put_channel(dsp);
-			return -ENOMEM;
-		}
-	}
-	ret = sst_block_alloc_scratch(hsw->dsp);
-	if (ret < 0)
-		return -EINVAL;
-
-	sst_dsp_dma_put_channel(dsp);
-	return 0;
-}
-
-static int sst_hsw_dsp_restore(struct sst_hsw *hsw)
-{
-	struct sst_dsp *dsp = hsw->dsp;
-	int ret;
-
-	dev_dbg(hsw->dev, "restoring audio DSP....");
-
-	ret = sst_dsp_dma_get_channel(dsp, 0);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: can't allocate dma channel %d\n", ret);
-		return ret;
-	}
-
-	ret = sst_hsw_dx_state_restore(hsw);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: SST FW context restore failed\n");
-		sst_dsp_dma_put_channel(dsp);
-		return -ENOMEM;
-	}
-	sst_dsp_dma_put_channel(dsp);
-
-	/* wait for DSP boot completion */
-	sst_dsp_boot(dsp);
-
-	return ret;
-}
-
-int sst_hsw_dsp_runtime_suspend(struct sst_hsw *hsw)
-{
-	int ret;
-
-	dev_dbg(hsw->dev, "audio dsp runtime suspend\n");
-
-	ret = sst_hsw_dx_set_state(hsw, SST_HSW_DX_STATE_D3, &hsw->dx);
-	if (ret < 0)
-		return ret;
-
-	sst_dsp_stall(hsw->dsp);
-
-	ret = sst_hsw_dx_state_dump(hsw);
-	if (ret < 0)
-		return ret;
-
-	sst_ipc_drop_all(&hsw->ipc);
-
-	return 0;
-}
-
-int sst_hsw_dsp_runtime_sleep(struct sst_hsw *hsw)
-{
-	struct sst_fw *sst_fw, *t;
-	struct sst_dsp *dsp = hsw->dsp;
-
-	list_for_each_entry_safe(sst_fw, t, &dsp->fw_list, list) {
-		sst_fw_unload(sst_fw);
-	}
-	sst_block_free_scratch(dsp);
-
-	hsw->boot_complete = false;
-
-	sst_dsp_sleep(dsp);
-
-	return 0;
-}
-
-int sst_hsw_dsp_runtime_resume(struct sst_hsw *hsw)
-{
-	struct device *dev = hsw->dev;
-	int ret;
-
-	dev_dbg(dev, "audio dsp runtime resume\n");
-
-	if (hsw->boot_complete)
-		return 1; /* tell caller no action is required */
-
-	ret = sst_hsw_dsp_restore(hsw);
-	if (ret < 0)
-		dev_err(dev, "error: audio DSP boot failure\n");
-
-	sst_hsw_init_module_state(hsw);
-
-	ret = wait_event_timeout(hsw->boot_wait, hsw->boot_complete,
-		msecs_to_jiffies(IPC_BOOT_MSECS));
-	if (ret == 0) {
-		dev_err(hsw->dev, "error: audio DSP boot timeout IPCD 0x%x IPCX 0x%x\n",
-			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCD),
-			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCX));
-		return -EIO;
-	}
-
-	/* Set ADSP SSP port settings - sadly the FW does not store SSP port
-	   settings as part of the PM context. */
-	ret = sst_hsw_device_set_config(hsw, hsw->dx_dev, hsw->dx_mclk,
-					hsw->dx_mode, hsw->dx_clock_divider);
-	if (ret < 0)
-		dev_err(dev, "error: SSP re-initialization failed\n");
-
-	return ret;
-}
-#endif
-
-struct sst_dsp *sst_hsw_get_dsp(struct sst_hsw *hsw)
-{
-	return hsw->dsp;
-}
-
-void sst_hsw_init_module_state(struct sst_hsw *hsw)
-{
-	struct sst_module *module;
-	enum sst_hsw_module_id id;
-
-	/* the base fw contains several modules */
-	for (id = SST_HSW_MODULE_BASE_FW; id < SST_HSW_MAX_MODULE_ID; id++) {
-		module = sst_module_get_from_id(hsw->dsp, id);
-		if (module) {
-			/* module waves is active only after being enabled */
-			if (id == SST_HSW_MODULE_WAVES)
-				module->state = SST_MODULE_STATE_INITIALIZED;
-			else
-				module->state = SST_MODULE_STATE_ACTIVE;
-		}
-	}
-}
-
-bool sst_hsw_is_module_loaded(struct sst_hsw *hsw, u32 module_id)
-{
-	struct sst_module *module;
-
-	module = sst_module_get_from_id(hsw->dsp, module_id);
-	if (module == NULL || module->state == SST_MODULE_STATE_UNLOADED)
-		return false;
-	else
-		return true;
-}
-
-bool sst_hsw_is_module_active(struct sst_hsw *hsw, u32 module_id)
-{
-	struct sst_module *module;
-
-	module = sst_module_get_from_id(hsw->dsp, module_id);
-	if (module != NULL && module->state == SST_MODULE_STATE_ACTIVE)
-		return true;
-	else
-		return false;
-}
-
-void sst_hsw_set_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id)
-{
-	hsw->enabled_modules_rtd3 |= (1 << module_id);
-}
-
-void sst_hsw_set_module_disabled_rtd3(struct sst_hsw *hsw, u32 module_id)
-{
-	hsw->enabled_modules_rtd3 &= ~(1 << module_id);
-}
-
-bool sst_hsw_is_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id)
-{
-	return hsw->enabled_modules_rtd3 & (1 << module_id);
-}
-
-void sst_hsw_reset_param_buf(struct sst_hsw *hsw)
-{
-	hsw->param_idx_w = 0;
-	hsw->param_idx_r = 0;
-	memset((void *)hsw->param_buf, 0, sizeof(hsw->param_buf));
-}
-
-int sst_hsw_store_param_line(struct sst_hsw *hsw, u8 *buf)
-{
-	/* save line to the first available position of param buffer */
-	if (hsw->param_idx_w > WAVES_PARAM_LINES - 1) {
-		dev_warn(hsw->dev, "warning: param buffer overflow!\n");
-		return -EPERM;
-	}
-	memcpy(hsw->param_buf[hsw->param_idx_w], buf, WAVES_PARAM_COUNT);
-	hsw->param_idx_w++;
-	return 0;
-}
-
-int sst_hsw_load_param_line(struct sst_hsw *hsw, u8 *buf)
-{
-	u8 id;
-
-	/* read the first matching line from param buffer */
-	while (hsw->param_idx_r < WAVES_PARAM_LINES) {
-		id = hsw->param_buf[hsw->param_idx_r][0];
-		hsw->param_idx_r++;
-		if (buf[0] == id) {
-			memcpy(buf, hsw->param_buf[hsw->param_idx_r],
-				WAVES_PARAM_COUNT);
-			break;
-		}
-	}
-	if (hsw->param_idx_r > WAVES_PARAM_LINES - 1) {
-		dev_dbg(hsw->dev, "end of buffer, roll to the beginning\n");
-		hsw->param_idx_r = 0;
-		return 0;
-	}
-	return 0;
-}
-
-int sst_hsw_launch_param_buf(struct sst_hsw *hsw)
-{
-	int ret, idx;
-
-	if (!sst_hsw_is_module_active(hsw, SST_HSW_MODULE_WAVES)) {
-		dev_dbg(hsw->dev, "module waves is not active\n");
-		return 0;
-	}
-
-	/* put all param lines to DSP through ipc */
-	for (idx = 0; idx < hsw->param_idx_w; idx++) {
-		ret = sst_hsw_module_set_param(hsw,
-			SST_HSW_MODULE_WAVES, 0, hsw->param_buf[idx][0],
-			WAVES_PARAM_COUNT, hsw->param_buf[idx]);
-		if (ret < 0)
-			return ret;
-	}
-	return 0;
-}
-
-int sst_hsw_module_load(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id, char *name)
-{
-	int ret = 0;
-	const struct firmware *fw = NULL;
-	struct sst_fw *hsw_sst_fw;
-	struct sst_module *module;
-	struct device *dev = hsw->dev;
-	struct sst_dsp *dsp = hsw->dsp;
-
-	dev_dbg(dev, "sst_hsw_module_load id=%d, name='%s'", module_id, name);
-
-	module = sst_module_get_from_id(dsp, module_id);
-	if (module == NULL) {
-		/* loading for the first time */
-		if (module_id == SST_HSW_MODULE_BASE_FW) {
-			/* for base module: use fw requested in acpi probe */
-			fw = dsp->pdata->fw;
-			if (!fw) {
-				dev_err(dev, "request Base fw failed\n");
-				return -ENODEV;
-			}
-		} else {
-			/* try and load any other optional modules if they are
-			 * available. Use dev_info instead of dev_err in case
-			 * request firmware failed */
-			ret = request_firmware(&fw, name, dev);
-			if (ret) {
-				dev_info(dev, "fw image %s not available(%d)\n",
-						name, ret);
-				return ret;
-			}
-		}
-		hsw_sst_fw = sst_fw_new(dsp, fw, hsw);
-		if (hsw_sst_fw  == NULL) {
-			dev_err(dev, "error: failed to load firmware\n");
-			ret = -ENOMEM;
-			goto out;
-		}
-		module = sst_module_get_from_id(dsp, module_id);
-		if (module == NULL) {
-			dev_err(dev, "error: no module %d in firmware %s\n",
-					module_id, name);
-		}
-	} else
-		dev_info(dev, "module %d (%s) already loaded\n",
-				module_id, name);
-out:
-	/* release fw, but base fw should be released by acpi driver */
-	if (fw && module_id != SST_HSW_MODULE_BASE_FW)
-		release_firmware(fw);
-
-	return ret;
-}
-
-int sst_hsw_module_enable(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id)
-{
-	int ret;
-	struct sst_ipc_message request;
-	struct sst_hsw_ipc_module_config config;
-	struct sst_module *module;
-	struct sst_module_runtime *runtime;
-	struct device *dev = hsw->dev;
-	struct sst_dsp *dsp = hsw->dsp;
-
-	if (!sst_hsw_is_module_loaded(hsw, module_id)) {
-		dev_dbg(dev, "module %d not loaded\n", module_id);
-		return 0;
-	}
-
-	if (sst_hsw_is_module_active(hsw, module_id)) {
-		dev_info(dev, "module %d already enabled\n", module_id);
-		return 0;
-	}
-
-	module = sst_module_get_from_id(dsp, module_id);
-	if (module == NULL) {
-		dev_err(dev, "module %d not valid\n", module_id);
-		return -ENXIO;
-	}
-
-	runtime = sst_module_runtime_get_from_id(module, module_id);
-	if (runtime == NULL) {
-		dev_err(dev, "runtime %d not valid", module_id);
-		return -ENXIO;
-	}
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_MODULE_OPERATION) |
-			IPC_MODULE_OPERATION(IPC_MODULE_ENABLE) |
-			IPC_MODULE_ID(module_id);
-	dev_dbg(dev, "module enable header: %x\n", (u32)request.header);
-
-	config.map.module_entries_count = 1;
-	config.map.module_entries[0].module_id = module->id;
-	config.map.module_entries[0].entry_point = module->entry;
-
-	config.persistent_mem.offset =
-		sst_dsp_get_offset(dsp,
-			runtime->persistent_offset, SST_MEM_DRAM);
-	config.persistent_mem.size = module->persistent_size;
-
-	config.scratch_mem.offset =
-		sst_dsp_get_offset(dsp,
-			dsp->scratch_offset, SST_MEM_DRAM);
-	config.scratch_mem.size = module->scratch_size;
-	dev_dbg(dev, "mod %d enable p:%d @ %x, s:%d @ %x, ep: %x",
-		config.map.module_entries[0].module_id,
-		config.persistent_mem.size,
-		config.persistent_mem.offset,
-		config.scratch_mem.size, config.scratch_mem.offset,
-		config.map.module_entries[0].entry_point);
-
-	request.data = &config;
-	request.size = sizeof(config);
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, NULL);
-	if (ret < 0)
-		dev_err(dev, "ipc: module enable failed - %d\n", ret);
-	else
-		module->state = SST_MODULE_STATE_ACTIVE;
-
-	return ret;
-}
-
-int sst_hsw_module_disable(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id)
-{
-	int ret;
-	struct sst_ipc_message request = {0};
-	struct sst_module *module;
-	struct device *dev = hsw->dev;
-	struct sst_dsp *dsp = hsw->dsp;
-
-	if (!sst_hsw_is_module_loaded(hsw, module_id)) {
-		dev_dbg(dev, "module %d not loaded\n", module_id);
-		return 0;
-	}
-
-	if (!sst_hsw_is_module_active(hsw, module_id)) {
-		dev_info(dev, "module %d already disabled\n", module_id);
-		return 0;
-	}
-
-	module = sst_module_get_from_id(dsp, module_id);
-	if (module == NULL) {
-		dev_err(dev, "module %d not valid\n", module_id);
-		return -ENXIO;
-	}
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_MODULE_OPERATION) |
-			IPC_MODULE_OPERATION(IPC_MODULE_DISABLE) |
-			IPC_MODULE_ID(module_id);
-
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, NULL);
-	if (ret < 0)
-		dev_err(dev, "module disable failed - %d\n", ret);
-	else
-		module->state = SST_MODULE_STATE_INITIALIZED;
-
-	return ret;
-}
-
-int sst_hsw_module_set_param(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id, u32 parameter_id,
-	u32 param_size, char *param)
-{
-	int ret;
-	struct sst_ipc_message request = {0};
-	u32 payload_size = 0;
-	struct sst_hsw_transfer_parameter *parameter;
-	struct device *dev = hsw->dev;
-
-	request.header = IPC_GLB_TYPE(IPC_GLB_MODULE_OPERATION) |
-			IPC_MODULE_OPERATION(IPC_MODULE_SET_PARAMETER) |
-			IPC_MODULE_ID(module_id);
-	dev_dbg(dev, "sst_hsw_module_set_param header=%x\n",
-			(u32)request.header);
-
-	payload_size = param_size +
-		sizeof(struct sst_hsw_transfer_parameter) -
-		sizeof(struct sst_hsw_transfer_list);
-	dev_dbg(dev, "parameter size : %d\n", param_size);
-	dev_dbg(dev, "payload size   : %d\n", payload_size);
-
-	if (payload_size <= SST_HSW_IPC_MAX_SHORT_PARAMETER_SIZE) {
-		/* short parameter, mailbox can contain data */
-		dev_dbg(dev, "transfer parameter size : %zu\n",
-			request.size);
-
-		request.size = ALIGN(payload_size, 4);
-		dev_dbg(dev, "transfer parameter aligned size : %zu\n",
-			request.size);
-
-		parameter = kzalloc(request.size, GFP_KERNEL);
-		if (parameter == NULL)
-			return -ENOMEM;
-
-		memcpy(parameter->data, param, param_size);
-	} else {
-		dev_warn(dev, "transfer parameter size too large!");
-		return 0;
-	}
-
-	parameter->parameter_id = parameter_id;
-	parameter->data_size = param_size;
-	request.data = parameter;
-
-	ret = sst_ipc_tx_message_wait(&hsw->ipc, request, NULL);
-	if (ret < 0)
-		dev_err(dev, "ipc: module set parameter failed - %d\n", ret);
-
-	kfree(parameter);
-
-	return ret;
-}
-
-static struct sst_dsp_device hsw_dev = {
-	.thread = hsw_irq_thread,
-	.ops = &haswell_ops,
-};
-
-static void hsw_tx_msg(struct sst_generic_ipc *ipc, struct ipc_message *msg)
-{
-	/* send the message */
-	sst_dsp_outbox_write(ipc->dsp, msg->tx.data, msg->tx.size);
-	sst_dsp_ipc_msg_tx(ipc->dsp, msg->tx.header);
-}
-
-static void hsw_shim_dbg(struct sst_generic_ipc *ipc, const char *text)
-{
-	struct sst_dsp *sst = ipc->dsp;
-	u32 isr, ipcd, imrx, ipcx;
-
-	ipcx = sst_dsp_shim_read_unlocked(sst, SST_IPCX);
-	isr = sst_dsp_shim_read_unlocked(sst, SST_ISRX);
-	ipcd = sst_dsp_shim_read_unlocked(sst, SST_IPCD);
-	imrx = sst_dsp_shim_read_unlocked(sst, SST_IMRX);
-
-	dev_err(ipc->dev,
-		"ipc: --%s-- ipcx 0x%8.8x isr 0x%8.8x ipcd 0x%8.8x imrx 0x%8.8x\n",
-		text, ipcx, isr, ipcd, imrx);
-}
-
-static void hsw_tx_data_copy(struct ipc_message *msg, char *tx_data,
-	size_t tx_size)
-{
-	memcpy(msg->tx.data, tx_data, tx_size);
-}
-
-static u64 hsw_reply_msg_match(u64 header, u64 *mask)
-{
-	/* clear reply bits & status bits */
-	header &= ~(IPC_STATUS_MASK | IPC_GLB_REPLY_MASK);
-	*mask = (u64)-1;
-
-	return header;
-}
-
-static bool hsw_is_dsp_busy(struct sst_dsp *dsp)
-{
-	u64 ipcx;
-
-	ipcx = sst_dsp_shim_read_unlocked(dsp, SST_IPCX);
-	return (ipcx & (SST_IPCX_BUSY | SST_IPCX_DONE));
-}
-
-int sst_hsw_dsp_init(struct device *dev, struct sst_pdata *pdata)
-{
-	struct sst_hsw_ipc_fw_version version;
-	struct sst_hsw *hsw;
-	struct sst_generic_ipc *ipc;
-	int ret;
-
-	dev_dbg(dev, "initialising Audio DSP IPC\n");
-
-	hsw = devm_kzalloc(dev, sizeof(*hsw), GFP_KERNEL);
-	if (hsw == NULL)
-		return -ENOMEM;
-
-	hsw->dev = dev;
-
-	ipc = &hsw->ipc;
-	ipc->dev = dev;
-	ipc->ops.tx_msg = hsw_tx_msg;
-	ipc->ops.shim_dbg = hsw_shim_dbg;
-	ipc->ops.tx_data_copy = hsw_tx_data_copy;
-	ipc->ops.reply_msg_match = hsw_reply_msg_match;
-	ipc->ops.is_dsp_busy = hsw_is_dsp_busy;
-
-	ipc->tx_data_max_size = IPC_MAX_MAILBOX_BYTES;
-	ipc->rx_data_max_size = IPC_MAX_MAILBOX_BYTES;
-
-	ret = sst_ipc_init(ipc);
-	if (ret != 0)
-		goto ipc_init_err;
-
-	INIT_LIST_HEAD(&hsw->stream_list);
-	init_waitqueue_head(&hsw->boot_wait);
-	hsw_dev.thread_context = hsw;
-
-	/* init SST shim */
-	hsw->dsp = sst_dsp_new(dev, &hsw_dev, pdata);
-	if (hsw->dsp == NULL) {
-		ret = -ENODEV;
-		goto dsp_new_err;
-	}
-
-	ipc->dsp = hsw->dsp;
-
-	/* allocate DMA buffer for context storage */
-	hsw->dx_context = dma_alloc_coherent(hsw->dsp->dma_dev,
-		SST_HSW_DX_CONTEXT_SIZE, &hsw->dx_context_paddr, GFP_KERNEL);
-	if (hsw->dx_context == NULL) {
-		ret = -ENOMEM;
-		goto dma_err;
-	}
-
-	/* keep the DSP in reset state for base FW loading */
-	sst_dsp_reset(hsw->dsp);
-
-	/* load base module and other modules in base firmware image */
-	ret = sst_hsw_module_load(hsw, SST_HSW_MODULE_BASE_FW, 0, "Base");
-	if (ret < 0)
-		goto fw_err;
-
-	/* try to load module waves */
-	sst_hsw_module_load(hsw, SST_HSW_MODULE_WAVES, 0, "intel/IntcPP01.bin");
-
-	/* allocate scratch mem regions */
-	ret = sst_block_alloc_scratch(hsw->dsp);
-	if (ret < 0)
-		goto boot_err;
-
-	/* init param buffer */
-	sst_hsw_reset_param_buf(hsw);
-
-	/* wait for DSP boot completion */
-	sst_dsp_boot(hsw->dsp);
-	ret = wait_event_timeout(hsw->boot_wait, hsw->boot_complete,
-		msecs_to_jiffies(IPC_BOOT_MSECS));
-	if (ret == 0) {
-		ret = -EIO;
-		dev_err(hsw->dev, "error: audio DSP boot timeout IPCD 0x%x IPCX 0x%x\n",
-			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCD),
-			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCX));
-		goto boot_err;
-	}
-
-	/* init module state after boot */
-	sst_hsw_init_module_state(hsw);
-
-	/* get the FW version */
-	sst_hsw_fw_get_version(hsw, &version);
-
-	/* get the globalmixer */
-	ret = sst_hsw_mixer_get_info(hsw);
-	if (ret < 0) {
-		dev_err(hsw->dev, "error: failed to get stream info\n");
-		goto boot_err;
-	}
-
-	pdata->dsp = hsw;
-	return 0;
-
-boot_err:
-	sst_dsp_reset(hsw->dsp);
-	sst_fw_free_all(hsw->dsp);
-fw_err:
-	dma_free_coherent(hsw->dsp->dma_dev, SST_HSW_DX_CONTEXT_SIZE,
-			hsw->dx_context, hsw->dx_context_paddr);
-dma_err:
-	sst_dsp_free(hsw->dsp);
-dsp_new_err:
-	sst_ipc_fini(ipc);
-ipc_init_err:
-	return ret;
-}
-EXPORT_SYMBOL_GPL(sst_hsw_dsp_init);
-
-void sst_hsw_dsp_free(struct device *dev, struct sst_pdata *pdata)
-{
-	struct sst_hsw *hsw = pdata->dsp;
-
-	sst_dsp_reset(hsw->dsp);
-	sst_fw_free_all(hsw->dsp);
-	dma_free_coherent(hsw->dsp->dma_dev, SST_HSW_DX_CONTEXT_SIZE,
-			hsw->dx_context, hsw->dx_context_paddr);
-	sst_dsp_free(hsw->dsp);
-	sst_ipc_fini(&hsw->ipc);
-}
-EXPORT_SYMBOL_GPL(sst_hsw_dsp_free);
diff --git a/sound/soc/intel/haswell/sst-haswell-ipc.h b/sound/soc/intel/haswell/sst-haswell-ipc.h
deleted file mode 100644
index 646dbbba327b..000000000000
--- a/sound/soc/intel/haswell/sst-haswell-ipc.h
+++ /dev/null
@@ -1,527 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Intel SST Haswell/Broadwell IPC Support
- *
- * Copyright (C) 2013, Intel Corporation. All rights reserved.
- */
-
-#ifndef __SST_HASWELL_IPC_H
-#define __SST_HASWELL_IPC_H
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <sound/asound.h>
-
-#define DRV_NAME "haswell-dai"
-
-#define SST_HSW_NO_CHANNELS		4
-#define SST_HSW_MAX_DX_REGIONS		14
-#define SST_HSW_DX_CONTEXT_SIZE        (640 * 1024)
-#define SST_HSW_CHANNELS_ALL		0xffffffff
-
-#define SST_HSW_FW_LOG_CONFIG_DWORDS	12
-#define SST_HSW_GLOBAL_LOG		15
-
-/**
- * Upfront defined maximum message size that is
- * expected by the in/out communication pipes in FW.
- */
-#define SST_HSW_IPC_MAX_PAYLOAD_SIZE	400
-#define SST_HSW_MAX_INFO_SIZE		64
-#define SST_HSW_BUILD_HASH_LENGTH	40
-#define SST_HSW_IPC_MAX_SHORT_PARAMETER_SIZE	500
-#define WAVES_PARAM_COUNT		128
-#define WAVES_PARAM_LINES		160
-
-struct sst_hsw;
-struct sst_hsw_stream;
-struct sst_hsw_log_stream;
-struct sst_pdata;
-struct sst_module;
-struct sst_module_runtime;
-extern struct sst_ops haswell_ops;
-
-/* Stream Allocate Path ID */
-enum sst_hsw_stream_path_id {
-	SST_HSW_STREAM_PATH_SSP0_OUT = 0,
-	SST_HSW_STREAM_PATH_SSP0_IN = 1,
-	SST_HSW_STREAM_PATH_MAX_PATH_ID = 2,
-};
-
-/* Stream Allocate Stream Type */
-enum sst_hsw_stream_type {
-	SST_HSW_STREAM_TYPE_RENDER = 0,
-	SST_HSW_STREAM_TYPE_SYSTEM = 1,
-	SST_HSW_STREAM_TYPE_CAPTURE = 2,
-	SST_HSW_STREAM_TYPE_LOOPBACK = 3,
-	SST_HSW_STREAM_TYPE_MAX_STREAM_TYPE = 4,
-};
-
-/* Stream Allocate Stream Format */
-enum sst_hsw_stream_format {
-	SST_HSW_STREAM_FORMAT_PCM_FORMAT = 0,
-	SST_HSW_STREAM_FORMAT_MP3_FORMAT = 1,
-	SST_HSW_STREAM_FORMAT_AAC_FORMAT = 2,
-	SST_HSW_STREAM_FORMAT_MAX_FORMAT_ID = 3,
-};
-
-/* Device ID */
-enum sst_hsw_device_id {
-	SST_HSW_DEVICE_SSP_0   = 0,
-	SST_HSW_DEVICE_SSP_1   = 1,
-};
-
-/* Device Master Clock Frequency */
-enum sst_hsw_device_mclk {
-	SST_HSW_DEVICE_MCLK_OFF         = 0,
-	SST_HSW_DEVICE_MCLK_FREQ_6_MHZ  = 1,
-	SST_HSW_DEVICE_MCLK_FREQ_12_MHZ = 2,
-	SST_HSW_DEVICE_MCLK_FREQ_24_MHZ = 3,
-};
-
-/* Device Clock Master */
-enum sst_hsw_device_mode {
-	SST_HSW_DEVICE_CLOCK_SLAVE   = 0,
-	SST_HSW_DEVICE_CLOCK_MASTER  = 1,
-	SST_HSW_DEVICE_TDM_CLOCK_MASTER = 2,
-};
-
-/* DX Power State */
-enum sst_hsw_dx_state {
-	SST_HSW_DX_STATE_D0     = 0,
-	SST_HSW_DX_STATE_D1     = 1,
-	SST_HSW_DX_STATE_D3     = 3,
-	SST_HSW_DX_STATE_MAX	= 3,
-};
-
-/* Audio stream stage IDs */
-enum sst_hsw_fx_stage_id {
-	SST_HSW_STAGE_ID_WAVES = 0,
-	SST_HSW_STAGE_ID_DTS   = 1,
-	SST_HSW_STAGE_ID_DOLBY = 2,
-	SST_HSW_STAGE_ID_BOOST = 3,
-	SST_HSW_STAGE_ID_MAX_FX_ID
-};
-
-/* DX State Type */
-enum sst_hsw_dx_type {
-	SST_HSW_DX_TYPE_FW_IMAGE = 0,
-	SST_HSW_DX_TYPE_MEMORY_DUMP = 1
-};
-
-/* Volume Curve Type*/
-enum sst_hsw_volume_curve {
-	SST_HSW_VOLUME_CURVE_NONE = 0,
-	SST_HSW_VOLUME_CURVE_FADE = 1
-};
-
-/* Sample ordering */
-enum sst_hsw_interleaving {
-	SST_HSW_INTERLEAVING_PER_CHANNEL = 0,
-	SST_HSW_INTERLEAVING_PER_SAMPLE  = 1,
-};
-
-/* Channel indices */
-enum sst_hsw_channel_index {
-	SST_HSW_CHANNEL_LEFT            = 0,
-	SST_HSW_CHANNEL_CENTER          = 1,
-	SST_HSW_CHANNEL_RIGHT           = 2,
-	SST_HSW_CHANNEL_LEFT_SURROUND   = 3,
-	SST_HSW_CHANNEL_CENTER_SURROUND = 3,
-	SST_HSW_CHANNEL_RIGHT_SURROUND  = 4,
-	SST_HSW_CHANNEL_LFE             = 7,
-	SST_HSW_CHANNEL_INVALID         = 0xF,
-};
-
-/* List of supported channel maps. */
-enum sst_hsw_channel_config {
-	SST_HSW_CHANNEL_CONFIG_MONO      = 0, /* mono only. */
-	SST_HSW_CHANNEL_CONFIG_STEREO    = 1, /* L & R. */
-	SST_HSW_CHANNEL_CONFIG_2_POINT_1 = 2, /* L, R & LFE; PCM only. */
-	SST_HSW_CHANNEL_CONFIG_3_POINT_0 = 3, /* L, C & R; MP3 & AAC only. */
-	SST_HSW_CHANNEL_CONFIG_3_POINT_1 = 4, /* L, C, R & LFE; PCM only. */
-	SST_HSW_CHANNEL_CONFIG_QUATRO    = 5, /* L, R, Ls & Rs; PCM only. */
-	SST_HSW_CHANNEL_CONFIG_4_POINT_0 = 6, /* L, C, R & Cs; MP3 & AAC only. */
-	SST_HSW_CHANNEL_CONFIG_5_POINT_0 = 7, /* L, C, R, Ls & Rs. */
-	SST_HSW_CHANNEL_CONFIG_5_POINT_1 = 8, /* L, C, R, Ls, Rs & LFE. */
-	SST_HSW_CHANNEL_CONFIG_DUAL_MONO = 9, /* One channel replicated in two. */
-	SST_HSW_CHANNEL_CONFIG_INVALID,
-};
-
-/* List of supported bit depths. */
-enum sst_hsw_bitdepth {
-	SST_HSW_DEPTH_8BIT  = 8,
-	SST_HSW_DEPTH_16BIT = 16,
-	SST_HSW_DEPTH_24BIT = 24, /* Default. */
-	SST_HSW_DEPTH_32BIT = 32,
-	SST_HSW_DEPTH_INVALID = 33,
-};
-
-enum sst_hsw_module_id {
-	SST_HSW_MODULE_BASE_FW = 0x0,
-	SST_HSW_MODULE_MP3     = 0x1,
-	SST_HSW_MODULE_AAC_5_1 = 0x2,
-	SST_HSW_MODULE_AAC_2_0 = 0x3,
-	SST_HSW_MODULE_SRC     = 0x4,
-	SST_HSW_MODULE_WAVES   = 0x5,
-	SST_HSW_MODULE_DOLBY   = 0x6,
-	SST_HSW_MODULE_BOOST   = 0x7,
-	SST_HSW_MODULE_LPAL    = 0x8,
-	SST_HSW_MODULE_DTS     = 0x9,
-	SST_HSW_MODULE_PCM_CAPTURE = 0xA,
-	SST_HSW_MODULE_PCM_SYSTEM = 0xB,
-	SST_HSW_MODULE_PCM_REFERENCE = 0xC,
-	SST_HSW_MODULE_PCM = 0xD,
-	SST_HSW_MODULE_BLUETOOTH_RENDER_MODULE = 0xE,
-	SST_HSW_MODULE_BLUETOOTH_CAPTURE_MODULE = 0xF,
-	SST_HSW_MAX_MODULE_ID,
-};
-
-enum sst_hsw_performance_action {
-	SST_HSW_PERF_START = 0,
-	SST_HSW_PERF_STOP = 1,
-};
-
-struct sst_hsw_transfer_info {
-	uint32_t destination;       /* destination address */
-	uint32_t reverse:1;         /* if 1 data flows from destination */
-	uint32_t size:31;           /* transfer size in bytes.*/
-	uint16_t first_page_offset; /* offset to data in the first page. */
-	uint8_t  packed_pages;   /* page addresses. Each occupies 20 bits */
-} __attribute__((packed));
-
-struct sst_hsw_transfer_list {
-	uint32_t transfers_count;
-	struct sst_hsw_transfer_info transfers;
-} __attribute__((packed));
-
-struct sst_hsw_transfer_parameter {
-	uint32_t parameter_id;
-	uint32_t data_size;
-	union {
-		uint8_t data[1];
-		struct sst_hsw_transfer_list transfer_list;
-	};
-} __attribute__((packed));
-
-/* SST firmware module info */
-struct sst_hsw_module_info {
-	u8 name[SST_HSW_MAX_INFO_SIZE];
-	u8 version[SST_HSW_MAX_INFO_SIZE];
-} __attribute__((packed));
-
-/* Module entry point */
-struct sst_hsw_module_entry {
-	enum sst_hsw_module_id module_id;
-	u32 entry_point;
-} __attribute__((packed));
-
-/* Module map - alignement matches DSP */
-struct sst_hsw_module_map {
-	u8 module_entries_count;
-	struct sst_hsw_module_entry module_entries[1];
-} __attribute__((packed));
-
-struct sst_hsw_memory_info {
-	u32 offset;
-	u32 size;
-} __attribute__((packed));
-
-struct sst_hsw_fx_enable {
-	struct sst_hsw_module_map module_map;
-	struct sst_hsw_memory_info persistent_mem;
-} __attribute__((packed));
-
-struct sst_hsw_ipc_module_config {
-	struct sst_hsw_module_map map;
-	struct sst_hsw_memory_info persistent_mem;
-	struct sst_hsw_memory_info scratch_mem;
-} __attribute__((packed));
-
-struct sst_hsw_get_fx_param {
-	u32 parameter_id;
-	u32 param_size;
-} __attribute__((packed));
-
-struct sst_hsw_perf_action {
-	u32 action;
-} __attribute__((packed));
-
-struct sst_hsw_perf_data {
-	u64 timestamp;
-	u64 cycles;
-	u64 datatime;
-} __attribute__((packed));
-
-/* FW version */
-struct sst_hsw_ipc_fw_version {
-	u8 build;
-	u8 minor;
-	u8 major;
-	u8 type;
-	u8 fw_build_hash[SST_HSW_BUILD_HASH_LENGTH];
-	u32 fw_log_providers_hash;
-} __attribute__((packed));
-
-/* Stream ring info */
-struct sst_hsw_ipc_stream_ring {
-	u32 ring_pt_address;
-	u32 num_pages;
-	u32 ring_size;
-	u32 ring_offset;
-	u32 ring_first_pfn;
-} __attribute__((packed));
-
-/* Debug Dump Log Enable Request */
-struct sst_hsw_ipc_debug_log_enable_req {
-	struct sst_hsw_ipc_stream_ring ringinfo;
-	u32 config[SST_HSW_FW_LOG_CONFIG_DWORDS];
-} __attribute__((packed));
-
-/* Debug Dump Log Reply */
-struct sst_hsw_ipc_debug_log_reply {
-	u32 log_buffer_begining;
-	u32 log_buffer_size;
-} __attribute__((packed));
-
-/* Stream glitch position */
-struct sst_hsw_ipc_stream_glitch_position {
-	u32 glitch_type;
-	u32 present_pos;
-	u32 write_pos;
-} __attribute__((packed));
-
-/* Stream get position */
-struct sst_hsw_ipc_stream_get_position {
-	u32 position;
-	u32 fw_cycle_count;
-} __attribute__((packed));
-
-/* Stream set position */
-struct sst_hsw_ipc_stream_set_position {
-	u32 position;
-	u32 end_of_buffer;
-} __attribute__((packed));
-
-/* Stream Free Request */
-struct sst_hsw_ipc_stream_free_req {
-	u8 stream_id;
-	u8 reserved[3];
-} __attribute__((packed));
-
-/* Set Volume Request */
-struct sst_hsw_ipc_volume_req {
-	u32 channel;
-	u32 target_volume;
-	u64 curve_duration;
-	u32 curve_type;
-} __attribute__((packed));
-
-/* Device Configuration Request */
-struct sst_hsw_ipc_device_config_req {
-	u32 ssp_interface;
-	u32 clock_frequency;
-	u32 mode;
-	u16 clock_divider;
-	u8 channels;
-	u8 reserved;
-} __attribute__((packed));
-
-/* Audio Data formats */
-struct sst_hsw_audio_data_format_ipc {
-	u32 frequency;
-	u32 bitdepth;
-	u32 map;
-	u32 config;
-	u32 style;
-	u8 ch_num;
-	u8 valid_bit;
-	u8 reserved[2];
-} __attribute__((packed));
-
-/* Stream Allocate Request */
-struct sst_hsw_ipc_stream_alloc_req {
-	u8 path_id;
-	u8 stream_type;
-	u8 format_id;
-	u8 reserved;
-	struct sst_hsw_audio_data_format_ipc format;
-	struct sst_hsw_ipc_stream_ring ringinfo;
-	struct sst_hsw_module_map map;
-	struct sst_hsw_memory_info persistent_mem;
-	struct sst_hsw_memory_info scratch_mem;
-	u32 number_of_notifications;
-} __attribute__((packed));
-
-/* Stream Allocate Reply */
-struct sst_hsw_ipc_stream_alloc_reply {
-	u32 stream_hw_id;
-	u32 mixer_hw_id; // returns rate ????
-	u32 read_position_register_address;
-	u32 presentation_position_register_address;
-	u32 peak_meter_register_address[SST_HSW_NO_CHANNELS];
-	u32 volume_register_address[SST_HSW_NO_CHANNELS];
-} __attribute__((packed));
-
-/* Get Mixer Stream Info */
-struct sst_hsw_ipc_stream_info_reply {
-	u32 mixer_hw_id;
-	u32 peak_meter_register_address[SST_HSW_NO_CHANNELS];
-	u32 volume_register_address[SST_HSW_NO_CHANNELS];
-} __attribute__((packed));
-
-/* DX State Request */
-struct sst_hsw_ipc_dx_req {
-	u8 state;
-	u8 reserved[3];
-} __attribute__((packed));
-
-/* DX State Reply Memory Info Item */
-struct sst_hsw_ipc_dx_memory_item {
-	u32 offset;
-	u32 size;
-	u32 source;
-} __attribute__((packed));
-
-/* DX State Reply */
-struct sst_hsw_ipc_dx_reply {
-	u32 entries_no;
-	struct sst_hsw_ipc_dx_memory_item mem_info[SST_HSW_MAX_DX_REGIONS];
-} __attribute__((packed));
-
-struct sst_hsw_ipc_fw_version;
-
-/* SST Init & Free */
-struct sst_hsw *sst_hsw_new(struct device *dev, const u8 *fw, size_t fw_length,
-	u32 fw_offset);
-void sst_hsw_free(struct sst_hsw *hsw);
-int sst_hsw_fw_get_version(struct sst_hsw *hsw,
-	struct sst_hsw_ipc_fw_version *version);
-u32 create_channel_map(enum sst_hsw_channel_config config);
-
-/* Stream Mixer Controls - */
-int sst_hsw_stream_set_volume(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 volume);
-int sst_hsw_stream_get_volume(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 *volume);
-
-/* Global Mixer Controls - */
-int sst_hsw_mixer_set_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
-	u32 volume);
-int sst_hsw_mixer_get_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
-	u32 *volume);
-
-/* Stream API */
-struct sst_hsw_stream *sst_hsw_stream_new(struct sst_hsw *hsw, int id,
-	u32 (*notify_position)(struct sst_hsw_stream *stream, void *data),
-	void *data);
-
-int sst_hsw_stream_free(struct sst_hsw *hsw, struct sst_hsw_stream *stream);
-
-/* Stream Configuration */
-int sst_hsw_stream_format(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	enum sst_hsw_stream_path_id path_id,
-	enum sst_hsw_stream_type stream_type,
-	enum sst_hsw_stream_format format_id);
-
-int sst_hsw_stream_buffer(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u32 ring_pt_address, u32 num_pages,
-	u32 ring_size, u32 ring_offset, u32 ring_first_pfn);
-
-int sst_hsw_stream_commit(struct sst_hsw *hsw, struct sst_hsw_stream *stream);
-
-int sst_hsw_stream_set_valid(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u32 bits);
-int sst_hsw_stream_set_rate(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	int rate);
-int sst_hsw_stream_set_bits(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	enum sst_hsw_bitdepth bits);
-int sst_hsw_stream_set_channels(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, int channels);
-int sst_hsw_stream_set_map_config(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 map,
-	enum sst_hsw_channel_config config);
-int sst_hsw_stream_set_style(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	enum sst_hsw_interleaving style);
-int sst_hsw_stream_set_module_info(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, struct sst_module_runtime *runtime);
-int sst_hsw_stream_set_pmemory_info(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 offset, u32 size);
-int sst_hsw_stream_set_smemory_info(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 offset, u32 size);
-snd_pcm_uframes_t sst_hsw_stream_get_old_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream);
-void sst_hsw_stream_set_old_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, snd_pcm_uframes_t val);
-bool sst_hsw_stream_get_silence_start(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream);
-void sst_hsw_stream_set_silence_start(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, bool val);
-int sst_hsw_mixer_get_info(struct sst_hsw *hsw);
-
-/* Stream ALSA trigger operations */
-int sst_hsw_stream_pause(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	int wait);
-int sst_hsw_stream_resume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	int wait);
-int sst_hsw_stream_reset(struct sst_hsw *hsw, struct sst_hsw_stream *stream);
-
-/* Stream pointer positions */
-int sst_hsw_stream_get_read_pos(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 *position);
-int sst_hsw_stream_get_write_pos(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, u32 *position);
-u32 sst_hsw_get_dsp_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream);
-u64 sst_hsw_get_dsp_presentation_position(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream);
-
-/* HW port config */
-int sst_hsw_device_set_config(struct sst_hsw *hsw,
-	enum sst_hsw_device_id dev, enum sst_hsw_device_mclk mclk,
-	enum sst_hsw_device_mode mode, u32 clock_divider);
-
-/* DX Config */
-int sst_hsw_dx_set_state(struct sst_hsw *hsw,
-	enum sst_hsw_dx_state state, struct sst_hsw_ipc_dx_reply *dx);
-
-/* init */
-int sst_hsw_dsp_init(struct device *dev, struct sst_pdata *pdata);
-void sst_hsw_dsp_free(struct device *dev, struct sst_pdata *pdata);
-struct sst_dsp *sst_hsw_get_dsp(struct sst_hsw *hsw);
-
-/* fw module function */
-void sst_hsw_init_module_state(struct sst_hsw *hsw);
-bool sst_hsw_is_module_loaded(struct sst_hsw *hsw, u32 module_id);
-bool sst_hsw_is_module_active(struct sst_hsw *hsw, u32 module_id);
-void sst_hsw_set_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id);
-void sst_hsw_set_module_disabled_rtd3(struct sst_hsw *hsw, u32 module_id);
-bool sst_hsw_is_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id);
-void sst_hsw_reset_param_buf(struct sst_hsw *hsw);
-int sst_hsw_store_param_line(struct sst_hsw *hsw, u8 *buf);
-int sst_hsw_load_param_line(struct sst_hsw *hsw, u8 *buf);
-int sst_hsw_launch_param_buf(struct sst_hsw *hsw);
-
-int sst_hsw_module_load(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id, char *name);
-int sst_hsw_module_enable(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id);
-int sst_hsw_module_disable(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id);
-int sst_hsw_module_set_param(struct sst_hsw *hsw,
-	u32 module_id, u32 instance_id, u32 parameter_id,
-	u32 param_size, char *param);
-
-/* runtime module management */
-struct sst_module_runtime *sst_hsw_runtime_module_create(struct sst_hsw *hsw,
-	int mod_id, int offset);
-void sst_hsw_runtime_module_free(struct sst_module_runtime *runtime);
-
-/* PM */
-int sst_hsw_dsp_runtime_resume(struct sst_hsw *hsw);
-int sst_hsw_dsp_runtime_suspend(struct sst_hsw *hsw);
-int sst_hsw_dsp_load(struct sst_hsw *hsw);
-int sst_hsw_dsp_runtime_sleep(struct sst_hsw *hsw);
-
-#endif
diff --git a/sound/soc/intel/haswell/sst-haswell-pcm.c b/sound/soc/intel/haswell/sst-haswell-pcm.c
deleted file mode 100644
index b8d86c74c53d..000000000000
--- a/sound/soc/intel/haswell/sst-haswell-pcm.c
+++ /dev/null
@@ -1,1369 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Intel SST Haswell/Broadwell PCM Support
- *
- * Copyright (C) 2013, Intel Corporation. All rights reserved.
- */
-
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/pm_runtime.h>
-#include <linux/pgtable.h>
-#include <asm/page.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/dmaengine_pcm.h>
-#include <sound/soc.h>
-#include <sound/tlv.h>
-#include <sound/compress_driver.h>
-
-#include "../haswell/sst-haswell-ipc.h"
-#include "../common/sst-dsp-priv.h"
-#include "../common/sst-dsp.h"
-
-#define HSW_PCM_COUNT		6
-#define HSW_VOLUME_MAX		0x7FFFFFFF	/* 0dB */
-
-#define SST_OLD_POSITION(d, r, o) ((d) +		\
-			frames_to_bytes(r, o))
-#define SST_SAMPLES(r, x) (bytes_to_samples(r,	\
-			frames_to_bytes(r, (x))))
-
-/* simple volume table */
-static const u32 volume_map[] = {
-	HSW_VOLUME_MAX >> 30,
-	HSW_VOLUME_MAX >> 29,
-	HSW_VOLUME_MAX >> 28,
-	HSW_VOLUME_MAX >> 27,
-	HSW_VOLUME_MAX >> 26,
-	HSW_VOLUME_MAX >> 25,
-	HSW_VOLUME_MAX >> 24,
-	HSW_VOLUME_MAX >> 23,
-	HSW_VOLUME_MAX >> 22,
-	HSW_VOLUME_MAX >> 21,
-	HSW_VOLUME_MAX >> 20,
-	HSW_VOLUME_MAX >> 19,
-	HSW_VOLUME_MAX >> 18,
-	HSW_VOLUME_MAX >> 17,
-	HSW_VOLUME_MAX >> 16,
-	HSW_VOLUME_MAX >> 15,
-	HSW_VOLUME_MAX >> 14,
-	HSW_VOLUME_MAX >> 13,
-	HSW_VOLUME_MAX >> 12,
-	HSW_VOLUME_MAX >> 11,
-	HSW_VOLUME_MAX >> 10,
-	HSW_VOLUME_MAX >> 9,
-	HSW_VOLUME_MAX >> 8,
-	HSW_VOLUME_MAX >> 7,
-	HSW_VOLUME_MAX >> 6,
-	HSW_VOLUME_MAX >> 5,
-	HSW_VOLUME_MAX >> 4,
-	HSW_VOLUME_MAX >> 3,
-	HSW_VOLUME_MAX >> 2,
-	HSW_VOLUME_MAX >> 1,
-	HSW_VOLUME_MAX >> 0,
-};
-
-#define HSW_PCM_PERIODS_MAX	64
-#define HSW_PCM_PERIODS_MIN	2
-
-#define HSW_PCM_DAI_ID_SYSTEM	0
-#define HSW_PCM_DAI_ID_OFFLOAD0	1
-#define HSW_PCM_DAI_ID_OFFLOAD1	2
-#define HSW_PCM_DAI_ID_LOOPBACK	3
-
-
-static const struct snd_pcm_hardware hsw_pcm_hardware = {
-	.info			= SNDRV_PCM_INFO_MMAP |
-				  SNDRV_PCM_INFO_MMAP_VALID |
-				  SNDRV_PCM_INFO_INTERLEAVED |
-				  SNDRV_PCM_INFO_PAUSE |
-				  SNDRV_PCM_INFO_RESUME |
-				  SNDRV_PCM_INFO_NO_PERIOD_WAKEUP |
-				  SNDRV_PCM_INFO_DRAIN_TRIGGER,
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
-				  SNDRV_PCM_FMTBIT_S32_LE,
-	.period_bytes_min	= PAGE_SIZE,
-	.period_bytes_max	= (HSW_PCM_PERIODS_MAX / HSW_PCM_PERIODS_MIN) * PAGE_SIZE,
-	.periods_min		= HSW_PCM_PERIODS_MIN,
-	.periods_max		= HSW_PCM_PERIODS_MAX,
-	.buffer_bytes_max	= HSW_PCM_PERIODS_MAX * PAGE_SIZE,
-};
-
-struct hsw_pcm_module_map {
-	int dai_id;
-	int stream;
-	enum sst_hsw_module_id mod_id;
-};
-
-/* private data for each PCM DSP stream */
-struct hsw_pcm_data {
-	int dai_id;
-	struct sst_hsw_stream *stream;
-	struct sst_module_runtime *runtime;
-	struct sst_module_runtime_context context;
-	struct snd_pcm *hsw_pcm;
-	u32 volume[2];
-	struct snd_pcm_substream *substream;
-	struct snd_compr_stream *cstream;
-	unsigned int wpos;
-	struct mutex mutex;
-	bool allocated;
-	int persistent_offset;
-};
-
-enum hsw_pm_state {
-	HSW_PM_STATE_D0 = 0,
-	HSW_PM_STATE_RTD3 = 1,
-	HSW_PM_STATE_D3 = 2,
-};
-
-/* private data for the driver */
-struct hsw_priv_data {
-	/* runtime DSP */
-	struct sst_hsw *hsw;
-	struct device *dev;
-	enum hsw_pm_state pm_state;
-	struct snd_soc_card *soc_card;
-	struct sst_module_runtime *runtime_waves; /* sound effect module */
-
-	/* page tables */
-	struct snd_dma_buffer dmab[HSW_PCM_COUNT][2];
-
-	/* DAI data */
-	struct hsw_pcm_data pcm[HSW_PCM_COUNT][2];
-};
-
-
-/* static mappings between PCMs and modules - may be dynamic in future */
-static struct hsw_pcm_module_map mod_map[] = {
-	{HSW_PCM_DAI_ID_SYSTEM, 0, SST_HSW_MODULE_PCM_SYSTEM},
-	{HSW_PCM_DAI_ID_OFFLOAD0, 0, SST_HSW_MODULE_PCM},
-	{HSW_PCM_DAI_ID_OFFLOAD1, 0, SST_HSW_MODULE_PCM},
-	{HSW_PCM_DAI_ID_LOOPBACK, 1, SST_HSW_MODULE_PCM_REFERENCE},
-	{HSW_PCM_DAI_ID_SYSTEM, 1, SST_HSW_MODULE_PCM_CAPTURE},
-};
-
-static u32 hsw_notify_pointer(struct sst_hsw_stream *stream, void *data);
-
-static inline u32 hsw_mixer_to_ipc(unsigned int value)
-{
-	if (value >= ARRAY_SIZE(volume_map))
-		return volume_map[0];
-	else
-		return volume_map[value];
-}
-
-static inline unsigned int hsw_ipc_to_mixer(u32 value)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(volume_map); i++) {
-		if (volume_map[i] >= value)
-			return i;
-	}
-
-	return i - 1;
-}
-
-static int hsw_stream_volume_put(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct hsw_priv_data *pdata =
-		snd_soc_component_get_drvdata(component);
-	struct hsw_pcm_data *pcm_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	u32 volume;
-	int dai, stream;
-
-	dai = mod_map[mc->reg].dai_id;
-	stream = mod_map[mc->reg].stream;
-	pcm_data = &pdata->pcm[dai][stream];
-
-	mutex_lock(&pcm_data->mutex);
-	pm_runtime_get_sync(pdata->dev);
-
-	if (!pcm_data->stream) {
-		pcm_data->volume[0] =
-			hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		pcm_data->volume[1] =
-			hsw_mixer_to_ipc(ucontrol->value.integer.value[1]);
-		pm_runtime_mark_last_busy(pdata->dev);
-		pm_runtime_put_autosuspend(pdata->dev);
-		mutex_unlock(&pcm_data->mutex);
-		return 0;
-	}
-
-	if (ucontrol->value.integer.value[0] ==
-		ucontrol->value.integer.value[1]) {
-		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		/* apply volume value to all channels */
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, SST_HSW_CHANNELS_ALL, volume);
-	} else {
-		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, 0, volume);
-		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[1]);
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, 1, volume);
-	}
-
-	pm_runtime_mark_last_busy(pdata->dev);
-	pm_runtime_put_autosuspend(pdata->dev);
-	mutex_unlock(&pcm_data->mutex);
-	return 0;
-}
-
-static int hsw_stream_volume_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct hsw_priv_data *pdata =
-		snd_soc_component_get_drvdata(component);
-	struct hsw_pcm_data *pcm_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	u32 volume;
-	int dai, stream;
-
-	dai = mod_map[mc->reg].dai_id;
-	stream = mod_map[mc->reg].stream;
-	pcm_data = &pdata->pcm[dai][stream];
-
-	mutex_lock(&pcm_data->mutex);
-	pm_runtime_get_sync(pdata->dev);
-
-	if (!pcm_data->stream) {
-		ucontrol->value.integer.value[0] =
-			hsw_ipc_to_mixer(pcm_data->volume[0]);
-		ucontrol->value.integer.value[1] =
-			hsw_ipc_to_mixer(pcm_data->volume[1]);
-		pm_runtime_mark_last_busy(pdata->dev);
-		pm_runtime_put_autosuspend(pdata->dev);
-		mutex_unlock(&pcm_data->mutex);
-		return 0;
-	}
-
-	sst_hsw_stream_get_volume(hsw, pcm_data->stream, 0, 0, &volume);
-	ucontrol->value.integer.value[0] = hsw_ipc_to_mixer(volume);
-	sst_hsw_stream_get_volume(hsw, pcm_data->stream, 0, 1, &volume);
-	ucontrol->value.integer.value[1] = hsw_ipc_to_mixer(volume);
-
-	pm_runtime_mark_last_busy(pdata->dev);
-	pm_runtime_put_autosuspend(pdata->dev);
-	mutex_unlock(&pcm_data->mutex);
-
-	return 0;
-}
-
-static int hsw_volume_put(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct sst_hsw *hsw = pdata->hsw;
-	u32 volume;
-
-	pm_runtime_get_sync(pdata->dev);
-
-	if (ucontrol->value.integer.value[0] ==
-		ucontrol->value.integer.value[1]) {
-
-		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		sst_hsw_mixer_set_volume(hsw, 0, SST_HSW_CHANNELS_ALL, volume);
-
-	} else {
-		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		sst_hsw_mixer_set_volume(hsw, 0, 0, volume);
-
-		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[1]);
-		sst_hsw_mixer_set_volume(hsw, 0, 1, volume);
-	}
-
-	pm_runtime_mark_last_busy(pdata->dev);
-	pm_runtime_put_autosuspend(pdata->dev);
-	return 0;
-}
-
-static int hsw_volume_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct sst_hsw *hsw = pdata->hsw;
-	unsigned int volume = 0;
-
-	pm_runtime_get_sync(pdata->dev);
-	sst_hsw_mixer_get_volume(hsw, 0, 0, &volume);
-	ucontrol->value.integer.value[0] = hsw_ipc_to_mixer(volume);
-
-	sst_hsw_mixer_get_volume(hsw, 0, 1, &volume);
-	ucontrol->value.integer.value[1] = hsw_ipc_to_mixer(volume);
-
-	pm_runtime_mark_last_busy(pdata->dev);
-	pm_runtime_put_autosuspend(pdata->dev);
-	return 0;
-}
-
-static int hsw_waves_switch_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct sst_hsw *hsw = pdata->hsw;
-	enum sst_hsw_module_id id = SST_HSW_MODULE_WAVES;
-
-	ucontrol->value.integer.value[0] =
-		(sst_hsw_is_module_active(hsw, id) ||
-		sst_hsw_is_module_enabled_rtd3(hsw, id));
-	return 0;
-}
-
-static int hsw_waves_switch_put(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct sst_hsw *hsw = pdata->hsw;
-	int ret = 0;
-	enum sst_hsw_module_id id = SST_HSW_MODULE_WAVES;
-	bool switch_on = (bool)ucontrol->value.integer.value[0];
-
-	/* if module is in RAM on the DSP, apply user settings to module through
-	 * ipc. If module is not in RAM on the DSP, store user setting for
-	 * track */
-	if (sst_hsw_is_module_loaded(hsw, id)) {
-		if (switch_on == sst_hsw_is_module_active(hsw, id))
-			return 0;
-
-		if (switch_on)
-			ret = sst_hsw_module_enable(hsw, id, 0);
-		else
-			ret = sst_hsw_module_disable(hsw, id, 0);
-	} else {
-		if (switch_on == sst_hsw_is_module_enabled_rtd3(hsw, id))
-			return 0;
-
-		if (switch_on)
-			sst_hsw_set_module_enabled_rtd3(hsw, id);
-		else
-			sst_hsw_set_module_disabled_rtd3(hsw, id);
-	}
-
-	return ret;
-}
-
-static int hsw_waves_param_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct sst_hsw *hsw = pdata->hsw;
-
-	/* return a matching line from param buffer */
-	return sst_hsw_load_param_line(hsw, ucontrol->value.bytes.data);
-}
-
-static int hsw_waves_param_put(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct sst_hsw *hsw = pdata->hsw;
-	int ret;
-	enum sst_hsw_module_id id = SST_HSW_MODULE_WAVES;
-	int param_id = ucontrol->value.bytes.data[0];
-	int param_size = WAVES_PARAM_COUNT;
-
-	/* clear param buffer and reset buffer index */
-	if (param_id == 0xFF) {
-		sst_hsw_reset_param_buf(hsw);
-		return 0;
-	}
-
-	/* store params into buffer */
-	ret = sst_hsw_store_param_line(hsw, ucontrol->value.bytes.data);
-	if (ret < 0)
-		return ret;
-
-	if (sst_hsw_is_module_active(hsw, id))
-		ret = sst_hsw_module_set_param(hsw, id, 0, param_id,
-				param_size, ucontrol->value.bytes.data);
-	return ret;
-}
-
-/* TLV used by both global and stream volumes */
-static const DECLARE_TLV_DB_SCALE(hsw_vol_tlv, -9000, 300, 1);
-
-/* System Pin has no volume control */
-static const struct snd_kcontrol_new hsw_volume_controls[] = {
-	/* Global DSP volume */
-	SOC_DOUBLE_EXT_TLV("Master Playback Volume", 0, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
-		hsw_volume_get, hsw_volume_put, hsw_vol_tlv),
-	/* Offload 0 volume */
-	SOC_DOUBLE_EXT_TLV("Media0 Playback Volume", 1, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
-		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
-	/* Offload 1 volume */
-	SOC_DOUBLE_EXT_TLV("Media1 Playback Volume", 2, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
-		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
-	/* Mic Capture volume */
-	SOC_DOUBLE_EXT_TLV("Mic Capture Volume", 4, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
-		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
-	/* enable/disable module waves */
-	SOC_SINGLE_BOOL_EXT("Waves Switch", 0,
-		hsw_waves_switch_get, hsw_waves_switch_put),
-	/* set parameters to module waves */
-	SND_SOC_BYTES_EXT("Waves Set Param", WAVES_PARAM_COUNT,
-		hsw_waves_param_get, hsw_waves_param_put),
-};
-
-/* Create DMA buffer page table for DSP */
-static int create_adsp_page_table(struct snd_pcm_substream *substream,
-	struct hsw_priv_data *pdata, struct snd_soc_pcm_runtime *rtd,
-	unsigned char *dma_area, size_t size, int pcm)
-{
-	struct snd_dma_buffer *dmab = snd_pcm_get_dma_buf(substream);
-	int i, pages, stream = substream->stream;
-
-	pages = snd_sgbuf_aligned_pages(size);
-
-	dev_dbg(rtd->dev, "generating page table for %p size 0x%zx pages %d\n",
-		dma_area, size, pages);
-
-	for (i = 0; i < pages; i++) {
-		u32 idx = (((i << 2) + i)) >> 1;
-		u32 pfn = snd_sgbuf_get_addr(dmab, i * PAGE_SIZE) >> PAGE_SHIFT;
-		u32 *pg_table;
-
-		dev_dbg(rtd->dev, "pfn i %i idx %d pfn %x\n", i, idx, pfn);
-
-		pg_table = (u32 *)(pdata->dmab[pcm][stream].area + idx);
-
-		if (i & 1)
-			*pg_table |= (pfn << 4);
-		else
-			*pg_table |= pfn;
-	}
-
-	return 0;
-}
-
-/* this may get called several times by oss emulation */
-static int hsw_pcm_hw_params(struct snd_soc_component *component,
-			     struct snd_pcm_substream *substream,
-			     struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct hsw_pcm_data *pcm_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	struct sst_module *module_data;
-	struct sst_dsp *dsp;
-	struct snd_dma_buffer *dmab;
-	enum sst_hsw_stream_type stream_type;
-	enum sst_hsw_stream_path_id path_id;
-	u32 rate, bits, map, pages, module_id;
-	u8 channels;
-	int ret, dai;
-
-	dai = mod_map[asoc_rtd_to_cpu(rtd, 0)->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
-
-	/* check if we are being called a subsequent time */
-	if (pcm_data->allocated) {
-		ret = sst_hsw_stream_reset(hsw, pcm_data->stream);
-		if (ret < 0)
-			dev_dbg(rtd->dev, "error: reset stream failed %d\n",
-				ret);
-
-		ret = sst_hsw_stream_free(hsw, pcm_data->stream);
-		if (ret < 0) {
-			dev_dbg(rtd->dev, "error: free stream failed %d\n",
-				ret);
-			return ret;
-		}
-		pcm_data->allocated = false;
-
-		pcm_data->stream = sst_hsw_stream_new(hsw, asoc_rtd_to_cpu(rtd, 0)->id,
-			hsw_notify_pointer, pcm_data);
-		if (pcm_data->stream == NULL) {
-			dev_err(rtd->dev, "error: failed to create stream\n");
-			return -EINVAL;
-		}
-	}
-
-	/* stream direction */
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		path_id = SST_HSW_STREAM_PATH_SSP0_OUT;
-	else
-		path_id = SST_HSW_STREAM_PATH_SSP0_IN;
-
-	/* DSP stream type depends on DAI ID */
-	switch (asoc_rtd_to_cpu(rtd, 0)->id) {
-	case 0:
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			stream_type = SST_HSW_STREAM_TYPE_SYSTEM;
-			module_id = SST_HSW_MODULE_PCM_SYSTEM;
-		}
-		else {
-			stream_type = SST_HSW_STREAM_TYPE_CAPTURE;
-			module_id = SST_HSW_MODULE_PCM_CAPTURE;
-		}
-		break;
-	case 1:
-	case 2:
-		stream_type = SST_HSW_STREAM_TYPE_RENDER;
-		module_id = SST_HSW_MODULE_PCM;
-		break;
-	case 3:
-		/* path ID needs to be OUT for loopback */
-		stream_type = SST_HSW_STREAM_TYPE_LOOPBACK;
-		path_id = SST_HSW_STREAM_PATH_SSP0_OUT;
-		module_id = SST_HSW_MODULE_PCM_REFERENCE;
-		break;
-	default:
-		dev_err(rtd->dev, "error: invalid DAI ID %d\n",
-			asoc_rtd_to_cpu(rtd, 0)->id);
-		return -EINVAL;
-	}
-
-	ret = sst_hsw_stream_format(hsw, pcm_data->stream,
-		path_id, stream_type, SST_HSW_STREAM_FORMAT_PCM_FORMAT);
-	if (ret < 0) {
-		dev_err(rtd->dev, "error: failed to set format %d\n", ret);
-		return ret;
-	}
-
-	rate = params_rate(params);
-	ret = sst_hsw_stream_set_rate(hsw, pcm_data->stream, rate);
-	if (ret < 0) {
-		dev_err(rtd->dev, "error: could not set rate %d\n", rate);
-		return ret;
-	}
-
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S16_LE:
-		bits = SST_HSW_DEPTH_16BIT;
-		sst_hsw_stream_set_valid(hsw, pcm_data->stream, 16);
-		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		bits = SST_HSW_DEPTH_32BIT;
-		sst_hsw_stream_set_valid(hsw, pcm_data->stream, 24);
-		break;
-	case SNDRV_PCM_FORMAT_S8:
-		bits = SST_HSW_DEPTH_8BIT;
-		sst_hsw_stream_set_valid(hsw, pcm_data->stream, 8);
-		break;
-	case SNDRV_PCM_FORMAT_S32_LE:
-		bits = SST_HSW_DEPTH_32BIT;
-		sst_hsw_stream_set_valid(hsw, pcm_data->stream, 32);
-		break;
-	default:
-		dev_err(rtd->dev, "error: invalid format %d\n",
-			params_format(params));
-		return -EINVAL;
-	}
-
-	ret = sst_hsw_stream_set_bits(hsw, pcm_data->stream, bits);
-	if (ret < 0) {
-		dev_err(rtd->dev, "error: could not set bits %d\n", bits);
-		return ret;
-	}
-
-	channels = params_channels(params);
-	map = create_channel_map(SST_HSW_CHANNEL_CONFIG_STEREO);
-	sst_hsw_stream_set_map_config(hsw, pcm_data->stream,
-			map, SST_HSW_CHANNEL_CONFIG_STEREO);
-
-	ret = sst_hsw_stream_set_channels(hsw, pcm_data->stream, channels);
-	if (ret < 0) {
-		dev_err(rtd->dev, "error: could not set channels %d\n",
-			channels);
-		return ret;
-	}
-
-	dmab = snd_pcm_get_dma_buf(substream);
-
-	ret = create_adsp_page_table(substream, pdata, rtd, runtime->dma_area,
-		runtime->dma_bytes, asoc_rtd_to_cpu(rtd, 0)->id);
-	if (ret < 0)
-		return ret;
-
-	sst_hsw_stream_set_style(hsw, pcm_data->stream,
-		SST_HSW_INTERLEAVING_PER_CHANNEL);
-
-	if (runtime->dma_bytes % PAGE_SIZE)
-		pages = (runtime->dma_bytes / PAGE_SIZE) + 1;
-	else
-		pages = runtime->dma_bytes / PAGE_SIZE;
-
-	ret = sst_hsw_stream_buffer(hsw, pcm_data->stream,
-		pdata->dmab[asoc_rtd_to_cpu(rtd, 0)->id][substream->stream].addr,
-		pages, runtime->dma_bytes, 0,
-		snd_sgbuf_get_addr(dmab, 0) >> PAGE_SHIFT);
-	if (ret < 0) {
-		dev_err(rtd->dev, "error: failed to set DMA buffer %d\n", ret);
-		return ret;
-	}
-
-	dsp = sst_hsw_get_dsp(hsw);
-
-	module_data = sst_module_get_from_id(dsp, module_id);
-	if (module_data == NULL) {
-		dev_err(rtd->dev, "error: failed to get module config\n");
-		return -EINVAL;
-	}
-
-	sst_hsw_stream_set_module_info(hsw, pcm_data->stream,
-		pcm_data->runtime);
-
-	ret = sst_hsw_stream_commit(hsw, pcm_data->stream);
-	if (ret < 0) {
-		dev_err(rtd->dev, "error: failed to commit stream %d\n", ret);
-		return ret;
-	}
-
-	if (!pcm_data->allocated) {
-		/* Set previous saved volume */
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
-				0, pcm_data->volume[0]);
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
-				1, pcm_data->volume[1]);
-		pcm_data->allocated = true;
-	}
-
-	ret = sst_hsw_stream_pause(hsw, pcm_data->stream, 1);
-	if (ret < 0)
-		dev_err(rtd->dev, "error: failed to pause %d\n", ret);
-
-	return 0;
-}
-
-static int hsw_pcm_trigger(struct snd_soc_component *component,
-			   struct snd_pcm_substream *substream, int cmd)
-{
-	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct hsw_pcm_data *pcm_data;
-	struct sst_hsw_stream *sst_stream;
-	struct sst_hsw *hsw = pdata->hsw;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	snd_pcm_uframes_t pos;
-	int dai;
-
-	dai = mod_map[asoc_rtd_to_cpu(rtd, 0)->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
-	sst_stream = pcm_data->stream;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		sst_hsw_stream_set_silence_start(hsw, sst_stream, false);
-		sst_hsw_stream_resume(hsw, pcm_data->stream, 0);
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		sst_hsw_stream_set_silence_start(hsw, sst_stream, false);
-		sst_hsw_stream_pause(hsw, pcm_data->stream, 0);
-		break;
-	case SNDRV_PCM_TRIGGER_DRAIN:
-		pos = runtime->control->appl_ptr % runtime->buffer_size;
-		sst_hsw_stream_set_old_position(hsw, pcm_data->stream, pos);
-		sst_hsw_stream_set_silence_start(hsw, sst_stream, true);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static u32 hsw_notify_pointer(struct sst_hsw_stream *stream, void *data)
-{
-	struct hsw_pcm_data *pcm_data = data;
-	struct snd_pcm_substream *substream = pcm_data->substream;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
-	struct snd_soc_component *component = snd_soc_rtdcom_lookup(rtd, DRV_NAME);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct sst_hsw *hsw = pdata->hsw;
-	u32 pos;
-	snd_pcm_uframes_t position = bytes_to_frames(runtime,
-		 sst_hsw_get_dsp_position(hsw, pcm_data->stream));
-	unsigned char *dma_area = runtime->dma_area;
-	snd_pcm_uframes_t dma_frames =
-		bytes_to_frames(runtime, runtime->dma_bytes);
-	snd_pcm_uframes_t old_position;
-	ssize_t samples;
-
-	pos = frames_to_bytes(runtime,
-		(runtime->control->appl_ptr % runtime->buffer_size));
-
-	dev_vdbg(rtd->dev, "PCM: App pointer %d bytes\n", pos);
-
-	/* SST fw don't know where to stop dma
-	 * So, SST driver need to clean the data which has been consumed
-	 */
-	if (dma_area == NULL || dma_frames <= 0
-		|| (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-		|| !sst_hsw_stream_get_silence_start(hsw, stream)) {
-		snd_pcm_period_elapsed(substream);
-		return pos;
-	}
-
-	old_position = sst_hsw_stream_get_old_position(hsw, stream);
-	if (position > old_position) {
-		if (position < dma_frames) {
-			samples = SST_SAMPLES(runtime, position - old_position);
-			snd_pcm_format_set_silence(runtime->format,
-				SST_OLD_POSITION(dma_area,
-					runtime, old_position),
-				samples);
-		} else
-			dev_err(rtd->dev, "PCM: position is wrong\n");
-	} else {
-		if (old_position < dma_frames) {
-			samples = SST_SAMPLES(runtime,
-				dma_frames - old_position);
-			snd_pcm_format_set_silence(runtime->format,
-				SST_OLD_POSITION(dma_area,
-					runtime, old_position),
-				samples);
-		} else
-			dev_err(rtd->dev, "PCM: dma_bytes is wrong\n");
-		if (position < dma_frames) {
-			samples = SST_SAMPLES(runtime, position);
-			snd_pcm_format_set_silence(runtime->format,
-				dma_area, samples);
-		} else
-			dev_err(rtd->dev, "PCM: position is wrong\n");
-	}
-	sst_hsw_stream_set_old_position(hsw, stream, position);
-
-	/* let alsa know we have play a period */
-	snd_pcm_period_elapsed(substream);
-	return pos;
-}
-
-static snd_pcm_uframes_t hsw_pcm_pointer(struct snd_soc_component *component,
-					 struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct hsw_pcm_data *pcm_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	snd_pcm_uframes_t offset;
-	uint64_t ppos;
-	u32 position;
-	int dai;
-
-	dai = mod_map[asoc_rtd_to_cpu(rtd, 0)->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
-	position = sst_hsw_get_dsp_position(hsw, pcm_data->stream);
-
-	offset = bytes_to_frames(runtime, position);
-	ppos = sst_hsw_get_dsp_presentation_position(hsw, pcm_data->stream);
-
-	dev_vdbg(rtd->dev, "PCM: DMA pointer %du bytes, pos %llu\n",
-		position, ppos);
-	return offset;
-}
-
-static int hsw_pcm_open(struct snd_soc_component *component,
-			struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct hsw_pcm_data *pcm_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	int dai;
-
-	dai = mod_map[asoc_rtd_to_cpu(rtd, 0)->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
-
-	mutex_lock(&pcm_data->mutex);
-	pm_runtime_get_sync(pdata->dev);
-
-	pcm_data->substream = substream;
-
-	snd_soc_set_runtime_hwparams(substream, &hsw_pcm_hardware);
-
-	pcm_data->stream = sst_hsw_stream_new(hsw, asoc_rtd_to_cpu(rtd, 0)->id,
-		hsw_notify_pointer, pcm_data);
-	if (pcm_data->stream == NULL) {
-		dev_err(rtd->dev, "error: failed to create stream\n");
-		pm_runtime_mark_last_busy(pdata->dev);
-		pm_runtime_put_autosuspend(pdata->dev);
-		mutex_unlock(&pcm_data->mutex);
-		return -EINVAL;
-	}
-
-	mutex_unlock(&pcm_data->mutex);
-	return 0;
-}
-
-static int hsw_pcm_close(struct snd_soc_component *component,
-			 struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
-	struct hsw_priv_data *pdata = snd_soc_component_get_drvdata(component);
-	struct hsw_pcm_data *pcm_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	int ret, dai;
-
-	dai = mod_map[asoc_rtd_to_cpu(rtd, 0)->id].dai_id;
-	pcm_data = &pdata->pcm[dai][substream->stream];
-
-	mutex_lock(&pcm_data->mutex);
-	ret = sst_hsw_stream_reset(hsw, pcm_data->stream);
-	if (ret < 0) {
-		dev_dbg(rtd->dev, "error: reset stream failed %d\n", ret);
-		goto out;
-	}
-
-	ret = sst_hsw_stream_free(hsw, pcm_data->stream);
-	if (ret < 0) {
-		dev_dbg(rtd->dev, "error: free stream failed %d\n", ret);
-		goto out;
-	}
-	pcm_data->allocated = false;
-	pcm_data->stream = NULL;
-
-out:
-	pm_runtime_mark_last_busy(pdata->dev);
-	pm_runtime_put_autosuspend(pdata->dev);
-	mutex_unlock(&pcm_data->mutex);
-	return ret;
-}
-
-static int hsw_pcm_create_modules(struct hsw_priv_data *pdata)
-{
-	struct sst_hsw *hsw = pdata->hsw;
-	struct hsw_pcm_data *pcm_data;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-		pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
-
-		/* create new runtime module, use same offset if recreated */
-		pcm_data->runtime = sst_hsw_runtime_module_create(hsw,
-			mod_map[i].mod_id, pcm_data->persistent_offset);
-		if (pcm_data->runtime == NULL)
-			goto err;
-		pcm_data->persistent_offset =
-			pcm_data->runtime->persistent_offset;
-	}
-
-	/* create runtime blocks for module waves */
-	if (sst_hsw_is_module_loaded(hsw, SST_HSW_MODULE_WAVES)) {
-		pdata->runtime_waves = sst_hsw_runtime_module_create(hsw,
-			SST_HSW_MODULE_WAVES, 0);
-		if (pdata->runtime_waves == NULL)
-			goto err;
-	}
-
-	return 0;
-
-err:
-	for (--i; i >= 0; i--) {
-		pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
-		sst_hsw_runtime_module_free(pcm_data->runtime);
-	}
-
-	return -ENODEV;
-}
-
-static void hsw_pcm_free_modules(struct hsw_priv_data *pdata)
-{
-	struct sst_hsw *hsw = pdata->hsw;
-	struct hsw_pcm_data *pcm_data;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-		pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
-		if (pcm_data->runtime){
-			sst_hsw_runtime_module_free(pcm_data->runtime);
-			pcm_data->runtime = NULL;
-		}
-	}
-	if (sst_hsw_is_module_loaded(hsw, SST_HSW_MODULE_WAVES) &&
-				pdata->runtime_waves) {
-		sst_hsw_runtime_module_free(pdata->runtime_waves);
-		pdata->runtime_waves = NULL;
-	}
-}
-
-static int hsw_pcm_new(struct snd_soc_component *component,
-		       struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_pcm *pcm = rtd->pcm;
-	struct sst_pdata *pdata = dev_get_platdata(component->dev);
-	struct hsw_priv_data *priv_data = dev_get_drvdata(component->dev);
-	struct device *dev = pdata->dma_dev;
-
-	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream ||
-			pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
-		snd_pcm_set_managed_buffer_all(pcm,
-			SNDRV_DMA_TYPE_DEV_SG,
-			dev,
-			hsw_pcm_hardware.buffer_bytes_max,
-			hsw_pcm_hardware.buffer_bytes_max);
-	}
-	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)
-		priv_data->pcm[asoc_rtd_to_cpu(rtd, 0)->id][SNDRV_PCM_STREAM_PLAYBACK].hsw_pcm = pcm;
-	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream)
-		priv_data->pcm[asoc_rtd_to_cpu(rtd, 0)->id][SNDRV_PCM_STREAM_CAPTURE].hsw_pcm = pcm;
-
-	return 0;
-}
-
-#define HSW_FORMATS \
-	(SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE)
-
-static struct snd_soc_dai_driver hsw_dais[] = {
-	{
-		.name  = "System Pin",
-		.id = HSW_PCM_DAI_ID_SYSTEM,
-		.playback = {
-			.stream_name = "System Playback",
-			.channels_min = 2,
-			.channels_max = 2,
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
-		},
-		.capture = {
-			.stream_name = "Analog Capture",
-			.channels_min = 2,
-			.channels_max = 4,
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
-		},
-	},
-	{
-		/* PCM */
-		.name  = "Offload0 Pin",
-		.id = HSW_PCM_DAI_ID_OFFLOAD0,
-		.playback = {
-			.stream_name = "Offload0 Playback",
-			.channels_min = 2,
-			.channels_max = 2,
-			.rates = SNDRV_PCM_RATE_8000_192000,
-			.formats = HSW_FORMATS,
-		},
-	},
-	{
-		/* PCM */
-		.name  = "Offload1 Pin",
-		.id = HSW_PCM_DAI_ID_OFFLOAD1,
-		.playback = {
-			.stream_name = "Offload1 Playback",
-			.channels_min = 2,
-			.channels_max = 2,
-			.rates = SNDRV_PCM_RATE_8000_192000,
-			.formats = HSW_FORMATS,
-		},
-	},
-	{
-		.name  = "Loopback Pin",
-		.id = HSW_PCM_DAI_ID_LOOPBACK,
-		.capture = {
-			.stream_name = "Loopback Capture",
-			.channels_min = 2,
-			.channels_max = 2,
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
-		},
-	},
-};
-
-static const struct snd_soc_dapm_widget widgets[] = {
-
-	/* Backend DAIs  */
-	SND_SOC_DAPM_AIF_IN("SSP0 CODEC IN", NULL, 0, SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_AIF_OUT("SSP0 CODEC OUT", NULL, 0, SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_AIF_IN("SSP1 BT IN", NULL, 0, SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_AIF_OUT("SSP1 BT OUT", NULL, 0, SND_SOC_NOPM, 0, 0),
-
-	/* Global Playback Mixer */
-	SND_SOC_DAPM_MIXER("Playback VMixer", SND_SOC_NOPM, 0, 0, NULL, 0),
-};
-
-static const struct snd_soc_dapm_route graph[] = {
-
-	/* Playback Mixer */
-	{"Playback VMixer", NULL, "System Playback"},
-	{"Playback VMixer", NULL, "Offload0 Playback"},
-	{"Playback VMixer", NULL, "Offload1 Playback"},
-
-	{"SSP0 CODEC OUT", NULL, "Playback VMixer"},
-
-	{"Analog Capture", NULL, "SSP0 CODEC IN"},
-};
-
-static int hsw_pcm_probe(struct snd_soc_component *component)
-{
-	struct hsw_priv_data *priv_data = snd_soc_component_get_drvdata(component);
-	struct sst_pdata *pdata = dev_get_platdata(component->dev);
-	struct device *dma_dev, *dev;
-	int i, ret = 0;
-
-	if (!pdata)
-		return -ENODEV;
-
-	dev = component->dev;
-	dma_dev = pdata->dma_dev;
-
-	priv_data->hsw = pdata->dsp;
-	priv_data->dev = dev;
-	priv_data->pm_state = HSW_PM_STATE_D0;
-	priv_data->soc_card = component->card;
-
-	/* allocate DSP buffer page tables */
-	for (i = 0; i < ARRAY_SIZE(hsw_dais); i++) {
-
-		/* playback */
-		if (hsw_dais[i].playback.channels_min) {
-			mutex_init(&priv_data->pcm[i][SNDRV_PCM_STREAM_PLAYBACK].mutex);
-			ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dma_dev,
-				PAGE_SIZE, &priv_data->dmab[i][0]);
-			if (ret < 0)
-				goto err;
-		}
-
-		/* capture */
-		if (hsw_dais[i].capture.channels_min) {
-			mutex_init(&priv_data->pcm[i][SNDRV_PCM_STREAM_CAPTURE].mutex);
-			ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dma_dev,
-				PAGE_SIZE, &priv_data->dmab[i][1]);
-			if (ret < 0)
-				goto err;
-		}
-	}
-
-	/* allocate runtime modules */
-	ret = hsw_pcm_create_modules(priv_data);
-	if (ret < 0)
-		goto err;
-
-	/* enable runtime PM with auto suspend */
-	pm_runtime_set_autosuspend_delay(dev, SST_RUNTIME_SUSPEND_DELAY);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_enable(dev);
-	pm_runtime_idle(dev);
-
-	return 0;
-
-err:
-	for (--i; i >= 0; i--) {
-		if (hsw_dais[i].playback.channels_min)
-			snd_dma_free_pages(&priv_data->dmab[i][0]);
-		if (hsw_dais[i].capture.channels_min)
-			snd_dma_free_pages(&priv_data->dmab[i][1]);
-	}
-	return ret;
-}
-
-static void hsw_pcm_remove(struct snd_soc_component *component)
-{
-	struct hsw_priv_data *priv_data =
-		snd_soc_component_get_drvdata(component);
-	int i;
-
-	pm_runtime_disable(component->dev);
-	hsw_pcm_free_modules(priv_data);
-
-	for (i = 0; i < ARRAY_SIZE(hsw_dais); i++) {
-		if (hsw_dais[i].playback.channels_min)
-			snd_dma_free_pages(&priv_data->dmab[i][0]);
-		if (hsw_dais[i].capture.channels_min)
-			snd_dma_free_pages(&priv_data->dmab[i][1]);
-	}
-}
-
-static const struct snd_soc_component_driver hsw_dai_component = {
-	.name		= DRV_NAME,
-	.probe		= hsw_pcm_probe,
-	.remove		= hsw_pcm_remove,
-	.open		= hsw_pcm_open,
-	.close		= hsw_pcm_close,
-	.hw_params	= hsw_pcm_hw_params,
-	.trigger	= hsw_pcm_trigger,
-	.pointer	= hsw_pcm_pointer,
-	.pcm_construct	= hsw_pcm_new,
-	.controls	= hsw_volume_controls,
-	.num_controls	= ARRAY_SIZE(hsw_volume_controls),
-	.dapm_widgets	= widgets,
-	.num_dapm_widgets = ARRAY_SIZE(widgets),
-	.dapm_routes	= graph,
-	.num_dapm_routes = ARRAY_SIZE(graph),
-};
-
-static int hsw_pcm_dev_probe(struct platform_device *pdev)
-{
-	struct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);
-	struct hsw_priv_data *priv_data;
-	int ret;
-
-	if (!sst_pdata)
-		return -EINVAL;
-
-	priv_data = devm_kzalloc(&pdev->dev, sizeof(*priv_data), GFP_KERNEL);
-	if (!priv_data)
-		return -ENOMEM;
-
-	ret = sst_hsw_dsp_init(&pdev->dev, sst_pdata);
-	if (ret < 0)
-		return -ENODEV;
-
-	priv_data->hsw = sst_pdata->dsp;
-	platform_set_drvdata(pdev, priv_data);
-
-	ret = devm_snd_soc_register_component(&pdev->dev, &hsw_dai_component,
-		hsw_dais, ARRAY_SIZE(hsw_dais));
-	if (ret < 0)
-		goto err_plat;
-
-	return 0;
-
-err_plat:
-	sst_hsw_dsp_free(&pdev->dev, sst_pdata);
-	return 0;
-}
-
-static int hsw_pcm_dev_remove(struct platform_device *pdev)
-{
-	struct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);
-
-	sst_hsw_dsp_free(&pdev->dev, sst_pdata);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-
-static int hsw_pcm_runtime_idle(struct device *dev)
-{
-	return 0;
-}
-
-static int hsw_pcm_suspend(struct device *dev)
-{
-	struct hsw_priv_data *pdata = dev_get_drvdata(dev);
-	struct sst_hsw *hsw = pdata->hsw;
-
-	/* enter D3 state and stall */
-	sst_hsw_dsp_runtime_suspend(hsw);
-	/* free all runtime modules */
-	hsw_pcm_free_modules(pdata);
-	/* put the DSP to sleep, fw unloaded after runtime modules freed */
-	sst_hsw_dsp_runtime_sleep(hsw);
-	return 0;
-}
-
-static int hsw_pcm_runtime_suspend(struct device *dev)
-{
-	struct hsw_priv_data *pdata = dev_get_drvdata(dev);
-	struct sst_hsw *hsw = pdata->hsw;
-	int ret;
-
-	if (pdata->pm_state >= HSW_PM_STATE_RTD3)
-		return 0;
-
-	/* fw modules will be unloaded on RTD3, set flag to track */
-	if (sst_hsw_is_module_active(hsw, SST_HSW_MODULE_WAVES)) {
-		ret = sst_hsw_module_disable(hsw, SST_HSW_MODULE_WAVES, 0);
-		if (ret < 0)
-			return ret;
-		sst_hsw_set_module_enabled_rtd3(hsw, SST_HSW_MODULE_WAVES);
-	}
-	hsw_pcm_suspend(dev);
-	pdata->pm_state = HSW_PM_STATE_RTD3;
-
-	return 0;
-}
-
-static int hsw_pcm_runtime_resume(struct device *dev)
-{
-	struct hsw_priv_data *pdata = dev_get_drvdata(dev);
-	struct sst_hsw *hsw = pdata->hsw;
-	int ret;
-
-	if (pdata->pm_state != HSW_PM_STATE_RTD3)
-		return 0;
-
-	ret = sst_hsw_dsp_load(hsw);
-	if (ret < 0) {
-		dev_err(dev, "failed to reload %d\n", ret);
-		return ret;
-	}
-
-	ret = hsw_pcm_create_modules(pdata);
-	if (ret < 0) {
-		dev_err(dev, "failed to create modules %d\n", ret);
-		return ret;
-	}
-
-	ret = sst_hsw_dsp_runtime_resume(hsw);
-	if (ret < 0)
-		return ret;
-	else if (ret == 1) /* no action required */
-		return 0;
-
-	/* check flag when resume */
-	if (sst_hsw_is_module_enabled_rtd3(hsw, SST_HSW_MODULE_WAVES)) {
-		ret = sst_hsw_module_enable(hsw, SST_HSW_MODULE_WAVES, 0);
-		if (ret < 0)
-			return ret;
-		/* put parameters from buffer to dsp */
-		ret = sst_hsw_launch_param_buf(hsw);
-		if (ret < 0)
-			return ret;
-		/* unset flag */
-		sst_hsw_set_module_disabled_rtd3(hsw, SST_HSW_MODULE_WAVES);
-	}
-
-	pdata->pm_state = HSW_PM_STATE_D0;
-	return ret;
-}
-
-#else
-#define hsw_pcm_runtime_idle		NULL
-#define hsw_pcm_runtime_suspend		NULL
-#define hsw_pcm_runtime_resume		NULL
-#endif
-
-#ifdef CONFIG_PM
-
-static void hsw_pcm_complete(struct device *dev)
-{
-	struct hsw_priv_data *pdata = dev_get_drvdata(dev);
-	struct sst_hsw *hsw = pdata->hsw;
-	struct hsw_pcm_data *pcm_data;
-	int i, err;
-
-	if (pdata->pm_state != HSW_PM_STATE_D3)
-		return;
-
-	err = sst_hsw_dsp_load(hsw);
-	if (err < 0) {
-		dev_err(dev, "failed to reload %d\n", err);
-		return;
-	}
-
-	err = hsw_pcm_create_modules(pdata);
-	if (err < 0) {
-		dev_err(dev, "failed to create modules %d\n", err);
-		return;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-		pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
-
-		if (!pcm_data->substream)
-			continue;
-
-		err = sst_module_runtime_restore(pcm_data->runtime,
-			&pcm_data->context);
-		if (err < 0)
-			dev_err(dev, "failed to restore context for PCM %d\n", i);
-	}
-
-	snd_soc_resume(pdata->soc_card->dev);
-
-	err = sst_hsw_dsp_runtime_resume(hsw);
-	if (err < 0)
-		return;
-	else if (err == 1) /* no action required */
-		return;
-
-	pdata->pm_state = HSW_PM_STATE_D0;
-	return;
-}
-
-static int hsw_pcm_prepare(struct device *dev)
-{
-	struct hsw_priv_data *pdata = dev_get_drvdata(dev);
-	struct hsw_pcm_data *pcm_data;
-	int i, err;
-
-	if (pdata->pm_state == HSW_PM_STATE_D3)
-		return 0;
-	else if (pdata->pm_state == HSW_PM_STATE_D0) {
-		/* suspend all active streams */
-		for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-			pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
-
-			if (!pcm_data->substream)
-				continue;
-			dev_dbg(dev, "suspending pcm %d\n", i);
-			snd_pcm_suspend_all(pcm_data->hsw_pcm);
-
-			/* We need to wait until the DSP FW stops the streams */
-			msleep(2);
-		}
-
-		/* preserve persistent memory */
-		for (i = 0; i < ARRAY_SIZE(mod_map); i++) {
-			pcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];
-
-			if (!pcm_data->substream)
-				continue;
-
-			dev_dbg(dev, "saving context pcm %d\n", i);
-			err = sst_module_runtime_save(pcm_data->runtime,
-				&pcm_data->context);
-			if (err < 0)
-				dev_err(dev, "failed to save context for PCM %d\n", i);
-		}
-		hsw_pcm_suspend(dev);
-	}
-
-	snd_soc_suspend(pdata->soc_card->dev);
-	snd_soc_poweroff(pdata->soc_card->dev);
-
-	pdata->pm_state = HSW_PM_STATE_D3;
-
-	return 0;
-}
-
-#else
-#define hsw_pcm_prepare		NULL
-#define hsw_pcm_complete	NULL
-#endif
-
-static const struct dev_pm_ops hsw_pcm_pm = {
-	.runtime_idle = hsw_pcm_runtime_idle,
-	.runtime_suspend = hsw_pcm_runtime_suspend,
-	.runtime_resume = hsw_pcm_runtime_resume,
-	.prepare = hsw_pcm_prepare,
-	.complete = hsw_pcm_complete,
-};
-
-static struct platform_driver hsw_pcm_driver = {
-	.driver = {
-		.name = "haswell-pcm-audio",
-		.pm = &hsw_pcm_pm,
-	},
-
-	.probe = hsw_pcm_dev_probe,
-	.remove = hsw_pcm_dev_remove,
-};
-module_platform_driver(hsw_pcm_driver);
-
-MODULE_AUTHOR("Liam Girdwood, Xingchao Wang");
-MODULE_DESCRIPTION("Haswell/Lynxpoint + Broadwell/Wildcatpoint PCM");
-MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:haswell-pcm-audio");
-- 
2.17.1

