Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 1B93E3DA08D
	for <lists+alsa-devel@lfdr.de>; Thu, 29 Jul 2021 11:50:02 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id AC0F11B13;
	Thu, 29 Jul 2021 11:49:11 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz AC0F11B13
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1627552201;
	bh=8924I53kcxGGzAVgoxg7FD+iLSnGx87UOIbYweJjxBg=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=Sn5GUyG/BuAS/e1GC9rXyGbO/b1bCd3M+/sRXgRQPr6NutWhObFp7INts+LtjQFL2
	 KJjtAe5tCv3tJ3sKpWzRw1iTR1uypU7AJ7MP9QEJyVxNhh0IdWq5GToPCkR9qMS3Q0
	 P3ENSFtatrwNmkRM23qZFC3AkrXuLce20lb+iGBw=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 061E7F80276;
	Thu, 29 Jul 2021 11:48:34 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id C01EDF8026C; Thu, 29 Jul 2021 11:48:29 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=-0.1 required=5.0 tests=DKIM_SIGNED,DKIM_VALID,
 DKIM_VALID_AU,SPF_HELO_NONE,SPF_NONE,URIBL_BLOCKED autolearn=disabled
 version=3.4.0
Received: from smtp-out1.suse.de (smtp-out1.suse.de [195.135.220.28])
 (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 1B03BF800E9
 for <alsa-devel@alsa-project.org>; Thu, 29 Jul 2021 11:48:25 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 1B03BF800E9
Authentication-Results: alsa1.perex.cz;
 dkim=pass (1024-bit key) header.d=suse.de header.i=@suse.de
 header.b="RcUzmr7S"; 
 dkim=permerror (0-bit key) header.d=suse.de header.i=@suse.de
 header.b="7e9HAB8T"
Received: from relay2.suse.de (relay2.suse.de [149.44.160.134])
 by smtp-out1.suse.de (Postfix) with ESMTP id 28CBF223F8;
 Thu, 29 Jul 2021 09:48:24 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=suse.de; s=susede2_rsa;
 t=1627552104; h=from:from:reply-to:date:date:message-id:message-id:to:to:cc:cc:
 mime-version:mime-version:content-type:content-type:
 in-reply-to:in-reply-to:references:references;
 bh=1GfBweEzJ55yOPJo4QR7hkQ5bfwkIvX22+qPgnRjBnU=;
 b=RcUzmr7SrgDCkiebeVulq2M/ksxsRnkGEJ9AE1ao0k7AO1rO1RoprHGp1QgXM2nE+Up2GW
 8jdLthfvHWDCTW1AlHK196J1S6O8tQRgKG1USUzLTUawiEcP2qqcIwcO7MiVLlmJ40NxY4
 pyjrZKW1WBY4Tm9JBET76LyevFR1JEk=
DKIM-Signature: v=1; a=ed25519-sha256; c=relaxed/relaxed; d=suse.de;
 s=susede2_ed25519; t=1627552104;
 h=from:from:reply-to:date:date:message-id:message-id:to:to:cc:cc:
 mime-version:mime-version:content-type:content-type:
 in-reply-to:in-reply-to:references:references;
 bh=1GfBweEzJ55yOPJo4QR7hkQ5bfwkIvX22+qPgnRjBnU=;
 b=7e9HAB8T/apMZRYmWvTpA7Jt2bppgxT5c33UFF0r5QIC2sY1X3Ub8fyUlnvixq8510dEhb
 Rqc7Xl8ggfgBxjAg==
Received: from alsa1.suse.de (alsa1.suse.de [10.160.4.42])
 by relay2.suse.de (Postfix) with ESMTP id 142A5A3B81;
 Thu, 29 Jul 2021 09:48:24 +0000 (UTC)
Date: Thu, 29 Jul 2021 11:48:24 +0200
Message-ID: <s5him0ta1sn.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Vitaly Rodionov <vitalyr@opensource.cirrus.com>
Subject: Re: [PATCH v2 13/27] ALSA: hda/cs8409: Dont disable I2C clock between
 consecutive accesses
In-Reply-To: <20210728134408.369396-14-vitalyr@opensource.cirrus.com>
References: <20210728134408.369396-1-vitalyr@opensource.cirrus.com>
 <20210728134408.369396-14-vitalyr@opensource.cirrus.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: alsa-devel@alsa-project.org, Lucas Tanure <tanureal@opensource.cirrus.com>,
 patches@opensource.cirrus.com, Takashi Iwai <tiwai@suse.com>,
 linux-kernel@vger.kernel.org, Stefan Binding <sbinding@opensource.cirrus.com>
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Wed, 28 Jul 2021 15:43:54 +0200,
Vitaly Rodionov wrote:
> 
> From: Lucas Tanure <tanureal@opensource.cirrus.com>
> 
> Only disable I2C clock 25 ms after not being used.
> 
> The current implementation enables and disables the I2C clock for each
> I2C transaction. Each enable/disable call requires two verb transactions.
> This means each I2C transaction requires a total of four verb transactions
> to enable and disable the clock.
> However, if there are multiple consecutive I2C transactions, it is not
> necessary to enable and disable the clock each time, instead it is more
> efficient to enable the clock for the first transaction, and disable it
> after the final transaction, which would improve performance.
> This is achieved by using a timeout which disables the clock if no request
> to enable the clock has occurred for 25 ms.
> 
> Signed-off-by: Lucas Tanure <tanureal@opensource.cirrus.com>
> Signed-off-by: Vitaly Rodionov <vitalyr@opensource.cirrus.com>
> Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
> 
> Changes in v2:
> Improved delayed work start/cancel implementation, and re-worked commit message
> adding more explanation why this was required. 
> 
> 
> ---
>  sound/pci/hda/patch_cs8409.c | 56 +++++++++++++++++++++++++-----------
>  sound/pci/hda/patch_cs8409.h |  4 +++
>  2 files changed, 43 insertions(+), 17 deletions(-)
> 
> diff --git a/sound/pci/hda/patch_cs8409.c b/sound/pci/hda/patch_cs8409.c
> index 08205c19698c..fafc0f309e70 100644
> --- a/sound/pci/hda/patch_cs8409.c
> +++ b/sound/pci/hda/patch_cs8409.c
> @@ -53,7 +53,9 @@ static struct cs8409_spec *cs8409_alloc_spec(struct hda_codec *codec)
>  	if (!spec)
>  		return NULL;
>  	codec->spec = spec;
> +	spec->codec = codec;
>  	codec->power_save_node = 1;
> +	INIT_DELAYED_WORK(&spec->i2c_clk_work, cs8409_disable_i2c_clock);
>  	snd_hda_gen_spec_init(&spec->gen);
>  
>  	return spec;
> @@ -72,21 +74,37 @@ static inline void cs8409_vendor_coef_set(struct hda_codec *codec, unsigned int
>  	snd_hda_codec_write(codec, CS8409_PIN_VENDOR_WIDGET, 0, AC_VERB_SET_PROC_COEF, coef);
>  }
>  
> -/**
> +/*
> + * cs8409_disable_i2c_clock - Worker that disable the I2C Clock after 25ms without use
> + */
> +static void cs8409_disable_i2c_clock(struct work_struct *work)
> +{
> +	struct cs8409_spec *spec = container_of(work, struct cs8409_spec, i2c_clk_work.work);
> +
> +	mutex_lock(&spec->cs8409_i2c_mux);
> +	cs8409_vendor_coef_set(spec->codec, 0x0,
> +			       cs8409_vendor_coef_get(spec->codec, 0x0) & 0xfffffff7);
> +	spec->i2c_clck_enabled = 0;
> +	mutex_unlock(&spec->cs8409_i2c_mux);

Here we have a lock in the work, and this would become a problem in
the below...

> +}
> +
> +/*
>   * cs8409_enable_i2c_clock - Enable I2C clocks
>   * @codec: the codec instance
> - * @enable: Enable or disable I2C clocks
> - *
>   * Enable or Disable I2C clocks.
> + * This must be called when the i2c mutex is locked.
>   */
> -static void cs8409_enable_i2c_clock(struct hda_codec *codec, unsigned int enable)
> +static void cs8409_enable_i2c_clock(struct hda_codec *codec)
>  {
> -	unsigned int retval;
> -	unsigned int newval;
> +	struct cs8409_spec *spec = codec->spec;
> +
> +	cancel_delayed_work_sync(&spec->i2c_clk_work);

Here, cancel_delayed_work_sync().  Since it's called inside the mutex
mutex (taken in the caller side), it'll lead to a deadlock.

(I know the i2c mutex lock is moved to this function in a later patch,
but this makes harder to review.  Given that it's only about the
performance, it'd better to apply this kind of change at the end of
series, not in the middle.)

In general, making such an async handling really race-free is not that
trivial.  Even if you call cancel_delayed_work_sync() outside the
mutex, it's possible that another task wedges itself between
cancel_work() and the mutex lock and re-enables the work.

One easier alternative implementation would be rather to allow enable
/ disable clock reentrant with refcounting.  It accepts the function
sequence like:

	enable_clock();
	i2c_write();
	i2c_write();
	...
	disable_clock();

while another thread calls

	enable_clock();
	i2c_write();
	disable_clock();

at the same time.


thanks,

Takashi
