Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 7CC812DE662
	for <lists+alsa-devel@lfdr.de>; Fri, 18 Dec 2020 16:19:20 +0100 (CET)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id F0C0F178E;
	Fri, 18 Dec 2020 16:18:29 +0100 (CET)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz F0C0F178E
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1608304760;
	bh=K3JUNiimlFO4i4DCrgpX3qmdZ6e0kY+5MXhOomxLyIs=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=SxGTJandRqEU7qSBYlHXZ4erJIdynutkQWmUjH3KCmrO6ou5rnBIWjgxVYBQHTBUL
	 TUQQPsSwwsSdlQn1s0VpbpNGVnLqT466quD/JnzXxa0u9CZ2QfaNcGUbkZ24Ww5f8G
	 NrYetSyk3mxJn4cwNYxmEVPCd6N9JlcvyPdeLsEk=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 1D93FF80168;
	Fri, 18 Dec 2020 16:17:44 +0100 (CET)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 7F678F801F7; Fri, 18 Dec 2020 16:17:42 +0100 (CET)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=SPF_HELO_NONE,SPF_NONE
 autolearn=disabled version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 4270FF8014B
 for <alsa-devel@alsa-project.org>; Fri, 18 Dec 2020 16:17:38 +0100 (CET)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 4270FF8014B
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id 5CB9BACF5;
 Fri, 18 Dec 2020 15:17:38 +0000 (UTC)
Date: Fri, 18 Dec 2020 16:17:38 +0100
Message-ID: <s5hczz7i1nx.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Kai Vehmanen <kai.vehmanen@linux.intel.com>
Subject: Re: [RFC][PATCH v2 1/1] alsa: jack: implement software jack injection
 via debugfs
In-Reply-To: <alpine.DEB.2.22.394.2012171749580.864696@eliteleevi.tm.intel.com>
References: <20201216114628.35739-1-hui.wang@canonical.com>
 <20201216114628.35739-2-hui.wang@canonical.com>
 <alpine.DEB.2.22.394.2012171749580.864696@eliteleevi.tm.intel.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: Hui Wang <hui.wang@canonical.com>, alsa-devel@alsa-project.org
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Thu, 17 Dec 2020 17:45:05 +0100,
Kai Vehmanen wrote:
> 
> Hey,
> 
> I gave a quick test spin and features seems to work as advertized. A few 
> minor comments on the code. If Jaroslav you think this would be ok as an 
> approach, I can give a more extensive test run on this.

The tree representation looks better than the previous one, IMO.
The exact contents would need more brush up, though; e.g. the content
of each jack could be shown in a debugfs node as well as the
injection.  Or the type and the mask-to-be-injected can be shown
there, too.

> > +static void _snd_jack_report(struct snd_jack *jack, int status, bool from_inject)
> > +{
> > +	struct snd_jack_kctl *jack_kctl;
> > +	unsigned int mask_bits = 0;
> > +#ifdef CONFIG_SND_JACK_INPUT_DEV
> > +	int i;
> > +#endif
> > +	list_for_each_entry(jack_kctl, &jack->kctl_list, list) {
> > +		if (jack_kctl->sw_inject_enable == from_inject)
> > +			snd_kctl_jack_report(jack->card, jack_kctl->kctl,
> > +					     status & jack_kctl->mask_bits);
> > +		else if (jack_kctl->sw_inject_enable)
> > +			mask_bits |= jack_kctl->mask_bits;
> > +	}
> 
> I'm wondering if it would be worth the code duplication to have the 
> inject-variant of this code in a separate function. I find the above code 
> to set up "mask_bits" a bit hard to read and this adds a layer of 
> complexity to anyone just wanting to look at the regular jack report code 
> path.

Yes, that's my impression, too.  The logic is hard to follow.


> > +static ssize_t sw_inject_enable_write(struct file *file,
> > +				      const char __user *from, size_t count, loff_t *ppos)
> > +{
> > +	struct snd_jack_kctl *jack_kctl = file->private_data;
> > +	char *buf;
> > +	int ret, err;
> > +	unsigned long enable;
> > +
> > +	buf = kzalloc(count, GFP_KERNEL);
> > +	if (!buf)
> > +		return -ENOMEM;
> > +
> > +	ret = simple_write_to_buffer(buf, count, ppos, from, count);
> > +	err = kstrtoul(buf, 0, &enable);
> > +	if (err) {
> > +		ret = err;
> > +		goto exit;
> > +	}
> > +
> > +	jack_kctl->sw_inject_enable = !!enable;
> 
> Here it's a bit annoying that after you disable sw_inject, the kcontrol
> values are not restored to reflrect actual hw state (until there are 
> new jack events from hw). User-space cannot completely handle the 
> save'n'restore as it cannot detect if real hw jack status changed 
> during the sw-inject test. OTOH, this would require caching the most 
> recent value and maybe not worth the effort.

Right, but I guess this can be ignored.

Or, as I mentioned in the above, we may expose the current value in
each node instead, and writing a value to this node is treated as
injection.  Then the rest requirement is rather masking from the
hardware update.


thanks,

Takashi
