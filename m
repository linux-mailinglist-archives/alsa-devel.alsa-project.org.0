Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 99CE735F385
	for <lists+alsa-devel@lfdr.de>; Wed, 14 Apr 2021 14:24:19 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id 238FF74C;
	Wed, 14 Apr 2021 14:23:29 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz 238FF74C
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1618403059;
	bh=siWxyXiAUw52kRPXdd3SAmnaco9ozAEpETgj5PV4bYA=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=VeS1JwciGawIjF175b+NZtVD9/XIT5sKvHQvMF/mwqNLPqD7wqUJ0BtYEMc79Uk3a
	 8xIOa66U9kMq6qEGBzGtNdNpoCJK5r1CNcx/T0TxmCw6lMcEF3e0xYukXZZG8LC5gT
	 gNsO2tDdgnLSYHMvubSblil+ouXxktWDd6ERe6VY=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 824EFF80271;
	Wed, 14 Apr 2021 14:22:50 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 29F15F80269; Wed, 14 Apr 2021 14:22:48 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=SPF_HELO_NONE,SPF_NONE
 autolearn=disabled version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 826D8F80128
 for <alsa-devel@alsa-project.org>; Wed, 14 Apr 2021 14:22:35 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 826D8F80128
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id 617B5AFC1;
 Wed, 14 Apr 2021 12:22:35 +0000 (UTC)
Date: Wed, 14 Apr 2021 14:22:35 +0200
Message-ID: <s5hpmyxukc4.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: "Hans Hu(SH-RD)" <HansHu@zhaoxin.com>
Subject: Re: [2/2]ALSA: hda: add Zhaoxin HDAC non-snoop support: patch a
 design limitation
In-Reply-To: <0f1c89c9728f4310b4e84e4c74df02c6@zhaoxin.com>
References: <0f1c89c9728f4310b4e84e4c74df02c6@zhaoxin.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Cc: "'alsa-devel@alsa-project.org'" <alsa-devel@alsa-project.org>,
 "Zhuangzhuang He\(SH-RD\)" <ZhuangzhuangHe@zhaoxin.com>,
 "Leo Liu\(XA-RD\)" <LeoLiu@zhaoxin.com>,
 "Cobe Chen\(BJ-RD\)" <CobeChen@zhaoxin.com>,
 "Tim Guo\(BJ-RD\)" <TimGuo@zhaoxin.com>,
 "Tony W. Wang\(XA-RD\)" <TonyWWang@zhaoxin.com>
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Wed, 14 Apr 2021 14:00:23 +0200,
Hans Hu(SH-RD) wrote:
> 
> Hi Takashi,
> 
> ZHAOXIN HDAC controller has one design limitation when it works in non-snoop mode. This design limitation is: hardware can't guarantee that the write CORB cycle always completes first before the write CORBWP cycle. Here is the error scene:
> int snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val)
> {
> ...
>         bus->corb.buf[wp] = cpu_to_le32(val);         // cycle_1:  write value to CORB
>         snd_hdac_chip_writew(bus, CORBWP, wp);     // cycle_2:  write wp to CORBWP
> ...
> }
> Normally, after cycle_2, DMA engine will start working and get data from CORB and sent it out. But if cycle_1 haven’t finished yet at this time(limitation occurs), which means the value haven’t been written into CORB, then DMA engine will get unexpected value, then error occurred. (feels like one kind of CORB underrun).
> 
> If we add one read CORB cycle between cycle_1 and cycle_2, cycle_1 and cycle_2 operations will be synchronized, this limitation will be fixed. We have written a draft patch based on this situation and hope to be accepted, the patch example is as follows:
> diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
> index 22af68b..c338db00 100644
> --- a/include/sound/hdaudio.h
> +++ b/include/sound/hdaudio.h
> @@ -339,6 +339,7 @@ struct hdac_bus {
>         bool sync_write:1;              /* sync after verb write */
>         bool use_posbuf:1;              /* use position buffer */
>         bool snoop:1;                   /* enable snooping */
> +       bool no_snoop_corb_sync:1;
>         bool align_bdle_4k:1;           /* BDLE align 4K boundary */
>         bool reverse_assign:1;          /* assign devices in reverse order */
>         bool corbrp_self_clear:1;       /* CORBRP clears itself after reset */
> diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
> index 062da7a..6c90cdd 100644
> --- a/sound/hda/hdac_controller.c
> +++ b/sound/hda/hdac_controller.c
> @@ -167,6 +167,8 @@ int snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val)
> 
>         bus->rirb.cmds[addr]++;
>         bus->corb.buf[wp] = cpu_to_le32(val);
> +       if (bus->no_snoop_corb_sync)
> +               val = bus->corb.buf[wp];
>         snd_hdac_chip_writew(bus, CORBWP, wp);

Just wondering whether using WRITE_ONCE() macro would be enough?
e.g.
	WRITE_ONCE(bus->corb.buf[wp], cpu_to_le32(val));

Also, no_snoop_corb_sync is a bit confusing.  What you do is rather
sync of the written value, so it can be taken as if other way round.
Maybe no_coherent_corb_write or such would be better understandable.


thanks,

Takashi
