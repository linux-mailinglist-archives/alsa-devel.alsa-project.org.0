Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 6D2D82C0D7B
	for <lists+alsa-devel@lfdr.de>; Mon, 23 Nov 2020 15:30:37 +0100 (CET)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id 0E28A1673;
	Mon, 23 Nov 2020 15:29:47 +0100 (CET)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz 0E28A1673
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1606141837;
	bh=RNYpbJjk4EmD80V7vXH0pXp1U2pAHh28MD1PuBPRxtY=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=djI+ai0KXIi97f+vVhr2DTNLq8N3c+ATWebqo73lgF0H4d2CAVy+OTJZ2cUPkwlD8
	 edQ9gxEDKINZcdy7wNTIK7wSup5e2Orr6T2zoT5bstYHKcKIyseYuuYVZHofCUfk1n
	 XR07m7Fq+C8U0NQKQKiNfDYR8+zBYLIZggvj5M0A=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 531A7F80268;
	Mon, 23 Nov 2020 15:29:03 +0100 (CET)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 5222FF80255; Mon, 23 Nov 2020 15:29:01 +0100 (CET)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=RCVD_IN_MSPIKE_H3,
 RCVD_IN_MSPIKE_WL,SPF_HELO_NONE,SPF_PASS,URIBL_BLOCKED autolearn=disabled
 version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id D6097F8015B
 for <alsa-devel@alsa-project.org>; Mon, 23 Nov 2020 15:28:55 +0100 (CET)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz D6097F8015B
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id 08E7EAE95;
 Mon, 23 Nov 2020 14:28:55 +0000 (UTC)
Date: Mon, 23 Nov 2020 15:28:54 +0100
Message-ID: <s5hblfo87vd.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Michael Nazzareno Trimarchi <michael@amarulasolutions.com>
Subject: Re: Poor performace on mmap reading arm64 on audio device
In-Reply-To: <CAOf5uwnWDaz4hK5AHEaK8guLkuVjSs+n1NcRLr+gNmyoOwWOUQ@mail.gmail.com>
References: <CAOf5uwmtixmz+RgimC_2Z31+NwRF03RJ-u0mN3NKpzhks1dzEw@mail.gmail.com>
 <s5hzh388awp.wl-tiwai@suse.de>
 <CAOf5uwmkuQDBH5gQFA4XfkiTipYKEZ8micyEkd_Xd8KFqSDZSA@mail.gmail.com>
 <s5hmtz889gw.wl-tiwai@suse.de>
 <CAOf5uwnWDaz4hK5AHEaK8guLkuVjSs+n1NcRLr+gNmyoOwWOUQ@mail.gmail.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: Nicolin Chen <nicoleotsuka@gmail.com>,
 Linux-ALSA <alsa-devel@alsa-project.org>, Mark Brown <broonie@linaro.org>
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Mon, 23 Nov 2020 15:19:34 +0100,
Michael Nazzareno Trimarchi wrote:
> 
> Hi
> 
> On Mon, Nov 23, 2020 at 2:54 PM Takashi Iwai <tiwai@suse.de> wrote:
> >
> > On Mon, 23 Nov 2020 14:44:52 +0100,
> > Michael Nazzareno Trimarchi wrote:
> > >
> > > Hi
> > >
> > > On Mon, Nov 23, 2020 at 2:23 PM Takashi Iwai <tiwai@suse.de> wrote:
> > > >
> > > > On Sat, 21 Nov 2020 10:40:04 +0100,
> > > > Michael Nazzareno Trimarchi wrote:
> > > > >
> > > > > Hi all
> > > > >
> > > > > I'm trying to figure out how to increase performance on audio reading
> > > > > using the mmap interface. Right now what I understand it's that
> > > > > allocation comes from core/memalloc.c ops that allocate the memory for
> > > > > dma under driver/dma.
> > > > > The reference platform I have is an imx8mm and the allocation in arm64 is:
> > > > >
> > > > > 0xffff800011ff5000-0xffff800012005000          64K PTE       RW NX SHD
> > > > > AF            UXN MEM/NORMAL-NC
> > > > >
> > > > > This is the reason that is allocated for dma interface.
> > > > >
> > > > > Now access linear on the multichannel interface the performance is bad
> > > > > but worse if I try to access a channel a time on read.
> > > > > So it looks like it is better to copy the block using memcpy on a
> > > > > cached area and then operate on a single channel sample. If it's
> > > > > correct what I'm saying the mmap_begin and mmap_commit
> > > > > basically they don't do anything on cache level so the page mapping
> > > > > and way is used is always the same. Can the interface be modified to
> > > > > allow cache the area during read and restore in the commit
> > > > > phase?
> > > >
> > > > The current API of the mmap for the sound ring-buffer is designed to
> > > > allow concurrent accesses at any time in the minimalistic kernel-user
> > > > context switching.  So the whole buffer is allocated as coherent and
> > > > mmapped in a shot.  It's pretty efficient for architectures like x86,
> > > > but has disadvantages on ARM, indeed.
> > >
> > > Each platform e/o architecture can specialize the mmap and declare the
> > > area that is consistent in dma to me mapped
> > > as no cache one
> > >
> > > vma->vm_page_prot = pgprot_cached(vma->vm_page_prot);
> > >                 return remap_pfn_range(vma, vma->vm_start,
> > >                                 vma->vm_end - vma->vm_start, vma->vm_page_prot);
> > >
> > > I have done it for testing purposes. This give an idea
> > >
> > > - read multi channel not sequentially took around 12% of the cpu with
> > > mmap interface
> > > - read multi channel use after a memcpy took around 6%
> > > - read on a cached area took around 3%. I'm trying to figure out how
> > > and when invalidate the area
> > >
> > > I have two use cases:
> > > - write on the channels (no performance issue)
> > > - read on channels
> > >
> > > Before reading I should only say that the cached area is not in sync
> > > with memory. I think that supporting write use cases
> > > makes little sense here.
> >
> > It's a necessary use case, unfortunately.  The reason we ended up with
> > one device per direction for the PCM in many many years ago was that
> > some applications need to write the buffers for marking even for the
> > read.  So it can't be read-only, and it's supposed to be coherent on
> > both read and write -- as long as keeping the current API usage.
> >
> 
> If I understand the allocation of the dma buffer depends on the direction.
> Each device allocate one dma_buffer for tx device and one dma buffer
> for rx device
> 
> @@ -105,10 +105,16 @@ static int imx_pcm_preallocate_dma_buffer(struct
> snd_pcm_substream *substream,
>         size_t size = imx_pcm_hardware.buffer_bytes_max;
>         int ret;
> 
> -       ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV_IRAM,
> -                                 dev,
> -                                 size,
> -                                 &substream->dma_buffer);
> +       if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
> +               ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
> +                                         dev,
> +                                         size,
> +                                         &substream->dma_buffer);
> +       else
> +               ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV_IRAM,
> +                                         dev,
> +                                         size,
> +                                         &substream->dma_buffer);
>         if (ret)
>                 return ret;
> 
> Just a snippet from me, on some of my testing. How the physical memory
> is used by the kernel is nothing to do in how the memory is then mapped
> by the userspace to read from it. If I allocate it consistente in
> snd_dma_alloc_pages
> then you can let the user remap the area as cached in his own virtual mapping.
> What I'm trying to said is that behind the scene everything is
> consistent but the user
> will get a cache line read during the first access and then he/she
> will read from the cache.
> Maybe is this assumption is totally wrong?

Ah I see your point now.  I believe that this kind of mapping tweak
could be done, but this doesn't satisfy the expectation of the mmap of
the current sound API; e.g. dmix / dsnoop would fail.  So, if any,
this should be an extension for some special usages.

My original idea was to totally go away from the coherent allocation
and mapping, but just let dynamically syncing like other drivers do
(e.g. net devices), aligned with mmap_begin/mmap_commit in alsa-lib.


Takashi
