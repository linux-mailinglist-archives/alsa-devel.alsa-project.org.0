Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 58A0E101984
	for <lists+alsa-devel@lfdr.de>; Tue, 19 Nov 2019 07:49:20 +0100 (CET)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id CB5FD168B;
	Tue, 19 Nov 2019 07:48:29 +0100 (CET)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz CB5FD168B
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1574146159;
	bh=l5/JR5mPXMhkO3KHBvnWFgiH4i5c3KsPMOl05x4paCg=;
	h=Date:From:To:In-Reply-To:References:Cc:Subject:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=JueX/e6pPky2ouqI4DQ5ua/DhBKYaPhUGb+yTUun3aiKyC3ildYI0cZw/4/0XGN2z
	 voiRWkPgWD3MMqzhWdp14uuSjIU8drC3fPGB/UI1Z+cDP3tyW66J0Apny8uSnyYCUd
	 NfCj8VXAxqw5+p0nSFEsClxb1FCVkyrTlcbVeQos=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id EFD65F80135;
	Tue, 19 Nov 2019 07:47:35 +0100 (CET)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id AD918F80137; Tue, 19 Nov 2019 07:47:32 +0100 (CET)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: *
X-Spam-Status: No, score=1.0 required=5.0 tests=PRX_BODY_30,SPF_HELO_NONE,
 SPF_PASS autolearn=disabled version=3.4.0
Received: from mx1.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 782DBF800F4
 for <alsa-devel@alsa-project.org>; Tue, 19 Nov 2019 07:47:30 +0100 (CET)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 782DBF800F4
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.220.254])
 by mx1.suse.de (Postfix) with ESMTP id 81DCFAD2C;
 Tue, 19 Nov 2019 06:47:29 +0000 (UTC)
Date: Tue, 19 Nov 2019 07:47:29 +0100
Message-ID: <s5ha78sz7jy.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Nikhil Mahale <nmahale@nvidia.com>
In-Reply-To: <6e8b6415-bad3-3530-4543-3ab3569b69fc@nvidia.com>
References: <20191115095606.22392-1-nmahale@nvidia.com>
 <20191115095606.22392-3-nmahale@nvidia.com>
 <s5hd0dtjnag.wl-tiwai@suse.de>
 <6e8b6415-bad3-3530-4543-3ab3569b69fc@nvidia.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Cc: alsa-devel@alsa-project.org, tiwai@suse.com, aplattner@nvidia.com
Subject: Re: [alsa-devel] [PATCH v2 2/5] ALSA: hda - Add DP-MST jack support
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: 7bit
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Tue, 19 Nov 2019 05:45:26 +0100,
Nikhil Mahale wrote:
> 
> On 11/15/19 6:42 PM, Takashi Iwai wrote:
> > On Fri, 15 Nov 2019 10:56:03 +0100,
> > Nikhil Mahale wrote:
> >>
> >>  static struct hda_jack_tbl *
> >> -snd_hda_jack_tbl_new(struct hda_codec *codec, hda_nid_t nid)
> >> +snd_hda_jack_tbl_new(struct hda_codec *codec, hda_nid_t nid, int dev_id)
> >>  {
> >> -	struct hda_jack_tbl *jack = snd_hda_jack_tbl_get(codec, nid);
> >> +	struct hda_jack_tbl *jack =
> >> +		snd_hda_jack_tbl_get_mst(codec, nid, dev_id);
> >> +	struct hda_jack_tbl *existing_nid_jack =
> >> +		any_jack_tbl_get_from_nid(codec, nid);
> >> +
> >> +	WARN_ON(dev_id != 0 && !codec->dp_mst);
> >> +
> >>  	if (jack)
> >>  		return jack;
> >>  	jack = snd_array_new(&codec->jacktbl);
> >>  	if (!jack)
> >>  		return NULL;
> >>  	jack->nid = nid;
> >> +	jack->dev_id = dev_id;
> >>  	jack->jack_dirty = 1;
> >> -	jack->tag = codec->jacktbl.used;
> >> +	if (!existing_nid_jack)
> >> +		jack->tag = codec->jacktbl.used;
> >> +	else
> >> +		jack->tag = existing_nid_jack->tag;
> >> +
> >>  	return jack;
> >>  }
> > 
> > In this logic, we assign the same tag to multiple jack objects, and
> > this will lead to the multiple calls of SET_UNSOLICITED_ENABLE on the
> > same pin.  But this should be only once at parsing, and the rest
> > resume init will be done from the codec regmap cache, so it's not too
> > bad, I guess.
> > 
> > Alternatively we can set 0 to jack->tag when existing_nid_jack!=NULL,
> > too, and skip SET_UNSOLICITED_ENABLE for tag==0.  But this will make
> > *_get_from_tag() won't work as you intended, hence the step will be
> > - get the jack once via snd_hda_jack_tbl_get_from_tag(tag)
> > - get the jack again with snd_hda_jack_tbl_get_mst(jack->nid, dev_id)
> > But it's more complex, and not better, either.
> 
> I am bit skeptical over this idea. One can build hypothetical case like - you create 2 jack objects, first one for (nid=1, dev_id=0) with jack->tag!=0 and second one for (nid=1, dev_id=1) with jack->tag==0. If you want free first jack object and continue working with second one then that would create problem because you lose tag with destruction of first object?
> 
> If objective is not to make multiple calls of SET_UNSOLICITED_ENABLE on the same pin, then just like jack->tag we can inherit jack->jack_detect from  existing_nid_jack. That can make sure snd_hda_jack_detect_enable_callback_mst() not to do multiple calls of SET_UNSOLICITED_ENABLE on the same pin, right?
> 
> I am suggesting code change like -
> 
> ...
> snd_hda_jack_tbl_new(...)
> {
>     [...]
>     if (!existing_nid_jack) {
>         jack->tag = codec->jacktbl.used;
>     } else {
>         jack->tag = existing_nid_jack->tag;
>         jack->jack_detect = existing_nid_jack->jack_detect;
>     }
>     [...]
> }

Yes, this looks like a good idea.


thanks,

Takashi
_______________________________________________
Alsa-devel mailing list
Alsa-devel@alsa-project.org
https://mailman.alsa-project.org/mailman/listinfo/alsa-devel
