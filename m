Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id E680935F0FC
	for <lists+alsa-devel@lfdr.de>; Wed, 14 Apr 2021 11:46:09 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id 7C32416E6;
	Wed, 14 Apr 2021 11:45:19 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz 7C32416E6
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1618393569;
	bh=C78gfFG7ZqCwa3mBe/eU3YTvZeeAgSihOjbngiPViLk=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=XTWt79QQDzRHqIsT1VkssjfIXj7Qz9DLLdoAsCjK+i/7qyX+pFu/lU0lavtMnkcwq
	 Tk+aE6rppZPNgivyozABoTvpPx1PVoSsBelyafkPh+e9DNP/ScqP3CCX+RQCYjpAw2
	 kgm/AQzBMMYgOVO7da3Za7TTAnyGR4bQmWDqBbLQ=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 16503F800EB;
	Wed, 14 Apr 2021 11:44:41 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id DAB82F80269; Wed, 14 Apr 2021 11:44:38 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: *
X-Spam-Status: No, score=1.0 required=5.0 tests=PRX_BODY_30,SPF_HELO_NONE,
 SPF_NONE,URIBL_BLOCKED autolearn=disabled version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 44114F80128
 for <alsa-devel@alsa-project.org>; Wed, 14 Apr 2021 11:44:31 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 44114F80128
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id 1C87DAD09;
 Wed, 14 Apr 2021 09:44:31 +0000 (UTC)
Date: Wed, 14 Apr 2021 11:44:30 +0200
Message-ID: <s5h35vtw681.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Jaroslav Kysela <perex@perex.cz>
Subject: Re: [PATCH] ALSA: control_led - fix the stack usage (control element
 ops)
In-Reply-To: <20210414093031.1934261-1-perex@perex.cz>
References: <20210414093031.1934261-1-perex@perex.cz>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: Nathan Chancellor <nathan@kernel.org>,
 ALSA development <alsa-devel@alsa-project.org>
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Wed, 14 Apr 2021 11:30:31 +0200,
Jaroslav Kysela wrote:
> 
> It's a bad idea to allocate big structures on the stack. Allocate
> the required structures on demand and cache them in the led
> structure.
> 
> Fixes: 22d8de62f11b ("ALSA: control - add generic LED trigger module as the new control layer")
> Signed-off-by: Jaroslav Kysela <perex@perex.cz>
> Cc: Nathan Chancellor <nathan@kernel.org>
> Cc: Takashi Sakamoto <o-takashi@sakamocchi.jp>

Thanks for the patch.

But, wouldn't it be simpler if we just add snd_ctl_elem_info and
_value in snd_ctl_led object itself?

-- 8< --
--- a/sound/core/control_led.c
+++ b/sound/core/control_led.c
@@ -38,6 +38,8 @@ struct snd_ctl_led {
 	enum led_audio trigger_type;
 	enum snd_ctl_led_mode mode;
 	struct snd_ctl_led_card *cards[SNDRV_CARDS];
+	struct snd_ctl_elem_info elem_info;
+	struct snd_ctl_elem_value elem_value;
 };
 
 struct snd_ctl_led_ctl {

-- 8< --

Then we need no extra kmalloc.  I guess snd_ctl_led_get() shall be
called almost always, so we won't save much even if we allocate
dynamically.


thanks,

Takashi


> ---
>  sound/core/control_led.c | 52 ++++++++++++++++++++++++----------------
>  1 file changed, 32 insertions(+), 20 deletions(-)
> 
> diff --git a/sound/core/control_led.c b/sound/core/control_led.c
> index 93b201063c7d..9d1612b1a6ff 100644
> --- a/sound/core/control_led.c
> +++ b/sound/core/control_led.c
> @@ -37,6 +37,7 @@ struct snd_ctl_led {
>  	unsigned int group;
>  	enum led_audio trigger_type;
>  	enum snd_ctl_led_mode mode;
> +	void *info_and_value;
>  	struct snd_ctl_led_card *cards[SNDRV_CARDS];
>  };
>  
> @@ -94,34 +95,41 @@ static struct snd_ctl_led *snd_ctl_led_get_by_access(unsigned int access)
>  	return &snd_ctl_leds[group];
>  }
>  
> -static int snd_ctl_led_get(struct snd_ctl_led_ctl *lctl)
> +static int snd_ctl_led_get(struct snd_ctl_led *led, struct snd_ctl_led_ctl *lctl)
>  {
>  	struct snd_kcontrol *kctl = lctl->kctl;
> -	struct snd_ctl_elem_info info;
> -	struct snd_ctl_elem_value value;
> +	struct snd_ctl_elem_info *info = led->info_and_value;
> +	struct snd_ctl_elem_value *value;
>  	unsigned int i;
>  	int result;
>  
> -	memset(&info, 0, sizeof(info));
> -	info.id = kctl->id;
> -	info.id.index += lctl->index_offset;
> -	info.id.numid += lctl->index_offset;
> -	result = kctl->info(kctl, &info);
> +	if (info == NULL) {
> +		info = kmalloc(sizeof(*info) + sizeof(*value), GFP_KERNEL);
> +		if (info == NULL)
> +			return -1;
> +		led->info_and_value = info;
> +	}
> +	value = (void *)(info + 1);
> +	memset(info, 0, sizeof(*info));
> +	info->id = kctl->id;
> +	info->id.index += lctl->index_offset;
> +	info->id.numid += lctl->index_offset;
> +	result = kctl->info(kctl, info);
>  	if (result < 0)
>  		return -1;
> -	memset(&value, 0, sizeof(value));
> -	value.id = info.id;
> -	result = kctl->get(kctl, &value);
> +	memset(value, 0, sizeof(*value));
> +	value->id = info->id;
> +	result = kctl->get(kctl, value);
>  	if (result < 0)
>  		return -1;
> -	if (info.type == SNDRV_CTL_ELEM_TYPE_BOOLEAN ||
> -	    info.type == SNDRV_CTL_ELEM_TYPE_INTEGER) {
> -		for (i = 0; i < info.count; i++)
> -			if (value.value.integer.value[i] != info.value.integer.min)
> +	if (info->type == SNDRV_CTL_ELEM_TYPE_BOOLEAN ||
> +	    info->type == SNDRV_CTL_ELEM_TYPE_INTEGER) {
> +		for (i = 0; i < info->count; i++)
> +			if (value->value.integer.value[i] != info->value.integer.min)
>  				return 1;
> -	} else if (info.type == SNDRV_CTL_ELEM_TYPE_INTEGER64) {
> -		for (i = 0; i < info.count; i++)
> -			if (value.value.integer64.value[i] != info.value.integer64.min)
> +	} else if (info->type == SNDRV_CTL_ELEM_TYPE_INTEGER64) {
> +		for (i = 0; i < info->count; i++)
> +			if (value->value.integer64.value[i] != info->value.integer64.min)
>  				return 1;
>  	}
>  	return 0;
> @@ -149,7 +157,7 @@ static void snd_ctl_led_set_state(struct snd_card *card, unsigned int access,
>  	list_for_each_entry(lctl, &led->controls, list) {
>  		if (lctl->kctl == kctl && lctl->index_offset == ioff)
>  			found = true;
> -		UPDATE_ROUTE(route, snd_ctl_led_get(lctl));
> +		UPDATE_ROUTE(route, snd_ctl_led_get(led, lctl));
>  	}
>  	if (!found && kctl && card) {
>  		lctl = kzalloc(sizeof(*lctl), GFP_KERNEL);
> @@ -159,7 +167,7 @@ static void snd_ctl_led_set_state(struct snd_card *card, unsigned int access,
>  			lctl->kctl = kctl;
>  			lctl->index_offset = ioff;
>  			list_add(&lctl->list, &led->controls);
> -			UPDATE_ROUTE(route, snd_ctl_led_get(lctl));
> +			UPDATE_ROUTE(route, snd_ctl_led_get(led, lctl));
>  		}
>  	}
>  	mutex_unlock(&snd_ctl_led_mutex);
> @@ -300,6 +308,10 @@ static void snd_ctl_led_clean(struct snd_card *card)
>  				snd_ctl_led_ctl_destroy(lctl);
>  				goto repeat;
>  			}
> +		if (!card) {
> +			kfree(led->info_and_value);
> +			led->info_and_value = NULL;
> +		}
>  	}
>  }
>  
> -- 
> 2.30.2
> 
