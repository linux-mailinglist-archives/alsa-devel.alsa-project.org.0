Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 8290438AE89
	for <lists+alsa-devel@lfdr.de>; Thu, 20 May 2021 14:39:21 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id 0E0271688;
	Thu, 20 May 2021 14:38:31 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz 0E0271688
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1621514361;
	bh=4UNTjMVQ0hNDLyO4FoEYbCT2qZ1Srw95wP5/jnuL5PI=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=nsr1W+c6U5lIDfMaClH/VdEZzP95GY2GWAL8JsDHHukOXLG7JtrKqc9GdgPjOvkmr
	 tHARe8Nb+Pb6YsmIxJKPinUDPJzbaFLDzCjx73Yq7x33/7J3gkF4vm0jblLd4qMO1w
	 5o8GaxXjUcPA5Mm4Nce63kTInWJ/Thq06GX+0ZUM=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 68184F800C8;
	Thu, 20 May 2021 14:37:51 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 7C02CF80217; Thu, 20 May 2021 14:37:49 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=SPF_HELO_NONE,SPF_NONE,
 URIBL_BLOCKED autolearn=disabled version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id DBC5FF800C8
 for <alsa-devel@alsa-project.org>; Thu, 20 May 2021 14:37:42 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz DBC5FF800C8
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id 3BCCBABE8;
 Thu, 20 May 2021 12:37:42 +0000 (UTC)
Date: Thu, 20 May 2021 14:37:42 +0200
Message-ID: <s5hfsyhh97t.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Colin Ian King <colin.king@canonical.com>
Subject: Re: ALSA: usb-audio: Handle error for the current selector gracefully
 [ uninitialized variable issue ]
In-Reply-To: <4b261d68-f53f-240d-2d8a-2f88b337849d@canonical.com>
References: <4b261d68-f53f-240d-2d8a-2f88b337849d@canonical.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>,
 alsa-devel@alsa-project.org, Takashi Iwai <tiwai@suse.com>
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Thu, 20 May 2021 10:58:21 +0200,
Colin Ian King wrote:
> 
> Hi,
> 
> Static analysis with Coverity on linux-next has detected an
> uninitialized variable issue with the following commit:
> 
> commit 481f17c41803985446fd12887b2c042f9c43b0d5
> Author: Takashi Iwai <tiwai@suse.de>
> Date:   Tue May 18 17:21:12 2021 +0200
> 
>     ALSA: usb-audio: Handle error for the current selector gracefully
> 
> The branching is a bit convoluted and we end up with variable cur not
> being initialized. Analysis is as follows:
> 
> 254static int __uac_clock_find_source(struct snd_usb_audio *chip,
> 255                                   const struct audioformat *fmt, int
> entity_id,
> 256                                   unsigned long *visited, bool validate)
> 257{
> 258        union uac23_clock_source_desc *source;
> 259        union uac23_clock_selector_desc *selector;
> 260        union uac23_clock_multiplier_desc *multiplier;
> 
>    1. var_decl: Declaring variable cur without initializer.
> 
> 261        int ret, i, cur, err, pins, clock_id;
> 262        const u8 *sources;
> 263        int proto = fmt->protocol;
> 264
> 265        entity_id &= 0xff;
> 266
> 
>    2. Condition test_and_set_bit(entity_id, visited), taking false
> branch.
> 
> 267        if (test_and_set_bit(entity_id, visited)) {
> 268                usb_audio_warn(chip,
> 269                         "%s(): recursive clock topology detected, id
> %d.\n",
> 270                         __func__, entity_id);
> 271                return -EINVAL;
> 272        }
> 273
> 274        /* first, see if the ID we're looking for is a clock source
> already */
> 275        source = snd_usb_find_clock_source(chip, entity_id, proto);
> 
>    3. Condition source, taking false branch.
> 
> 276        if (source) {
> 277                entity_id = GET_VAL(source, proto, bClockID);
> 278                if (validate && !uac_clock_source_is_valid(chip, fmt,
> 279
> entity_id)) {
> 280                        usb_audio_err(chip,
> 281                                "clock source %d is not valid, cannot
> use\n",
> 282                                entity_id);
> 283                        return -ENXIO;
> 284                }
> 285                return entity_id;
> 286        }
> 287
> 288        selector = snd_usb_find_clock_selector(chip, entity_id, proto);
> 
>    4. Condition selector, taking true branch.
> 289        if (selector) {
>    5. Condition proto == 48, taking true branch.
> 290                pins = GET_VAL(selector, proto, bNrInPins);
>    6. Condition proto == 48, taking true branch.
> 291                clock_id = GET_VAL(selector, proto, bClockID);
>    7. Condition proto == 48, taking true branch.
> 292                sources = GET_VAL(selector, proto, baCSourceID);
> 293
>    8. Condition pins == 1, taking false branch.
> 
> 294                if (pins == 1) {
> 295                        ret = 1;
> 296                        goto find_source;
> 297                }
> 298
> 299                /* the entity ID we are looking for is a selector.
> 300                 * find out what it currently selects */
> 301                ret = uac_clock_selector_get_val(chip, clock_id);
> 
>    9. Condition ret < 0, taking true branch.
> 
> 302                if (ret < 0) {
> 
>    10. Condition !chip->autoclock, taking false branch.
> 
> 303                        if (!chip->autoclock)
> 304                                return ret;
> 
>    11. Jumping to label find_others.
> 
> 305                        goto find_others;
> 306                }
> 307
> 308                /* Selector values are one-based */
> 309
> 310                if (ret > pins || ret < 1) {
> 311                        usb_audio_err(chip,
> 312                                "%s(): selector reported illegal
> value, id %d, ret %d\n",
> 313                                __func__, clock_id, ret);
> 314
> 315                        if (!chip->autoclock)
> 316                                return -EINVAL;
> 317                        ret = 0;
> 318                        goto find_others;
> 319                }
> 320
> 321        find_source:
> 322                cur = ret;
> 323                ret = __uac_clock_find_source(chip, fmt,
> 324                                              sources[ret - 1],
> 325                                              visited, validate);
> 326                if (ret > 0) {
> 327                        err = uac_clock_selector_set_val(chip,
> entity_id, cur);
> 328                        if (err < 0)
> 329                                return err;
> 330                }
> 331
> 332                if (!validate || ret > 0 || !chip->autoclock)
> 333                        return ret;
> 334
> 335        find_others:
> 336                /* The current clock source is invalid, try others. */
>    12. Condition i <= pins, taking true branch.
> 337                for (i = 1; i <= pins; i++) {
> 
> Uninitialized scalar variable (UNINIT)
> 
>    13. uninit_use: Using uninitialized value cur.
> 
> 338                        if (i == cur)
> 339                                continue;
> 340

Thanks, it looks indeed like a possible scenario.
The fix patch is below.


Takashi

-- 8< --
From: Takashi Iwai <tiwai@suse.de>
Subject: [PATCH] ALSA: usb-audio: Fix uninitialized variable at
 __uac_clock_find_source()

The cur variable indicating the currently selected clock source can be
theoretically used as uninitialized after the recent commit
481f17c41803 ("ALSA: usb-audio: Handle error for the current selector
gracefully").  For addressing it, initialize it before use.

Also, one place seems setting 0 to a wrong variable ret, instead of
cur; otherwise it makes little sense.  Since the initialization is
done beforehand, we can get rid of this line, too.

Fixes: 481f17c41803 ("ALSA: usb-audio: Handle error for the current selector gracefully")
Reported-by: Colin Ian King <colin.king@canonical.com>
Link: https://lore.kernel.org/r/4b261d68-f53f-240d-2d8a-2f88b337849d@canonical.com
Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 sound/usb/clock.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sound/usb/clock.c b/sound/usb/clock.c
index 772478c725c2..0afae839d295 100644
--- a/sound/usb/clock.c
+++ b/sound/usb/clock.c
@@ -290,6 +290,7 @@ static int __uac_clock_find_source(struct snd_usb_audio *chip,
 		pins = GET_VAL(selector, proto, bNrInPins);
 		clock_id = GET_VAL(selector, proto, bClockID);
 		sources = GET_VAL(selector, proto, baCSourceID);
+		cur = 0;
 
 		if (pins == 1) {
 			ret = 1;
@@ -314,7 +315,6 @@ static int __uac_clock_find_source(struct snd_usb_audio *chip,
 
 			if (!chip->autoclock)
 				return -EINVAL;
-			ret = 0;
 			goto find_others;
 		}
 
-- 
2.26.2

