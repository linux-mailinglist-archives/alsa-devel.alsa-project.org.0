Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 92594429CD4
	for <lists+alsa-devel@lfdr.de>; Tue, 12 Oct 2021 06:57:34 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id 2EE2F16A0;
	Tue, 12 Oct 2021 06:56:44 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz 2EE2F16A0
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1634014654;
	bh=LqJemn0F4RS+l7dy4iUVNfok2Fi4rChCvwOWPcRxGO0=;
	h=Date:From:Subject:To:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=Pjl9oBt1fvMznINITnHWIuR8MfMAapV5mXls1u9X84mlIackRfMAyBgyrkTdHYSdO
	 msnJIv3KugtiOYMYUUqeVZx+bqonU5g2J2MRd0FxhzIxQ31qKWemNoZZvP2nfjHlT2
	 b0OgN67kq03qom8EE7PizRdtKIE/rGlfDHVDwhwQ=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id EFF39F804E5;
	Tue, 12 Oct 2021 06:55:49 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 4D0E5F804E6; Tue, 12 Oct 2021 06:55:48 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.4 required=5.0 tests=KHOP_HELO_FCRDNS, SPF_HELO_NONE,
 SPF_NONE,URIBL_BLOCKED autolearn=disabled version=3.4.0
Received: from relmlie5.idc.renesas.com (relmlor1.renesas.com
 [210.160.252.171])
 by alsa1.perex.cz (Postfix) with ESMTP id 26DB6F80212
 for <alsa-devel@alsa-project.org>; Tue, 12 Oct 2021 06:55:40 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 26DB6F80212
Date: 12 Oct 2021 13:55:33 +0900
X-IronPort-AV: E=Sophos;i="5.85,366,1624287600"; d="scan'208";a="96710737"
Received: from unknown (HELO relmlir5.idc.renesas.com) ([10.200.68.151])
 by relmlie5.idc.renesas.com with ESMTP; 12 Oct 2021 13:55:33 +0900
Received: from mercury.renesas.com (unknown [10.166.252.133])
 by relmlir5.idc.renesas.com (Postfix) with ESMTP id DFD824007F58;
 Tue, 12 Oct 2021 13:55:33 +0900 (JST)
Message-ID: <87y26ylu4a.wl-kuninori.morimoto.gx@renesas.com>
From: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Subject: [PATCH v5 08/16] ASoC: audio-graph-card2: add Codec2Codec support
User-Agent: Wanderlust/2.15.9 Emacs/26.3 Mule/6.0
To: Mark Brown <broonie@kernel.org>
In-Reply-To: <87a6jen8su.wl-kuninori.morimoto.gx@renesas.com>
References: <87a6jen8su.wl-kuninori.morimoto.gx@renesas.com>
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
Cc: Linux-ALSA <alsa-devel@alsa-project.org>
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>


From: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>

This patch adds Codec2Codec support to audio-graph-card2.
It can use Codec2Codec but very simple case only for now.
It doesn't have "SWITCH" control yet, thus it start automatically
when it was probed, and can't stop, so far.
Thus it needs to be updated around widgets/routing handling,
and you need to understand that it is under experimental.

Codec has SND_SOC_DAPM_INPUT() (= IN) / SND_SOC_DAPM_OUTPUT(= OUT)
widgets in below case.

It is assuming 2channel, S32_LE format for now.
It needs to be updated, too.

It needs "codec2codec" node (= B), needs to have routing (= A),
need to indicate CPU side at links (= X).
ports@0 is for CPU side (= X), port@1 is Codec side (= Y).
It needs to have "rate" (= C)

	+--+
	|  |<-- Codec0 <-- IN
	|  |--> Codec1 --> OUT
	+--+

	sound {
		compatible = "audio-graph-card2";

(A)		routing = "OUT" ,"DAI1 Playback",
			  "DAI0 Capture", "IN";

(X)		links = <&c2c>;

(B)		codec2codec {
			ports {
(C)				rate = <48000>;
(X)			c2c:	port@0 { c2cf_ep: endpoint { remote-endpoint = <&codec0_ep>; }; };
(Y)				port@1 { c2cb_ep: endpoint { remote-endpoint = <&codec1_ep>; }; };
		};
	};

	Codec {
		ports {
			port@0 {
				 bitclock-master;
				 frame-master;
				 codec0_ep: endpoint { remote-endpoint = <&c2cf_ep>; }; };
			port@1 { codec1_ep: endpoint { remote-endpoint = <&c2cb_ep>; }; };
		};
	};

Link: https://lore.kernel.org/r/87k0xszlep.wl-kuninori.morimoto.gx@renesas.com
Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
---
 include/sound/graph_card.h            |   3 +
 sound/soc/generic/audio-graph-card2.c | 181 ++++++++++++++++++++++++++
 2 files changed, 184 insertions(+)

diff --git a/include/sound/graph_card.h b/include/sound/graph_card.h
index ece78a84391c..4c8b94c77b8e 100644
--- a/include/sound/graph_card.h
+++ b/include/sound/graph_card.h
@@ -18,6 +18,7 @@ struct graph2_custom_hooks {
 	int (*hook_post)(struct asoc_simple_priv *priv);
 	GRAPH2_CUSTOM custom_normal;
 	GRAPH2_CUSTOM custom_dpcm;
+	GRAPH2_CUSTOM custom_c2c;
 };
 
 int audio_graph_parse_of(struct asoc_simple_priv *priv, struct device *dev);
@@ -28,5 +29,7 @@ int audio_graph2_link_normal(struct asoc_simple_priv *priv,
 			     struct device_node *lnk, struct link_info *li);
 int audio_graph2_link_dpcm(struct asoc_simple_priv *priv,
 			   struct device_node *lnk, struct link_info *li);
+int audio_graph2_link_c2c(struct asoc_simple_priv *priv,
+			  struct device_node *lnk, struct link_info *li);
 
 #endif /* __GRAPH_CARD_H */
diff --git a/sound/soc/generic/audio-graph-card2.c b/sound/soc/generic/audio-graph-card2.c
index 56e9e6c3b86e..b6049bcfb771 100644
--- a/sound/soc/generic/audio-graph-card2.c
+++ b/sound/soc/generic/audio-graph-card2.c
@@ -176,17 +176,54 @@ links indicates connection part of CPU side (= A).
 	};
  };
 
+ ************************************
+	Codec to Codec
+ ************************************
+
+ +--+
+ |  |<-- Codec0 <- IN
+ |  |--> Codec1 -> OUT
+ +--+
+
+ sound {
+	compatible = "audio-graph-card2";
+
+	routing = "OUT" ,"DAI1 Playback",
+		  "DAI0 Capture", "IN";
+
+	links = <&c2c>;
+
+	codec2codec {
+		ports {
+			rate = <48000>;
+		c2c:	port@0 { c2cf_ep: endpoint { remote-endpoint = <&codec0_ep>; }; };
+			port@1 { c2cb_ep: endpoint { remote-endpoint = <&codec1_ep>; }; };
+	};
+ };
+
+ Codec {
+	ports {
+		port@0 {
+			bitclock-master;
+			frame-master;
+			 codec0_ep: endpoint { remote-endpoint = <&c2cf_ep>; }; };
+		port@1 { codec1_ep: endpoint { remote-endpoint = <&c2cb_ep>; }; };
+	};
+ };
+
 */
 
 enum graph_type {
 	GRAPH_NORMAL,
 	GRAPH_DPCM,
+	GRAPH_C2C,
 
 	GRAPH_MULTI,	/* don't use ! Use this only in __graph_get_type() */
 };
 
 #define GRAPH_NODENAME_MULTI	"multi"
 #define GRAPH_NODENAME_DPCM	"dpcm"
+#define GRAPH_NODENAME_C2C	"codec2codec"
 
 #define port_to_endpoint(port) of_get_child_by_name(port, "endpoint")
 
@@ -212,6 +249,9 @@ static enum graph_type __graph_get_type(struct device_node *lnk)
 	if (of_node_name_eq(np, GRAPH_NODENAME_DPCM))
 		return GRAPH_DPCM;
 
+	if (of_node_name_eq(np, GRAPH_NODENAME_C2C))
+		return GRAPH_C2C;
+
 	return GRAPH_NORMAL;
 }
 
@@ -236,6 +276,9 @@ static enum graph_type graph_get_type(struct asoc_simple_priv *priv,
 			else
 				str = "DPCM Back-End";
 			break;
+		case GRAPH_C2C:
+			str = "Codec2Codec";
+			break;
 		default:
 			break;
 		}
@@ -494,6 +537,13 @@ static int __graph_parse_node(struct asoc_simple_priv *priv,
 				asoc_simple_set_dailink_name(dev, dai_link, "be.%pOFP.%s%s",
 						codecs->of_node, codecs->dai_name, codec_multi);
 			break;
+		case GRAPH_C2C:
+			/* run is_cpu only. see audio_graph2_link_c2c() */
+			if (is_cpu)
+				asoc_simple_set_dailink_name(dev, dai_link, "c2c.%s%s-%s%s",
+							     cpus->dai_name,   cpu_multi,
+							     codecs->dai_name, codec_multi);
+			break;
 		default:
 			break;
 		}
@@ -792,6 +842,91 @@ int audio_graph2_link_dpcm(struct asoc_simple_priv *priv,
 }
 EXPORT_SYMBOL_GPL(audio_graph2_link_dpcm);
 
+int audio_graph2_link_c2c(struct asoc_simple_priv *priv,
+			  struct device_node *lnk,
+			  struct link_info *li)
+{
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);
+	struct simple_dai_props *dai_props = simple_priv_to_props(priv, li->link);
+	struct snd_soc_pcm_stream *c2c_conf = dai_props->c2c_conf;
+	struct device_node *port0, *port1, *ports;
+	struct device_node *codec0_port, *codec1_port;
+	struct device_node *ep0, *ep1;
+	u32 val;
+	int ret = -EINVAL;
+
+	/*
+	 * codec2codec {
+	 *	ports {
+	 *		rate = <48000>;
+	 * =>	lnk:	port@0 { c2c0_ep: { ... = codec0_ep; }; };
+	 *		port@1 { c2c1_ep: { ... = codec1_ep; }; };
+	 *	};
+	 * };
+	 *
+	 * Codec {
+	 *	ports {
+	 *		port@0 { codec0_ep: ... }; };
+	 *		port@1 { codec1_ep: ... }; };
+	 *	};
+	 * };
+	 */
+	of_node_get(lnk);
+	port0 = lnk;
+	ports = of_get_parent(port0);
+	port1 = of_get_next_child(ports, lnk);
+
+	if (!of_get_property(ports, "rate", &val)) {
+		struct device *dev = simple_priv_to_dev(priv);
+
+		dev_err(dev, "Codec2Codec needs rate settings\n");
+		goto err1;
+	}
+
+	c2c_conf->formats	= SNDRV_PCM_FMTBIT_S32_LE; /* update ME */
+	c2c_conf->rate_min	=
+	c2c_conf->rate_max	= val;
+	c2c_conf->channels_min	=
+	c2c_conf->channels_max	= 2; /* update ME */
+	dai_link->params	= c2c_conf;
+
+	ep0 = port_to_endpoint(port0);
+	ep1 = port_to_endpoint(port1);
+
+	codec0_port = of_graph_get_remote_port(ep0);
+	codec1_port = of_graph_get_remote_port(ep1);
+
+	/*
+	 * call Codec first.
+	 * see
+	 *	__graph_parse_node() :: DAI Naming
+	 */
+	ret = graph_parse_node(priv, GRAPH_C2C, codec1_port, li, 0);
+	if (ret < 0)
+		goto err2;
+
+	/*
+	 * call CPU, and set DAI Name
+	 */
+	ret = graph_parse_node(priv, GRAPH_C2C, codec0_port, li, 1);
+	if (ret < 0)
+		goto err2;
+
+	graph_link_init(priv, codec0_port, li, 1);
+err2:
+	of_node_put(ep0);
+	of_node_put(ep1);
+	of_node_put(codec0_port);
+	of_node_put(codec1_port);
+err1:
+	of_node_put(ports);
+	of_node_put(port0);
+	of_node_put(port1);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(audio_graph2_link_c2c);
+
 static int graph_link(struct asoc_simple_priv *priv,
 		      struct graph2_custom_hooks *hooks,
 		      enum graph_type gtype,
@@ -815,6 +950,12 @@ static int graph_link(struct asoc_simple_priv *priv,
 		else
 			func = audio_graph2_link_dpcm;
 		break;
+	case GRAPH_C2C:
+		if (hooks && hooks->custom_c2c)
+			func = hooks->custom_c2c;
+		else
+			func = audio_graph2_link_c2c;
+		break;
 	default:
 		break;
 	}
@@ -916,6 +1057,43 @@ static int graph_count_dpcm(struct asoc_simple_priv *priv,
 	return 0;
 }
 
+static int graph_count_c2c(struct asoc_simple_priv *priv,
+			   struct device_node *lnk,
+			   struct link_info *li)
+{
+	struct device_node *ports = of_get_parent(lnk);
+	struct device_node *port0 = lnk;
+	struct device_node *port1 = of_get_next_child(ports, lnk);
+	struct device_node *ep0 = port_to_endpoint(port0);
+	struct device_node *ep1 = port_to_endpoint(port1);
+	struct device_node *codec0 = of_graph_get_remote_port(ep0);
+	struct device_node *codec1 = of_graph_get_remote_port(ep1);
+
+	of_node_get(lnk);
+
+	/*
+	 * codec2codec {
+	 *	ports {
+	 * =>	lnk:	port@0 { endpoint { ... }; };
+	 *		port@1 { endpoint { ... }; };
+	 *	};
+	 * };
+	 */
+	li->num[li->link].cpus		=
+	li->num[li->link].platforms	= graph_counter(codec0);
+	li->num[li->link].codecs	= graph_counter(codec1);
+	li->num[li->link].c2c		= 1;
+
+	of_node_put(ports);
+	of_node_put(port1);
+	of_node_put(ep0);
+	of_node_put(ep1);
+	of_node_put(codec0);
+	of_node_put(codec1);
+
+	return 0;
+}
+
 static int graph_count(struct asoc_simple_priv *priv,
 		       struct graph2_custom_hooks *hooks,
 		       enum graph_type gtype,
@@ -938,6 +1116,9 @@ static int graph_count(struct asoc_simple_priv *priv,
 	case GRAPH_DPCM:
 		func = graph_count_dpcm;
 		break;
+	case GRAPH_C2C:
+		func = graph_count_c2c;
+		break;
 	default:
 		break;
 	}
-- 
2.25.1

