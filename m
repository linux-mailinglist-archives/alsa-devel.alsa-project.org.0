Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 9C440284BF1
	for <lists+alsa-devel@lfdr.de>; Tue,  6 Oct 2020 14:46:53 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id 161F21761;
	Tue,  6 Oct 2020 14:46:03 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz 161F21761
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1601988413;
	bh=gOJYgMTmeeqfyZaifMuU2TqB1UE8XNMr6XleEwkfyRU=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=BFwhYk83LLtXgZ1cPzUgvCB4s66nse+2RsoXHwGAMEzV9HriAJlWHtfNg1IcVw8QQ
	 7kHhZbz/+almDDbPr46TfyLWa5+VzEyPuGkRa1gailGnhmlzjEvhR61c8ha5gnk6kQ
	 SATmTbYUDVsL6/OcbHajCTk60ObH4X0rzjpbdpCg=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id A6975F8012A;
	Tue,  6 Oct 2020 14:45:12 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 01E20F8012A; Tue,  6 Oct 2020 14:45:09 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=RCVD_IN_MSPIKE_H3,
 RCVD_IN_MSPIKE_WL,SPF_HELO_NONE,SPF_PASS autolearn=disabled version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 52F5BF80053
 for <alsa-devel@alsa-project.org>; Tue,  6 Oct 2020 14:45:06 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 52F5BF80053
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id 4625EAFAE;
 Tue,  6 Oct 2020 12:45:06 +0000 (UTC)
Date: Tue, 06 Oct 2020 14:45:06 +0200
Message-ID: <s5hh7r75xrh.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: Kai Vehmanen <kai.vehmanen@linux.intel.com>
Subject: Re: [RFC PATCH 0/2] ALSA: hda - acomp probe fix for i915
In-Reply-To: <s5hpn5v5z7v.wl-tiwai@suse.de>
References: <20201006113042.471718-1-kai.vehmanen@linux.intel.com>
 <s5hpn5v5z7v.wl-tiwai@suse.de>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: alsa-devel@alsa-project.org
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Tue, 06 Oct 2020 14:13:40 +0200,
Takashi Iwai wrote:
> 
> On Tue, 06 Oct 2020 13:30:40 +0200,
> Kai Vehmanen wrote:
> > 
> > Hi,
> > 
> > this simple bugfix started to feel a bit like getting stuck in quicksand,
> > so I'm looking for some early input via this RFC series.
> > 
> > Basicly hdac_i915.c should not use global state to track communication
> > with i915 driver. But how to get handle of "hdac_bus*? I considered
> > a few options:
> > 
> >   1) add hdac_bus as a member of drm_audio_component.h
> > 	-> seems wrong as this is really an audio side implementation)
> > 
> >   2) embed copy of drm_audio_component to 'struct hdac_bus', so
> >      I could use container_of() on the device handle to get
> >      to the bus 
> > 	-> wasted space to keep a copy at hdac_bus level
> > 	   (note: snd-hda-codec-hdmi do this by embedding a copy
> > 	    of ops to "struct hdmi_spec")
> > 
> >   3) add another devres entry to store the hdac_bus directly
> >      in acomp_init and a new helper function to query it
> > 
> > I now implemented option 3 in this RFC series as it seemed cleanest
> > and most local to hdac_component.c, where the problem stems from. It's still
> > somewhat messy, and I'm wondering if I'm overlooking some obvious alternative.
> > We could dig this deeper into i915 specific code, but OTOH, hdac_bus is
> > an argument snd_hdac_acomp_init(), so it's common for all.
> > 
> > Kai Vehmanen (2):
> >   ALSA: hda - keep track of HDA core bus instance in acomp
> >   ALSA: hda/i915 - fix list corruption with concurrent probes
> 
> Another option would be to move the completion into the common acomp
> helper from i915-specific one.  That is,
> 
> - Add bind_complete field into struct drm_audio_component,
>   initialize it at snd_hdac_acomp_init()
> 
> - Call complete_all(&acomp->bind_complete) at the end of
>   hdac_component_master_bind()
> 
> - Remove / replace i915's own completion with the hdac's one.
>   The i915_init_ops can be dropped.

So something like below (totally untested).


Takashi

---
--- a/include/drm/drm_audio_component.h
+++ b/include/drm/drm_audio_component.h
@@ -117,6 +117,10 @@ struct drm_audio_component {
 	 * @audio_ops: Ops implemented by hda driver, called by DRM driver
 	 */
 	const struct drm_audio_component_audio_ops *audio_ops;
+	/**
+	 * @master_bind_complete: completion held during component master binding
+	 */
+	struct completion master_bind_complete;
 };
 
 #endif /* _DRM_AUDIO_COMPONENT_H_ */
--- a/sound/hda/hdac_component.c
+++ b/sound/hda/hdac_component.c
@@ -210,12 +210,14 @@ static int hdac_component_master_bind(struct device *dev)
 			goto module_put;
 	}
 
+	complete_all(&acomp->master_bind_complete);
 	return 0;
 
  module_put:
 	module_put(acomp->ops->owner);
 out_unbind:
 	component_unbind_all(dev, acomp);
+	complete_all(&acomp->master_bind_complete);
 
 	return ret;
 }
@@ -296,6 +298,7 @@ int snd_hdac_acomp_init(struct hdac_bus *bus,
 	if (!acomp)
 		return -ENOMEM;
 	acomp->audio_ops = aops;
+	init_completion(&acomp->master_bind_complete);
 	bus->audio_component = acomp;
 	devres_add(dev, acomp);
 
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -11,8 +11,6 @@
 #include <sound/hda_i915.h>
 #include <sound/hda_register.h>
 
-static struct completion bind_complete;
-
 #define IS_HSW_CONTROLLER(pci) (((pci)->device == 0x0a0c) || \
 				((pci)->device == 0x0c0c) || \
 				((pci)->device == 0x0d0c) || \
@@ -130,19 +128,6 @@ static bool i915_gfx_present(void)
 	return pci_dev_present(ids);
 }
 
-static int i915_master_bind(struct device *dev,
-			    struct drm_audio_component *acomp)
-{
-	complete_all(&bind_complete);
-	/* clear audio_ops here as it was needed only for completion call */
-	acomp->audio_ops = NULL;
-	return 0;
-}
-
-static const struct drm_audio_component_audio_ops i915_init_ops = {
-	.master_bind = i915_master_bind
-};
-
 /**
  * snd_hdac_i915_init - Initialize i915 audio component
  * @bus: HDA core bus
@@ -163,9 +148,7 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 	if (!i915_gfx_present())
 		return -ENODEV;
 
-	init_completion(&bind_complete);
-
-	err = snd_hdac_acomp_init(bus, &i915_init_ops,
+	err = snd_hdac_acomp_init(bus, NULL,
 				  i915_component_master_match,
 				  sizeof(struct i915_audio_component) - sizeof(*acomp));
 	if (err < 0)
@@ -177,7 +160,7 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 		if (!IS_ENABLED(CONFIG_MODULES) ||
 		    !request_module("i915")) {
 			/* 60s timeout */
-			wait_for_completion_timeout(&bind_complete,
+			wait_for_completion_timeout(&acomp->master_bind_complete,
 						   msecs_to_jiffies(60 * 1000));
 		}
 	}
