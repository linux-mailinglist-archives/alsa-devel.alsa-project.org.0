Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 51A14197D03
	for <lists+alsa-devel@lfdr.de>; Mon, 30 Mar 2020 15:34:16 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id CA15C1666;
	Mon, 30 Mar 2020 15:33:25 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz CA15C1666
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1585575255;
	bh=/DP6i2HBDez53rAS+KERQf4La9y19hBHy7QJQqMltfo=;
	h=From:To:Subject:Date:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=iJHlAbnVWb8neFAWBU4FN++7W/si3g+76kh+i2BtrgTe1mrWsGOq832cu0gHbqbsy
	 AudWXO3Td+ZR6jrSFjVzDyJf8A5J0SnM9TBq1dWVILW1Tjyur4OTR6PNDZOgIuguRw
	 vWIq8jVn0nEhatRo7sSsGJM7FhqIk0bdM49yyvOA=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id B19FDF80145;
	Mon, 30 Mar 2020 15:32:34 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 1F698F80148; Mon, 30 Mar 2020 15:32:31 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.3 required=5.0 tests=DKIM_SIGNED,DKIM_VALID,
 HEADER_FROM_DIFFERENT_DOMAINS,SPF_HELO_NONE,SPF_NONE,URIBL_BLOCKED
 autolearn=disabled version=3.4.0
Received: from mail-wr1-x444.google.com (mail-wr1-x444.google.com
 [IPv6:2a00:1450:4864:20::444])
 (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 6158AF800EB
 for <alsa-devel@alsa-project.org>; Mon, 30 Mar 2020 15:32:23 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 6158AF800EB
Authentication-Results: alsa1.perex.cz;
 dkim=pass (2048-bit key) header.d=monstr-eu.20150623.gappssmtp.com
 header.i=@monstr-eu.20150623.gappssmtp.com header.b="U1PGkbFt"
Received: by mail-wr1-x444.google.com with SMTP id m11so15756629wrx.10
 for <alsa-devel@alsa-project.org>; Mon, 30 Mar 2020 06:32:23 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=monstr-eu.20150623.gappssmtp.com; s=20150623;
 h=sender:from:to:cc:subject:date:message-id:in-reply-to:references
 :mime-version:content-transfer-encoding;
 bh=ZhdFPV96Myd+UqGbRCA3QiEgqYUqf432L63ZbCp2YbE=;
 b=U1PGkbFtZQ/eJKnmAC84y3ghECeUwFcBtrgSNxzMVEkQJE3JrtdFC7eoQeh5ctTOpa
 4TvKqvwHjKaot0HNmxSE2rOAE5pFV1OO2/7qwNcp/J2SYSlutsML4cvy8V2HemIx3uOt
 urLQbHDdqVwSAUsyCDFm0kzvRXyCtJbT8CTVegFYLL6vfqh6rQK9qcf9SWzBJ98ayUa9
 nPqfFXusPL2hoDsxfC4/4UPfwMHoPmJQ6stU5ku9uY0wJ/MkorAaEOc4qJPG/jZEiPNY
 Dpe5bETnZxEy6H10ni8H3/TpH9MhPAeHX5cNokNiKW/g/kBBXMPH+4uWcgKnHQrX0MvM
 wEJg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=1e100.net; s=20161025;
 h=x-gm-message-state:sender:from:to:cc:subject:date:message-id
 :in-reply-to:references:mime-version:content-transfer-encoding;
 bh=ZhdFPV96Myd+UqGbRCA3QiEgqYUqf432L63ZbCp2YbE=;
 b=MQF0jJ0Jl/0xQ1kolv2qePvvcCTrCiMdV3mCxnlGMrqliCsGO9x4p7VvNw0v2w7m4T
 ICtKcJUDpKvfiZj60DhKKJ45dADkpb/gvKELwsvF+ra3Ox7mTW8M1gHksOmyD7HLijBl
 t6swpoZ2RDfaxTtYQ4DBywp4eB0nSu6LnoQfQvP+9xJTTB4StukPUtXVrEMy3RYFLVJ1
 4pHuIARt37q131IU5QHwwFQScGOxtsITbF6oBvFeJZ38EDqK46NZnNprXpSqXuiHDBpF
 cvvWlK6T3FzjsaGLewEwLBQOOddBn/6SQKNGCYnY/7r5wwUs1M8GbL6XmV6E3YxDnWWC
 XGbg==
X-Gm-Message-State: ANhLgQ0qUQG0lZo0Ju7IZ+YH3sQpb2rkFn7nbOJE86dHhp9xrvqULEig
 jpp9uRR1eHzhB1jEZgZh1zuWuw==
X-Google-Smtp-Source: ADFU+vufD3B7jjY0Pxe5M3lTcOClHCtvnFH3DWQRSRk4he8lw0DK/RXCAvetEcqnL0WSnc42kkzG8Q==
X-Received: by 2002:adf:f589:: with SMTP id f9mr14902008wro.405.1585575141416; 
 Mon, 30 Mar 2020 06:32:21 -0700 (PDT)
Received: from localhost (nat-35.starnet.cz. [178.255.168.35])
 by smtp.gmail.com with ESMTPSA id f12sm18400909wrm.94.2020.03.30.06.32.20
 (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
 Mon, 30 Mar 2020 06:32:20 -0700 (PDT)
From: Michal Simek <michal.simek@xilinx.com>
To: linux-kernel@vger.kernel.org, monstr@monstr.eu, michal.simek@xilinx.com,
 git@xilinx.com, sfr@canb.auug.org.au, maz@kernel.org
Subject: [PATCH v2 1/2] sound: ac97: Remove sound driver for ancient platform
Date: Mon, 30 Mar 2020 15:32:16 +0200
Message-Id: <31a3b884dde2c47a30bb2b92355978b97ea70f86.1585575111.git.michal.simek@xilinx.com>
X-Mailer: git-send-email 2.26.0
In-Reply-To: <cover.1585575111.git.michal.simek@xilinx.com>
References: <cover.1585575111.git.michal.simek@xilinx.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Cc: Kate Stewart <kstewart@linuxfoundation.org>, alsa-devel@alsa-project.org,
 Takashi Iwai <tiwai@suse.de>, Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
 Takashi Iwai <tiwai@suse.com>, Krzysztof Kozlowski <krzk@kernel.org>,
 Richard Fontana <rfontana@redhat.com>, Mark Brown <broonie@kernel.org>,
 Michael Ellerman <mpe@ellerman.id.au>, Thomas Gleixner <tglx@linutronix.de>,
 Allison Randal <allison@lohutok.net>
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

Xilinx PowerPC platforms are no longer supported and none is really testing
these platforms that's why remove them. If someone has any issue with it
these patches can be reverted.

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Acked-by: Takashi Iwai <tiwai@suse.de>
---

Changes in v2:
- Remove also sound/drivers/pcm-indirect2.[ch] files
  Reported-by: Takashi Iwai <tiwai@suse.de>

 sound/drivers/Kconfig         |   12 -
 sound/drivers/Makefile        |    2 -
 sound/drivers/ml403-ac97cr.c  | 1298 ---------------------------------
 sound/drivers/pcm-indirect2.c |  560 --------------
 sound/drivers/pcm-indirect2.h |  127 ----
 5 files changed, 1999 deletions(-)
 delete mode 100644 sound/drivers/ml403-ac97cr.c
 delete mode 100644 sound/drivers/pcm-indirect2.c
 delete mode 100644 sound/drivers/pcm-indirect2.h

diff --git a/sound/drivers/Kconfig b/sound/drivers/Kconfig
index 577c8e03ec4d..7141f73cddd3 100644
--- a/sound/drivers/Kconfig
+++ b/sound/drivers/Kconfig
@@ -186,18 +186,6 @@ config SND_PORTMAN2X4
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-portman2x4.
 
-config SND_ML403_AC97CR
-	tristate "Xilinx ML403 AC97 Controller Reference"
-	depends on XILINX_VIRTEX
-	select SND_AC97_CODEC
-	help
-	  Say Y here to include support for the
-	  opb_ac97_controller_ref_v1_00_a ip core found in Xilinx's ML403
-	  reference design.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called snd-ml403_ac97cr.
-
 config SND_AC97_POWER_SAVE
 	bool "AC97 Power-Saving Mode"
 	depends on SND_AC97_CODEC
diff --git a/sound/drivers/Makefile b/sound/drivers/Makefile
index 615558a281c8..c0fe4eccdaef 100644
--- a/sound/drivers/Makefile
+++ b/sound/drivers/Makefile
@@ -11,7 +11,6 @@ snd-mts64-objs := mts64.o
 snd-portman2x4-objs := portman2x4.o
 snd-serial-u16550-objs := serial-u16550.o
 snd-virmidi-objs := virmidi.o
-snd-ml403-ac97cr-objs := ml403-ac97cr.o pcm-indirect2.o
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_DUMMY) += snd-dummy.o
@@ -21,6 +20,5 @@ obj-$(CONFIG_SND_SERIAL_U16550) += snd-serial-u16550.o
 obj-$(CONFIG_SND_MTPAV) += snd-mtpav.o
 obj-$(CONFIG_SND_MTS64) += snd-mts64.o
 obj-$(CONFIG_SND_PORTMAN2X4) += snd-portman2x4.o
-obj-$(CONFIG_SND_ML403_AC97CR) += snd-ml403-ac97cr.o
 
 obj-$(CONFIG_SND) += opl3/ opl4/ mpu401/ vx/ pcsp/
diff --git a/sound/drivers/ml403-ac97cr.c b/sound/drivers/ml403-ac97cr.c
deleted file mode 100644
index 0710707da8c1..000000000000
--- a/sound/drivers/ml403-ac97cr.c
+++ /dev/null
@@ -1,1298 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * ALSA driver for Xilinx ML403 AC97 Controller Reference
- *   IP: opb_ac97_controller_ref_v1_00_a (EDK 8.1i)
- *   IP: opb_ac97_controller_ref_v1_00_a (EDK 9.1i)
- *
- *  Copyright (c) by 2007  Joachim Foerster <JOFT@gmx.de>
- */
-
-/* Some notes / status of this driver:
- *
- * - Don't wonder about some strange implementations of things - especially the
- * (heavy) shadowing of codec registers, with which I tried to reduce read
- * accesses to a minimum, because after a variable amount of accesses, the AC97
- * controller doesn't raise the register access finished bit anymore ...
- *
- * - Playback support seems to be pretty stable - no issues here.
- * - Capture support "works" now, too. Overruns don't happen any longer so often.
- *   But there might still be some ...
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-
-#include <linux/platform_device.h>
-
-#include <linux/ioport.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-
-/* HZ */
-#include <linux/param.h>
-/* jiffies, time_*() */
-#include <linux/jiffies.h>
-/* schedule_timeout*() */
-#include <linux/sched.h>
-/* spin_lock*() */
-#include <linux/spinlock.h>
-/* struct mutex, mutex_init(), mutex_*lock() */
-#include <linux/mutex.h>
-
-/* snd_printk(), snd_printd() */
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/initval.h>
-#include <sound/ac97_codec.h>
-
-#include "pcm-indirect2.h"
-
-
-#define SND_ML403_AC97CR_DRIVER "ml403-ac97cr"
-
-MODULE_AUTHOR("Joachim Foerster <JOFT@gmx.de>");
-MODULE_DESCRIPTION("Xilinx ML403 AC97 Controller Reference");
-MODULE_LICENSE("GPL");
-MODULE_SUPPORTED_DEVICE("{{Xilinx,ML403 AC97 Controller Reference}}");
-
-static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
-static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
-static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;
-
-module_param_array(index, int, NULL, 0444);
-MODULE_PARM_DESC(index, "Index value for ML403 AC97 Controller Reference.");
-module_param_array(id, charp, NULL, 0444);
-MODULE_PARM_DESC(id, "ID string for ML403 AC97 Controller Reference.");
-module_param_array(enable, bool, NULL, 0444);
-MODULE_PARM_DESC(enable, "Enable this ML403 AC97 Controller Reference.");
-
-/* Special feature options */
-/*#define CODEC_WRITE_CHECK_RAF*/ /* don't return after a write to a codec
-				   * register, while RAF bit is not set
-				   */
-/* Debug options for code which may be removed completely in a final version */
-#ifdef CONFIG_SND_DEBUG
-/*#define CODEC_STAT*/            /* turn on some minimal "statistics"
-				   * about codec register usage
-				   */
-#define SND_PCM_INDIRECT2_STAT    /* turn on some "statistics" about the
-				   * process of copying bytes from the
-				   * intermediate buffer to the hardware
-				   * fifo and the other way round
-				   */
-#endif
-
-/* Definition of a "level/facility dependent" printk(); may be removed
- * completely in a final version
- */
-#undef PDEBUG
-#ifdef CONFIG_SND_DEBUG
-/* "facilities" for PDEBUG */
-#define UNKNOWN       (1<<0)
-#define CODEC_SUCCESS (1<<1)
-#define CODEC_FAKE    (1<<2)
-#define INIT_INFO     (1<<3)
-#define INIT_FAILURE  (1<<4)
-#define WORK_INFO     (1<<5)
-#define WORK_FAILURE  (1<<6)
-
-#define PDEBUG_FACILITIES (UNKNOWN | INIT_FAILURE | WORK_FAILURE)
-
-#define PDEBUG(fac, fmt, args...) do { \
-		if (fac & PDEBUG_FACILITIES) \
-			snd_printd(KERN_DEBUG SND_ML403_AC97CR_DRIVER ": " \
-				   fmt, ##args); \
-	} while (0)
-#else
-#define PDEBUG(fac, fmt, args...) /* nothing */
-#endif
-
-
-
-/* Defines for "waits"/timeouts (portions of HZ=250 on arch/ppc by default) */
-#define CODEC_TIMEOUT_ON_INIT       5	/* timeout for checking for codec
-					 * readiness (after insmod)
-					 */
-#ifndef CODEC_WRITE_CHECK_RAF
-#define CODEC_WAIT_AFTER_WRITE    100	/* general, static wait after a write
-					 * access to a codec register, may be
-					 * 0 to completely remove wait
-					 */
-#else
-#define CODEC_TIMEOUT_AFTER_WRITE   5	/* timeout after a write access to a
-					 * codec register, if RAF bit is used
-					 */
-#endif
-#define CODEC_TIMEOUT_AFTER_READ    5	/* timeout after a read access to a
-					 * codec register (checking RAF bit)
-					 */
-
-/* Infrastructure for codec register shadowing */
-#define LM4550_REG_OK        (1<<0)   /* register exists */
-#define LM4550_REG_DONEREAD  (1<<1)   /* read register once, value should be
-				       * the same currently in the register
-				       */
-#define LM4550_REG_NOSAVE    (1<<2)   /* values written to this register will
-				       * not be saved in the register
-				       */
-#define LM4550_REG_NOSHADOW  (1<<3)   /* don't do register shadowing, use plain
-				       * hardware access
-				       */
-#define LM4550_REG_READONLY  (1<<4)   /* register is read only */
-#define LM4550_REG_FAKEPROBE (1<<5)   /* fake write _and_ read actions during
-				       * probe() correctly
-				       */
-#define LM4550_REG_FAKEREAD  (1<<6)   /* fake read access, always return
-				       * default value
-				       */
-#define LM4550_REG_ALLFAKE   (LM4550_REG_FAKEREAD | LM4550_REG_FAKEPROBE)
-
-struct lm4550_reg {
-	u16 value;
-	u16 flag;
-	u16 wmask;
-	u16 def;
-};
-
-struct lm4550_reg lm4550_regfile[64] = {
-	[AC97_RESET / 2]              = {.flag = LM4550_REG_OK \
-						| LM4550_REG_NOSAVE \
-						| LM4550_REG_FAKEREAD,
-					 .def = 0x0D50},
-	[AC97_MASTER / 2]             = {.flag = LM4550_REG_OK
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x9F1F,
-					 .def = 0x8000},
-	[AC97_HEADPHONE / 2]          = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x9F1F,
-					 .def = 0x8000},
-	[AC97_MASTER_MONO / 2]        = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x801F,
-					 .def = 0x8000},
-	[AC97_PC_BEEP / 2]            = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x801E,
-					 .def = 0x0},
-	[AC97_PHONE / 2]              = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x801F,
-					 .def = 0x8008},
-	[AC97_MIC / 2]                = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x805F,
-					 .def = 0x8008},
-	[AC97_LINE / 2]               = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x9F1F,
-					 .def = 0x8808},
-	[AC97_CD / 2]                 = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x9F1F,
-					 .def = 0x8808},
-	[AC97_VIDEO / 2]              = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x9F1F,
-					 .def = 0x8808},
-	[AC97_AUX / 2]                = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x9F1F,
-					 .def = 0x8808},
-	[AC97_PCM / 2]                = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x9F1F,
-					 .def = 0x8008},
-	[AC97_REC_SEL / 2]            = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x707,
-					 .def = 0x0},
-	[AC97_REC_GAIN / 2]           = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .wmask = 0x8F0F,
-					 .def = 0x8000},
-	[AC97_GENERAL_PURPOSE / 2]    = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .def = 0x0,
-					 .wmask = 0xA380},
-	[AC97_3D_CONTROL / 2]         = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEREAD \
-						| LM4550_REG_READONLY,
-					 .def = 0x0101},
-	[AC97_POWERDOWN / 2]          = {.flag = LM4550_REG_OK \
-						| LM4550_REG_NOSHADOW \
-						| LM4550_REG_NOSAVE,
-					 .wmask = 0xFF00},
-					/* may not write ones to
-					 * REF/ANL/DAC/ADC bits
-					 * FIXME: Is this ok?
-					 */
-	[AC97_EXTENDED_ID / 2]        = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEREAD \
-						| LM4550_REG_READONLY,
-					 .def = 0x0201}, /* primary codec */
-	[AC97_EXTENDED_STATUS / 2]    = {.flag = LM4550_REG_OK \
-						| LM4550_REG_NOSHADOW \
-						| LM4550_REG_NOSAVE,
-					 .wmask = 0x1},
-	[AC97_PCM_FRONT_DAC_RATE / 2] = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .def = 0xBB80,
-					 .wmask = 0xFFFF},
-	[AC97_PCM_LR_ADC_RATE / 2]    = {.flag = LM4550_REG_OK \
-						| LM4550_REG_FAKEPROBE,
-					 .def = 0xBB80,
-					 .wmask = 0xFFFF},
-	[AC97_VENDOR_ID1 / 2]         = {.flag = LM4550_REG_OK \
-						| LM4550_REG_READONLY \
-						| LM4550_REG_FAKEREAD,
-					 .def = 0x4E53},
-	[AC97_VENDOR_ID2 / 2]         = {.flag = LM4550_REG_OK \
-						| LM4550_REG_READONLY \
-						| LM4550_REG_FAKEREAD,
-					 .def = 0x4350}
-};
-
-#define LM4550_RF_OK(reg)    (lm4550_regfile[reg / 2].flag & LM4550_REG_OK)
-
-static void lm4550_regfile_init(void)
-{
-	int i;
-	for (i = 0; i < 64; i++)
-		if (lm4550_regfile[i].flag & LM4550_REG_FAKEPROBE)
-			lm4550_regfile[i].value = lm4550_regfile[i].def;
-}
-
-static void lm4550_regfile_write_values_after_init(struct snd_ac97 *ac97)
-{
-	int i;
-	for (i = 0; i < 64; i++)
-		if ((lm4550_regfile[i].flag & LM4550_REG_FAKEPROBE) &&
-		    (lm4550_regfile[i].value != lm4550_regfile[i].def)) {
-			PDEBUG(CODEC_FAKE, "lm4550_regfile_write_values_after_"
-			       "init(): reg=0x%x value=0x%x / %d is different "
-			       "from def=0x%x / %d\n",
-			       i, lm4550_regfile[i].value,
-			       lm4550_regfile[i].value, lm4550_regfile[i].def,
-			       lm4550_regfile[i].def);
-			snd_ac97_write(ac97, i * 2, lm4550_regfile[i].value);
-			lm4550_regfile[i].flag |= LM4550_REG_DONEREAD;
-		}
-}
-
-
-/* direct registers */
-#define CR_REG(ml403_ac97cr, x) ((ml403_ac97cr)->port + CR_REG_##x)
-
-#define CR_REG_PLAYFIFO         0x00
-#define   CR_PLAYDATA(a)        ((a) & 0xFFFF)
-
-#define CR_REG_RECFIFO          0x04
-#define   CR_RECDATA(a)         ((a) & 0xFFFF)
-
-#define CR_REG_STATUS           0x08
-#define   CR_RECOVER            (1<<7)
-#define   CR_PLAYUNDER          (1<<6)
-#define   CR_CODECREADY         (1<<5)
-#define   CR_RAF                (1<<4)
-#define   CR_RECEMPTY           (1<<3)
-#define   CR_RECFULL            (1<<2)
-#define   CR_PLAYHALF           (1<<1)
-#define   CR_PLAYFULL           (1<<0)
-
-#define CR_REG_RESETFIFO        0x0C
-#define   CR_RECRESET           (1<<1)
-#define   CR_PLAYRESET          (1<<0)
-
-#define CR_REG_CODEC_ADDR       0x10
-/* UG082 says:
- * #define   CR_CODEC_ADDR(a)  ((a) << 1)
- * #define   CR_CODEC_READ     (1<<0)
- * #define   CR_CODEC_WRITE    (0<<0)
- */
-/* RefDesign example says: */
-#define   CR_CODEC_ADDR(a)      ((a) << 0)
-#define   CR_CODEC_READ         (1<<7)
-#define   CR_CODEC_WRITE        (0<<7)
-
-#define CR_REG_CODEC_DATAREAD   0x14
-#define   CR_CODEC_DATAREAD(v)  ((v) & 0xFFFF)
-
-#define CR_REG_CODEC_DATAWRITE  0x18
-#define   CR_CODEC_DATAWRITE(v) ((v) & 0xFFFF)
-
-#define CR_FIFO_SIZE            32
-
-struct snd_ml403_ac97cr {
-	/* lock for access to (controller) registers */
-	spinlock_t reg_lock;
-	/* mutex for the whole sequence of accesses to (controller) registers
-	 * which affect codec registers
-	 */
-	struct mutex cdc_mutex;
-
-	int irq; /* for playback */
-	int enable_irq;	/* for playback */
-
-	int capture_irq;
-	int enable_capture_irq;
-
-	struct resource *res_port;
-	void *port;
-
-	struct snd_ac97 *ac97;
-	int ac97_fake;
-#ifdef CODEC_STAT
-	int ac97_read;
-	int ac97_write;
-#endif
-
-	struct platform_device *pfdev;
-	struct snd_card *card;
-	struct snd_pcm *pcm;
-	struct snd_pcm_substream *playback_substream;
-	struct snd_pcm_substream *capture_substream;
-
-	struct snd_pcm_indirect2 ind_rec; /* for playback */
-	struct snd_pcm_indirect2 capture_ind2_rec;
-};
-
-static const struct snd_pcm_hardware snd_ml403_ac97cr_playback = {
-	.info =	            (SNDRV_PCM_INFO_MMAP |
-			     SNDRV_PCM_INFO_INTERLEAVED |
-			     SNDRV_PCM_INFO_MMAP_VALID),
-	.formats =          SNDRV_PCM_FMTBIT_S16_BE,
-	.rates =	    (SNDRV_PCM_RATE_CONTINUOUS |
-			     SNDRV_PCM_RATE_8000_48000),
-	.rate_min =	    4000,
-	.rate_max =	    48000,
-	.channels_min =     2,
-	.channels_max =     2,
-	.buffer_bytes_max = (128*1024),
-	.period_bytes_min = CR_FIFO_SIZE/2,
-	.period_bytes_max = (64*1024),
-	.periods_min =      2,
-	.periods_max =      (128*1024)/(CR_FIFO_SIZE/2),
-	.fifo_size =	    0,
-};
-
-static const struct snd_pcm_hardware snd_ml403_ac97cr_capture = {
-	.info =	            (SNDRV_PCM_INFO_MMAP |
-			     SNDRV_PCM_INFO_INTERLEAVED |
-			     SNDRV_PCM_INFO_MMAP_VALID),
-	.formats =          SNDRV_PCM_FMTBIT_S16_BE,
-	.rates =            (SNDRV_PCM_RATE_CONTINUOUS |
-			     SNDRV_PCM_RATE_8000_48000),
-	.rate_min =         4000,
-	.rate_max =         48000,
-	.channels_min =     2,
-	.channels_max =     2,
-	.buffer_bytes_max = (128*1024),
-	.period_bytes_min = CR_FIFO_SIZE/2,
-	.period_bytes_max = (64*1024),
-	.periods_min =      2,
-	.periods_max =      (128*1024)/(CR_FIFO_SIZE/2),
-	.fifo_size =	    0,
-};
-
-static size_t
-snd_ml403_ac97cr_playback_ind2_zero(struct snd_pcm_substream *substream,
-				    struct snd_pcm_indirect2 *rec)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	int copied_words = 0;
-	u32 full = 0;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-
-	spin_lock(&ml403_ac97cr->reg_lock);
-	while ((full = (in_be32(CR_REG(ml403_ac97cr, STATUS)) &
-			CR_PLAYFULL)) != CR_PLAYFULL) {
-		out_be32(CR_REG(ml403_ac97cr, PLAYFIFO), 0);
-		copied_words++;
-	}
-	rec->hw_ready = 0;
-	spin_unlock(&ml403_ac97cr->reg_lock);
-
-	return (size_t) (copied_words * 2);
-}
-
-static size_t
-snd_ml403_ac97cr_playback_ind2_copy(struct snd_pcm_substream *substream,
-				    struct snd_pcm_indirect2 *rec,
-				    size_t bytes)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	u16 *src;
-	int copied_words = 0;
-	u32 full = 0;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-	src = (u16 *)(substream->runtime->dma_area + rec->sw_data);
-
-	spin_lock(&ml403_ac97cr->reg_lock);
-	while (((full = (in_be32(CR_REG(ml403_ac97cr, STATUS)) &
-			 CR_PLAYFULL)) != CR_PLAYFULL) && (bytes > 1)) {
-		out_be32(CR_REG(ml403_ac97cr, PLAYFIFO),
-			 CR_PLAYDATA(src[copied_words]));
-		copied_words++;
-		bytes = bytes - 2;
-	}
-	if (full != CR_PLAYFULL)
-		rec->hw_ready = 1;
-	else
-		rec->hw_ready = 0;
-	spin_unlock(&ml403_ac97cr->reg_lock);
-
-	return (size_t) (copied_words * 2);
-}
-
-static size_t
-snd_ml403_ac97cr_capture_ind2_null(struct snd_pcm_substream *substream,
-				   struct snd_pcm_indirect2 *rec)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	int copied_words = 0;
-	u32 empty = 0;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-
-	spin_lock(&ml403_ac97cr->reg_lock);
-	while ((empty = (in_be32(CR_REG(ml403_ac97cr, STATUS)) &
-			 CR_RECEMPTY)) != CR_RECEMPTY) {
-		volatile u32 trash;
-
-		trash = CR_RECDATA(in_be32(CR_REG(ml403_ac97cr, RECFIFO)));
-		/* Hmmmm, really necessary? Don't want call to in_be32()
-		 * to be optimised away!
-		 */
-		trash++;
-		copied_words++;
-	}
-	rec->hw_ready = 0;
-	spin_unlock(&ml403_ac97cr->reg_lock);
-
-	return (size_t) (copied_words * 2);
-}
-
-static size_t
-snd_ml403_ac97cr_capture_ind2_copy(struct snd_pcm_substream *substream,
-				   struct snd_pcm_indirect2 *rec, size_t bytes)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	u16 *dst;
-	int copied_words = 0;
-	u32 empty = 0;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-	dst = (u16 *)(substream->runtime->dma_area + rec->sw_data);
-
-	spin_lock(&ml403_ac97cr->reg_lock);
-	while (((empty = (in_be32(CR_REG(ml403_ac97cr, STATUS)) &
-			  CR_RECEMPTY)) != CR_RECEMPTY) && (bytes > 1)) {
-		dst[copied_words] = CR_RECDATA(in_be32(CR_REG(ml403_ac97cr,
-							      RECFIFO)));
-		copied_words++;
-		bytes = bytes - 2;
-	}
-	if (empty != CR_RECEMPTY)
-		rec->hw_ready = 1;
-	else
-		rec->hw_ready = 0;
-	spin_unlock(&ml403_ac97cr->reg_lock);
-
-	return (size_t) (copied_words * 2);
-}
-
-static snd_pcm_uframes_t
-snd_ml403_ac97cr_pcm_pointer(struct snd_pcm_substream *substream)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	struct snd_pcm_indirect2 *ind2_rec = NULL;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-
-	if (substream == ml403_ac97cr->playback_substream)
-		ind2_rec = &ml403_ac97cr->ind_rec;
-	if (substream == ml403_ac97cr->capture_substream)
-		ind2_rec = &ml403_ac97cr->capture_ind2_rec;
-
-	if (ind2_rec != NULL)
-		return snd_pcm_indirect2_pointer(substream, ind2_rec);
-	return (snd_pcm_uframes_t) 0;
-}
-
-static int
-snd_ml403_ac97cr_pcm_playback_trigger(struct snd_pcm_substream *substream,
-				      int cmd)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	int err = 0;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		PDEBUG(WORK_INFO, "trigger(playback): START\n");
-		ml403_ac97cr->ind_rec.hw_ready = 1;
-
-		/* clear play FIFO */
-		out_be32(CR_REG(ml403_ac97cr, RESETFIFO), CR_PLAYRESET);
-
-		/* enable play irq */
-		ml403_ac97cr->enable_irq = 1;
-		enable_irq(ml403_ac97cr->irq);
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		PDEBUG(WORK_INFO, "trigger(playback): STOP\n");
-		ml403_ac97cr->ind_rec.hw_ready = 0;
-#ifdef SND_PCM_INDIRECT2_STAT
-		snd_pcm_indirect2_stat(substream, &ml403_ac97cr->ind_rec);
-#endif
-		/* disable play irq */
-		disable_irq_nosync(ml403_ac97cr->irq);
-		ml403_ac97cr->enable_irq = 0;
-		break;
-	default:
-		err = -EINVAL;
-		break;
-	}
-	PDEBUG(WORK_INFO, "trigger(playback): (done)\n");
-	return err;
-}
-
-static int
-snd_ml403_ac97cr_pcm_capture_trigger(struct snd_pcm_substream *substream,
-				      int cmd)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	int err = 0;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		PDEBUG(WORK_INFO, "trigger(capture): START\n");
-		ml403_ac97cr->capture_ind2_rec.hw_ready = 0;
-
-		/* clear record FIFO */
-		out_be32(CR_REG(ml403_ac97cr, RESETFIFO), CR_RECRESET);
-
-		/* enable record irq */
-		ml403_ac97cr->enable_capture_irq = 1;
-		enable_irq(ml403_ac97cr->capture_irq);
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		PDEBUG(WORK_INFO, "trigger(capture): STOP\n");
-		ml403_ac97cr->capture_ind2_rec.hw_ready = 0;
-#ifdef SND_PCM_INDIRECT2_STAT
-		snd_pcm_indirect2_stat(substream,
-				       &ml403_ac97cr->capture_ind2_rec);
-#endif
-		/* disable capture irq */
-		disable_irq_nosync(ml403_ac97cr->capture_irq);
-		ml403_ac97cr->enable_capture_irq = 0;
-		break;
-	default:
-		err = -EINVAL;
-		break;
-	}
-	PDEBUG(WORK_INFO, "trigger(capture): (done)\n");
-	return err;
-}
-
-static int
-snd_ml403_ac97cr_pcm_playback_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	struct snd_pcm_runtime *runtime;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-	runtime = substream->runtime;
-
-	PDEBUG(WORK_INFO,
-	       "prepare(): period_bytes=%d, minperiod_bytes=%d\n",
-	       snd_pcm_lib_period_bytes(substream), CR_FIFO_SIZE / 2);
-
-	/* set sampling rate */
-	snd_ac97_set_rate(ml403_ac97cr->ac97, AC97_PCM_FRONT_DAC_RATE,
-			  runtime->rate);
-	PDEBUG(WORK_INFO, "prepare(): rate=%d\n", runtime->rate);
-
-	/* init struct for intermediate buffer */
-	memset(&ml403_ac97cr->ind_rec, 0,
-	       sizeof(struct snd_pcm_indirect2));
-	ml403_ac97cr->ind_rec.hw_buffer_size = CR_FIFO_SIZE;
-	ml403_ac97cr->ind_rec.sw_buffer_size =
-		snd_pcm_lib_buffer_bytes(substream);
-	ml403_ac97cr->ind_rec.min_periods = -1;
-	ml403_ac97cr->ind_rec.min_multiple =
-		snd_pcm_lib_period_bytes(substream) / (CR_FIFO_SIZE / 2);
-	PDEBUG(WORK_INFO, "prepare(): hw_buffer_size=%d, "
-	       "sw_buffer_size=%d, min_multiple=%d\n",
-	       CR_FIFO_SIZE, ml403_ac97cr->ind_rec.sw_buffer_size,
-	       ml403_ac97cr->ind_rec.min_multiple);
-	return 0;
-}
-
-static int
-snd_ml403_ac97cr_pcm_capture_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	struct snd_pcm_runtime *runtime;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-	runtime = substream->runtime;
-
-	PDEBUG(WORK_INFO,
-	       "prepare(capture): period_bytes=%d, minperiod_bytes=%d\n",
-	       snd_pcm_lib_period_bytes(substream), CR_FIFO_SIZE / 2);
-
-	/* set sampling rate */
-	snd_ac97_set_rate(ml403_ac97cr->ac97, AC97_PCM_LR_ADC_RATE,
-			  runtime->rate);
-	PDEBUG(WORK_INFO, "prepare(capture): rate=%d\n", runtime->rate);
-
-	/* init struct for intermediate buffer */
-	memset(&ml403_ac97cr->capture_ind2_rec, 0,
-	       sizeof(struct snd_pcm_indirect2));
-	ml403_ac97cr->capture_ind2_rec.hw_buffer_size = CR_FIFO_SIZE;
-	ml403_ac97cr->capture_ind2_rec.sw_buffer_size =
-		snd_pcm_lib_buffer_bytes(substream);
-	ml403_ac97cr->capture_ind2_rec.min_multiple =
-		snd_pcm_lib_period_bytes(substream) / (CR_FIFO_SIZE / 2);
-	PDEBUG(WORK_INFO, "prepare(capture): hw_buffer_size=%d, "
-	       "sw_buffer_size=%d, min_multiple=%d\n", CR_FIFO_SIZE,
-	       ml403_ac97cr->capture_ind2_rec.sw_buffer_size,
-	       ml403_ac97cr->capture_ind2_rec.min_multiple);
-	return 0;
-}
-
-static int snd_ml403_ac97cr_playback_open(struct snd_pcm_substream *substream)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	struct snd_pcm_runtime *runtime;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-	runtime = substream->runtime;
-
-	PDEBUG(WORK_INFO, "open(playback)\n");
-	ml403_ac97cr->playback_substream = substream;
-	runtime->hw = snd_ml403_ac97cr_playback;
-
-	snd_pcm_hw_constraint_step(runtime, 0,
-				   SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
-				   CR_FIFO_SIZE / 2);
-	return 0;
-}
-
-static int snd_ml403_ac97cr_capture_open(struct snd_pcm_substream *substream)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	struct snd_pcm_runtime *runtime;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-	runtime = substream->runtime;
-
-	PDEBUG(WORK_INFO, "open(capture)\n");
-	ml403_ac97cr->capture_substream = substream;
-	runtime->hw = snd_ml403_ac97cr_capture;
-
-	snd_pcm_hw_constraint_step(runtime, 0,
-				   SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
-				   CR_FIFO_SIZE / 2);
-	return 0;
-}
-
-static int snd_ml403_ac97cr_playback_close(struct snd_pcm_substream *substream)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-
-	PDEBUG(WORK_INFO, "close(playback)\n");
-	ml403_ac97cr->playback_substream = NULL;
-	return 0;
-}
-
-static int snd_ml403_ac97cr_capture_close(struct snd_pcm_substream *substream)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-
-	ml403_ac97cr = snd_pcm_substream_chip(substream);
-
-	PDEBUG(WORK_INFO, "close(capture)\n");
-	ml403_ac97cr->capture_substream = NULL;
-	return 0;
-}
-
-static const struct snd_pcm_ops snd_ml403_ac97cr_playback_ops = {
-	.open = snd_ml403_ac97cr_playback_open,
-	.close = snd_ml403_ac97cr_playback_close,
-	.prepare = snd_ml403_ac97cr_pcm_playback_prepare,
-	.trigger = snd_ml403_ac97cr_pcm_playback_trigger,
-	.pointer = snd_ml403_ac97cr_pcm_pointer,
-};
-
-static const struct snd_pcm_ops snd_ml403_ac97cr_capture_ops = {
-	.open = snd_ml403_ac97cr_capture_open,
-	.close = snd_ml403_ac97cr_capture_close,
-	.prepare = snd_ml403_ac97cr_pcm_capture_prepare,
-	.trigger = snd_ml403_ac97cr_pcm_capture_trigger,
-	.pointer = snd_ml403_ac97cr_pcm_pointer,
-};
-
-static irqreturn_t snd_ml403_ac97cr_irq(int irq, void *dev_id)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	struct platform_device *pfdev;
-	int cmp_irq;
-
-	ml403_ac97cr = (struct snd_ml403_ac97cr *)dev_id;
-	if (ml403_ac97cr == NULL)
-		return IRQ_NONE;
-
-	pfdev = ml403_ac97cr->pfdev;
-
-	/* playback interrupt */
-	cmp_irq = platform_get_irq(pfdev, 0);
-	if (irq == cmp_irq) {
-		if (ml403_ac97cr->enable_irq)
-			snd_pcm_indirect2_playback_interrupt(
-				ml403_ac97cr->playback_substream,
-				&ml403_ac97cr->ind_rec,
-				snd_ml403_ac97cr_playback_ind2_copy,
-				snd_ml403_ac97cr_playback_ind2_zero);
-		else
-			goto __disable_irq;
-	} else {
-		/* record interrupt */
-		cmp_irq = platform_get_irq(pfdev, 1);
-		if (irq == cmp_irq) {
-			if (ml403_ac97cr->enable_capture_irq)
-				snd_pcm_indirect2_capture_interrupt(
-					ml403_ac97cr->capture_substream,
-					&ml403_ac97cr->capture_ind2_rec,
-					snd_ml403_ac97cr_capture_ind2_copy,
-					snd_ml403_ac97cr_capture_ind2_null);
-			else
-				goto __disable_irq;
-		} else
-			return IRQ_NONE;
-	}
-	return IRQ_HANDLED;
-
-__disable_irq:
-	PDEBUG(INIT_INFO, "irq(): irq %d is meant to be disabled! So, now try "
-	       "to disable it _really_!\n", irq);
-	disable_irq_nosync(irq);
-	return IRQ_HANDLED;
-}
-
-static unsigned short
-snd_ml403_ac97cr_codec_read(struct snd_ac97 *ac97, unsigned short reg)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr = ac97->private_data;
-#ifdef CODEC_STAT
-	u32 stat;
-	u32 rafaccess = 0;
-#endif
-	unsigned long end_time;
-	u16 value = 0;
-
-	if (!LM4550_RF_OK(reg)) {
-		snd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "
-			   "access to unknown/unused codec register 0x%x "
-			   "ignored!\n", reg);
-		return 0;
-	}
-	/* check if we can fake/answer this access from our shadow register */
-	if ((lm4550_regfile[reg / 2].flag &
-	     (LM4550_REG_DONEREAD | LM4550_REG_ALLFAKE)) &&
-	    !(lm4550_regfile[reg / 2].flag & LM4550_REG_NOSHADOW)) {
-		if (lm4550_regfile[reg / 2].flag & LM4550_REG_FAKEREAD) {
-			PDEBUG(CODEC_FAKE, "codec_read(): faking read from "
-			       "reg=0x%x, val=0x%x / %d\n",
-			       reg, lm4550_regfile[reg / 2].def,
-			       lm4550_regfile[reg / 2].def);
-			return lm4550_regfile[reg / 2].def;
-		} else if ((lm4550_regfile[reg / 2].flag &
-			    LM4550_REG_FAKEPROBE) &&
-			   ml403_ac97cr->ac97_fake) {
-			PDEBUG(CODEC_FAKE, "codec_read(): faking read from "
-			       "reg=0x%x, val=0x%x / %d (probe)\n",
-			       reg, lm4550_regfile[reg / 2].value,
-			       lm4550_regfile[reg / 2].value);
-			return lm4550_regfile[reg / 2].value;
-		} else {
-#ifdef CODEC_STAT
-			PDEBUG(CODEC_FAKE, "codec_read(): read access "
-			       "answered by shadow register 0x%x (value=0x%x "
-			       "/ %d) (cw=%d cr=%d)\n",
-			       reg, lm4550_regfile[reg / 2].value,
-			       lm4550_regfile[reg / 2].value,
-			       ml403_ac97cr->ac97_write,
-			       ml403_ac97cr->ac97_read);
-#else
-			PDEBUG(CODEC_FAKE, "codec_read(): read access "
-			       "answered by shadow register 0x%x (value=0x%x "
-			       "/ %d)\n",
-			       reg, lm4550_regfile[reg / 2].value,
-			       lm4550_regfile[reg / 2].value);
-#endif
-			return lm4550_regfile[reg / 2].value;
-		}
-	}
-	/* if we are here, we _have_ to access the codec really, no faking */
-	if (mutex_lock_interruptible(&ml403_ac97cr->cdc_mutex) != 0)
-		return 0;
-#ifdef CODEC_STAT
-	ml403_ac97cr->ac97_read++;
-#endif
-	spin_lock(&ml403_ac97cr->reg_lock);
-	out_be32(CR_REG(ml403_ac97cr, CODEC_ADDR),
-		 CR_CODEC_ADDR(reg) | CR_CODEC_READ);
-	spin_unlock(&ml403_ac97cr->reg_lock);
-	end_time = jiffies + (HZ / CODEC_TIMEOUT_AFTER_READ);
-	do {
-		spin_lock(&ml403_ac97cr->reg_lock);
-#ifdef CODEC_STAT
-		rafaccess++;
-		stat = in_be32(CR_REG(ml403_ac97cr, STATUS));
-		if ((stat & CR_RAF) == CR_RAF) {
-			value = CR_CODEC_DATAREAD(
-				in_be32(CR_REG(ml403_ac97cr, CODEC_DATAREAD)));
-			PDEBUG(CODEC_SUCCESS, "codec_read(): (done) reg=0x%x, "
-			       "value=0x%x / %d (STATUS=0x%x)\n",
-			       reg, value, value, stat);
-#else
-		if ((in_be32(CR_REG(ml403_ac97cr, STATUS)) &
-		     CR_RAF) == CR_RAF) {
-			value = CR_CODEC_DATAREAD(
-				in_be32(CR_REG(ml403_ac97cr, CODEC_DATAREAD)));
-			PDEBUG(CODEC_SUCCESS, "codec_read(): (done) "
-			       "reg=0x%x, value=0x%x / %d\n",
-			       reg, value, value);
-#endif
-			lm4550_regfile[reg / 2].value = value;
-			lm4550_regfile[reg / 2].flag |= LM4550_REG_DONEREAD;
-			spin_unlock(&ml403_ac97cr->reg_lock);
-			mutex_unlock(&ml403_ac97cr->cdc_mutex);
-			return value;
-		}
-		spin_unlock(&ml403_ac97cr->reg_lock);
-		schedule_timeout_uninterruptible(1);
-	} while (time_after(end_time, jiffies));
-	/* read the DATAREAD register anyway, see comment below */
-	spin_lock(&ml403_ac97cr->reg_lock);
-	value =
-	    CR_CODEC_DATAREAD(in_be32(CR_REG(ml403_ac97cr, CODEC_DATAREAD)));
-	spin_unlock(&ml403_ac97cr->reg_lock);
-#ifdef CODEC_STAT
-	snd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "
-		   "timeout while codec read! "
-		   "(reg=0x%x, last STATUS=0x%x, DATAREAD=0x%x / %d, %d) "
-		   "(cw=%d, cr=%d)\n",
-		   reg, stat, value, value, rafaccess,
-		   ml403_ac97cr->ac97_write, ml403_ac97cr->ac97_read);
-#else
-	snd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "
-		   "timeout while codec read! "
-		   "(reg=0x%x, DATAREAD=0x%x / %d)\n",
-		   reg, value, value);
-#endif
-	/* BUG: This is PURE speculation! But after _most_ read timeouts the
-	 * value in the register is ok!
-	 */
-	lm4550_regfile[reg / 2].value = value;
-	lm4550_regfile[reg / 2].flag |= LM4550_REG_DONEREAD;
-	mutex_unlock(&ml403_ac97cr->cdc_mutex);
-	return value;
-}
-
-static void
-snd_ml403_ac97cr_codec_write(struct snd_ac97 *ac97, unsigned short reg,
-			     unsigned short val)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr = ac97->private_data;
-
-#ifdef CODEC_STAT
-	u32 stat;
-	u32 rafaccess = 0;
-#endif
-#ifdef CODEC_WRITE_CHECK_RAF
-	unsigned long end_time;
-#endif
-
-	if (!LM4550_RF_OK(reg)) {
-		snd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "
-			   "access to unknown/unused codec register 0x%x "
-			   "ignored!\n", reg);
-		return;
-	}
-	if (lm4550_regfile[reg / 2].flag & LM4550_REG_READONLY) {
-		snd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "
-			   "write access to read only codec register 0x%x "
-			   "ignored!\n", reg);
-		return;
-	}
-	if ((val & lm4550_regfile[reg / 2].wmask) != val) {
-		snd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "
-			   "write access to codec register 0x%x "
-			   "with bad value 0x%x / %d!\n",
-			   reg, val, val);
-		val = val & lm4550_regfile[reg / 2].wmask;
-	}
-	if (((lm4550_regfile[reg / 2].flag & LM4550_REG_FAKEPROBE) &&
-	     ml403_ac97cr->ac97_fake) &&
-	    !(lm4550_regfile[reg / 2].flag & LM4550_REG_NOSHADOW)) {
-		PDEBUG(CODEC_FAKE, "codec_write(): faking write to reg=0x%x, "
-		       "val=0x%x / %d\n", reg, val, val);
-		lm4550_regfile[reg / 2].value = (val &
-						lm4550_regfile[reg / 2].wmask);
-		return;
-	}
-	if (mutex_lock_interruptible(&ml403_ac97cr->cdc_mutex) != 0)
-		return;
-#ifdef CODEC_STAT
-	ml403_ac97cr->ac97_write++;
-#endif
-	spin_lock(&ml403_ac97cr->reg_lock);
-	out_be32(CR_REG(ml403_ac97cr, CODEC_DATAWRITE),
-		 CR_CODEC_DATAWRITE(val));
-	out_be32(CR_REG(ml403_ac97cr, CODEC_ADDR),
-		 CR_CODEC_ADDR(reg) | CR_CODEC_WRITE);
-	spin_unlock(&ml403_ac97cr->reg_lock);
-#ifdef CODEC_WRITE_CHECK_RAF
-	/* check CR_CODEC_RAF bit to see if write access to register is done;
-	 * loop until bit is set or timeout happens
-	 */
-	end_time = jiffies + HZ / CODEC_TIMEOUT_AFTER_WRITE;
-	do {
-		spin_lock(&ml403_ac97cr->reg_lock);
-#ifdef CODEC_STAT
-		rafaccess++;
-		stat = in_be32(CR_REG(ml403_ac97cr, STATUS))
-		if ((stat & CR_RAF) == CR_RAF) {
-#else
-		if ((in_be32(CR_REG(ml403_ac97cr, STATUS)) &
-		     CR_RAF) == CR_RAF) {
-#endif
-			PDEBUG(CODEC_SUCCESS, "codec_write(): (done) "
-			       "reg=0x%x, value=%d / 0x%x\n",
-			       reg, val, val);
-			if (!(lm4550_regfile[reg / 2].flag &
-			      LM4550_REG_NOSHADOW) &&
-			    !(lm4550_regfile[reg / 2].flag &
-			      LM4550_REG_NOSAVE))
-				lm4550_regfile[reg / 2].value = val;
-			lm4550_regfile[reg / 2].flag |= LM4550_REG_DONEREAD;
-			spin_unlock(&ml403_ac97cr->reg_lock);
-			mutex_unlock(&ml403_ac97cr->cdc_mutex);
-			return;
-		}
-		spin_unlock(&ml403_ac97cr->reg_lock);
-		schedule_timeout_uninterruptible(1);
-	} while (time_after(end_time, jiffies));
-#ifdef CODEC_STAT
-	snd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "
-		   "timeout while codec write "
-		   "(reg=0x%x, val=0x%x / %d, last STATUS=0x%x, %d) "
-		   "(cw=%d, cr=%d)\n",
-		   reg, val, val, stat, rafaccess, ml403_ac97cr->ac97_write,
-		   ml403_ac97cr->ac97_read);
-#else
-	snd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "
-		   "timeout while codec write (reg=0x%x, val=0x%x / %d)\n",
-		   reg, val, val);
-#endif
-#else /* CODEC_WRITE_CHECK_RAF */
-#if CODEC_WAIT_AFTER_WRITE > 0
-	/* officially, in AC97 spec there is no possibility for a AC97
-	 * controller to determine, if write access is done or not - so: How
-	 * is Xilinx able to provide a RAF bit for write access?
-	 * => very strange, thus just don't check RAF bit (compare with
-	 * Xilinx's example app in EDK 8.1i) and wait
-	 */
-	schedule_timeout_uninterruptible(HZ / CODEC_WAIT_AFTER_WRITE);
-#endif
-	PDEBUG(CODEC_SUCCESS, "codec_write(): (done) "
-	       "reg=0x%x, value=%d / 0x%x (no RAF check)\n",
-	       reg, val, val);
-#endif
-	mutex_unlock(&ml403_ac97cr->cdc_mutex);
-	return;
-}
-
-static int
-snd_ml403_ac97cr_chip_init(struct snd_ml403_ac97cr *ml403_ac97cr)
-{
-	unsigned long end_time;
-	PDEBUG(INIT_INFO, "chip_init():\n");
-	end_time = jiffies + HZ / CODEC_TIMEOUT_ON_INIT;
-	do {
-		if (in_be32(CR_REG(ml403_ac97cr, STATUS)) & CR_CODECREADY) {
-			/* clear both hardware FIFOs */
-			out_be32(CR_REG(ml403_ac97cr, RESETFIFO),
-				 CR_RECRESET | CR_PLAYRESET);
-			PDEBUG(INIT_INFO, "chip_init(): (done)\n");
-			return 0;
-		}
-		schedule_timeout_uninterruptible(1);
-	} while (time_after(end_time, jiffies));
-	snd_printk(KERN_ERR SND_ML403_AC97CR_DRIVER ": "
-		   "timeout while waiting for codec, "
-		   "not ready!\n");
-	return -EBUSY;
-}
-
-static int snd_ml403_ac97cr_free(struct snd_ml403_ac97cr *ml403_ac97cr)
-{
-	PDEBUG(INIT_INFO, "free():\n");
-	/* irq release */
-	if (ml403_ac97cr->irq >= 0)
-		free_irq(ml403_ac97cr->irq, ml403_ac97cr);
-	if (ml403_ac97cr->capture_irq >= 0)
-		free_irq(ml403_ac97cr->capture_irq, ml403_ac97cr);
-	/* give back "port" */
-	iounmap(ml403_ac97cr->port);
-	kfree(ml403_ac97cr);
-	PDEBUG(INIT_INFO, "free(): (done)\n");
-	return 0;
-}
-
-static int snd_ml403_ac97cr_dev_free(struct snd_device *snddev)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr = snddev->device_data;
-	PDEBUG(INIT_INFO, "dev_free():\n");
-	return snd_ml403_ac97cr_free(ml403_ac97cr);
-}
-
-static int
-snd_ml403_ac97cr_create(struct snd_card *card, struct platform_device *pfdev,
-			struct snd_ml403_ac97cr **rml403_ac97cr)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr;
-	int err;
-	static const struct snd_device_ops ops = {
-		.dev_free = snd_ml403_ac97cr_dev_free,
-	};
-	struct resource *resource;
-	int irq;
-
-	*rml403_ac97cr = NULL;
-	ml403_ac97cr = kzalloc(sizeof(*ml403_ac97cr), GFP_KERNEL);
-	if (ml403_ac97cr == NULL)
-		return -ENOMEM;
-	spin_lock_init(&ml403_ac97cr->reg_lock);
-	mutex_init(&ml403_ac97cr->cdc_mutex);
-	ml403_ac97cr->card = card;
-	ml403_ac97cr->pfdev = pfdev;
-	ml403_ac97cr->irq = -1;
-	ml403_ac97cr->enable_irq = 0;
-	ml403_ac97cr->capture_irq = -1;
-	ml403_ac97cr->enable_capture_irq = 0;
-	ml403_ac97cr->port = NULL;
-	ml403_ac97cr->res_port = NULL;
-
-	PDEBUG(INIT_INFO, "Trying to reserve resources now ...\n");
-	resource = platform_get_resource(pfdev, IORESOURCE_MEM, 0);
-	/* get "port" */
-	ml403_ac97cr->port = ioremap(resource->start,
-					     (resource->end) -
-					     (resource->start) + 1);
-	if (ml403_ac97cr->port == NULL) {
-		snd_printk(KERN_ERR SND_ML403_AC97CR_DRIVER ": "
-			   "unable to remap memory region (%pR)\n",
-			   resource);
-		snd_ml403_ac97cr_free(ml403_ac97cr);
-		return -EBUSY;
-	}
-	snd_printk(KERN_INFO SND_ML403_AC97CR_DRIVER ": "
-		   "remap controller memory region to "
-		   "0x%x done\n", (unsigned int)ml403_ac97cr->port);
-	/* get irq */
-	irq = platform_get_irq(pfdev, 0);
-	if (request_irq(irq, snd_ml403_ac97cr_irq, 0,
-			dev_name(&pfdev->dev), (void *)ml403_ac97cr)) {
-		snd_printk(KERN_ERR SND_ML403_AC97CR_DRIVER ": "
-			   "unable to grab IRQ %d\n",
-			   irq);
-		snd_ml403_ac97cr_free(ml403_ac97cr);
-		return -EBUSY;
-	}
-	ml403_ac97cr->irq = irq;
-	snd_printk(KERN_INFO SND_ML403_AC97CR_DRIVER ": "
-		   "request (playback) irq %d done\n",
-		   ml403_ac97cr->irq);
-	irq = platform_get_irq(pfdev, 1);
-	if (request_irq(irq, snd_ml403_ac97cr_irq, 0,
-			dev_name(&pfdev->dev), (void *)ml403_ac97cr)) {
-		snd_printk(KERN_ERR SND_ML403_AC97CR_DRIVER ": "
-			   "unable to grab IRQ %d\n",
-			   irq);
-		snd_ml403_ac97cr_free(ml403_ac97cr);
-		return -EBUSY;
-	}
-	ml403_ac97cr->capture_irq = irq;
-	snd_printk(KERN_INFO SND_ML403_AC97CR_DRIVER ": "
-		   "request (capture) irq %d done\n",
-		   ml403_ac97cr->capture_irq);
-
-	err = snd_ml403_ac97cr_chip_init(ml403_ac97cr);
-	if (err < 0) {
-		snd_ml403_ac97cr_free(ml403_ac97cr);
-		return err;
-	}
-
-	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ml403_ac97cr, &ops);
-	if (err < 0) {
-		PDEBUG(INIT_FAILURE, "probe(): snd_device_new() failed!\n");
-		snd_ml403_ac97cr_free(ml403_ac97cr);
-		return err;
-	}
-
-	*rml403_ac97cr = ml403_ac97cr;
-	return 0;
-}
-
-static void snd_ml403_ac97cr_mixer_free(struct snd_ac97 *ac97)
-{
-	struct snd_ml403_ac97cr *ml403_ac97cr = ac97->private_data;
-	PDEBUG(INIT_INFO, "mixer_free():\n");
-	ml403_ac97cr->ac97 = NULL;
-	PDEBUG(INIT_INFO, "mixer_free(): (done)\n");
-}
-
-static int
-snd_ml403_ac97cr_mixer(struct snd_ml403_ac97cr *ml403_ac97cr)
-{
-	struct snd_ac97_bus *bus;
-	struct snd_ac97_template ac97;
-	int err;
-	static const struct snd_ac97_bus_ops ops = {
-		.write = snd_ml403_ac97cr_codec_write,
-		.read = snd_ml403_ac97cr_codec_read,
-	};
-	PDEBUG(INIT_INFO, "mixer():\n");
-	err = snd_ac97_bus(ml403_ac97cr->card, 0, &ops, NULL, &bus);
-	if (err < 0)
-		return err;
-
-	memset(&ac97, 0, sizeof(ac97));
-	ml403_ac97cr->ac97_fake = 1;
-	lm4550_regfile_init();
-#ifdef CODEC_STAT
-	ml403_ac97cr->ac97_read = 0;
-	ml403_ac97cr->ac97_write = 0;
-#endif
-	ac97.private_data = ml403_ac97cr;
-	ac97.private_free = snd_ml403_ac97cr_mixer_free;
-	ac97.scaps = AC97_SCAP_AUDIO | AC97_SCAP_SKIP_MODEM |
-	    AC97_SCAP_NO_SPDIF;
-	err = snd_ac97_mixer(bus, &ac97, &ml403_ac97cr->ac97);
-	ml403_ac97cr->ac97_fake = 0;
-	lm4550_regfile_write_values_after_init(ml403_ac97cr->ac97);
-	PDEBUG(INIT_INFO, "mixer(): (done) snd_ac97_mixer()=%d\n", err);
-	return err;
-}
-
-static int
-snd_ml403_ac97cr_pcm(struct snd_ml403_ac97cr *ml403_ac97cr, int device)
-{
-	struct snd_pcm *pcm;
-	int err;
-
-	err = snd_pcm_new(ml403_ac97cr->card, "ML403AC97CR/1", device, 1, 1,
-			  &pcm);
-	if (err < 0)
-		return err;
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
-			&snd_ml403_ac97cr_playback_ops);
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
-			&snd_ml403_ac97cr_capture_ops);
-	pcm->private_data = ml403_ac97cr;
-	pcm->info_flags = 0;
-	strcpy(pcm->name, "ML403AC97CR DAC/ADC");
-	ml403_ac97cr->pcm = pcm;
-
-	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-				       NULL,
-				       64 * 1024,
-				       128 * 1024);
-	return 0;
-}
-
-static int snd_ml403_ac97cr_probe(struct platform_device *pfdev)
-{
-	struct snd_card *card;
-	struct snd_ml403_ac97cr *ml403_ac97cr = NULL;
-	int err;
-	int dev = pfdev->id;
-
-	if (dev >= SNDRV_CARDS)
-		return -ENODEV;
-	if (!enable[dev])
-		return -ENOENT;
-
-	err = snd_card_new(&pfdev->dev, index[dev], id[dev], THIS_MODULE,
-			   0, &card);
-	if (err < 0)
-		return err;
-	err = snd_ml403_ac97cr_create(card, pfdev, &ml403_ac97cr);
-	if (err < 0) {
-		PDEBUG(INIT_FAILURE, "probe(): create failed!\n");
-		snd_card_free(card);
-		return err;
-	}
-	PDEBUG(INIT_INFO, "probe(): create done\n");
-	card->private_data = ml403_ac97cr;
-	err = snd_ml403_ac97cr_mixer(ml403_ac97cr);
-	if (err < 0) {
-		snd_card_free(card);
-		return err;
-	}
-	PDEBUG(INIT_INFO, "probe(): mixer done\n");
-	err = snd_ml403_ac97cr_pcm(ml403_ac97cr, 0);
-	if (err < 0) {
-		snd_card_free(card);
-		return err;
-	}
-	PDEBUG(INIT_INFO, "probe(): PCM done\n");
-	strcpy(card->driver, SND_ML403_AC97CR_DRIVER);
-	strcpy(card->shortname, "ML403 AC97 Controller Reference");
-	sprintf(card->longname, "%s %s at 0x%lx, irq %i & %i, device %i",
-		card->shortname, card->driver,
-		(unsigned long)ml403_ac97cr->port, ml403_ac97cr->irq,
-		ml403_ac97cr->capture_irq, dev + 1);
-
-	err = snd_card_register(card);
-	if (err < 0) {
-		snd_card_free(card);
-		return err;
-	}
-	platform_set_drvdata(pfdev, card);
-	PDEBUG(INIT_INFO, "probe(): (done)\n");
-	return 0;
-}
-
-static int snd_ml403_ac97cr_remove(struct platform_device *pfdev)
-{
-	snd_card_free(platform_get_drvdata(pfdev));
-	return 0;
-}
-
-/* work with hotplug and coldplug */
-MODULE_ALIAS("platform:" SND_ML403_AC97CR_DRIVER);
-
-static struct platform_driver snd_ml403_ac97cr_driver = {
-	.probe = snd_ml403_ac97cr_probe,
-	.remove = snd_ml403_ac97cr_remove,
-	.driver = {
-		.name = SND_ML403_AC97CR_DRIVER,
-	},
-};
-
-module_platform_driver(snd_ml403_ac97cr_driver);
diff --git a/sound/drivers/pcm-indirect2.c b/sound/drivers/pcm-indirect2.c
deleted file mode 100644
index 4c491d0ff071..000000000000
--- a/sound/drivers/pcm-indirect2.c
+++ /dev/null
@@ -1,560 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Helper functions for indirect PCM data transfer to a simple FIFO in
- * hardware (small, no possibility to read "hardware io position",
- * updating position done by interrupt, ...)
- *
- *  Copyright (c) by 2007  Joachim Foerster <JOFT@gmx.de>
- *
- *  Based on "pcm-indirect.h" (alsa-driver-1.0.13) by
- *
- *  Copyright (c) by Takashi Iwai <tiwai@suse.de>
- *                   Jaroslav Kysela <perex@suse.cz>
- */
-
-/* snd_printk/d() */
-#include <sound/core.h>
-/* struct snd_pcm_substream, struct snd_pcm_runtime, snd_pcm_uframes_t
- * snd_pcm_period_elapsed() */
-#include <sound/pcm.h>
-
-#include "pcm-indirect2.h"
-
-#ifdef SND_PCM_INDIRECT2_STAT
-/* jiffies */
-#include <linux/jiffies.h>
-
-void snd_pcm_indirect2_stat(struct snd_pcm_substream *substream,
-			    struct snd_pcm_indirect2 *rec)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int i;
-	int j;
-	int k;
-	int seconds = (rec->lastbytetime - rec->firstbytetime) / HZ;
-
-	snd_printk(KERN_DEBUG "STAT: mul_elapsed: %u, mul_elapsed_real: %d, "
-		   "irq_occurred: %d\n",
-		   rec->mul_elapsed, rec->mul_elapsed_real, rec->irq_occured);
-	snd_printk(KERN_DEBUG "STAT: min_multiple: %d (irqs/period)\n",
-		   rec->min_multiple);
-	snd_printk(KERN_DEBUG "STAT: firstbytetime: %lu, lastbytetime: %lu, "
-		   "firstzerotime: %lu\n",
-		 rec->firstbytetime, rec->lastbytetime, rec->firstzerotime);
-	snd_printk(KERN_DEBUG "STAT: bytes2hw: %u Bytes => (by runtime->rate) "
-		   "length: %d s\n",
-		 rec->bytes2hw, rec->bytes2hw / 2 / 2 / runtime->rate);
-	snd_printk(KERN_DEBUG "STAT: (by measurement) length: %d => "
-		   "rate: %d Bytes/s = %d Frames/s|Hz\n",
-		   seconds, rec->bytes2hw / seconds,
-		   rec->bytes2hw / 2 / 2 / seconds);
-	snd_printk(KERN_DEBUG
-		   "STAT: zeros2hw: %u = %d ms ~ %d * %d zero copies\n",
-		   rec->zeros2hw, ((rec->zeros2hw / 2 / 2) * 1000) /
-		   runtime->rate,
-		   rec->zeros2hw / (rec->hw_buffer_size / 2),
-		   (rec->hw_buffer_size / 2));
-	snd_printk(KERN_DEBUG "STAT: pointer_calls: %u, lastdifftime: %u\n",
-		   rec->pointer_calls, rec->lastdifftime);
-	snd_printk(KERN_DEBUG "STAT: sw_io: %d, sw_data: %d\n", rec->sw_io,
-		   rec->sw_data);
-	snd_printk(KERN_DEBUG "STAT: byte_sizes[]:\n");
-	k = 0;
-	for (j = 0; j < 8; j++) {
-		for (i = j * 8; i < (j + 1) * 8; i++)
-			if (rec->byte_sizes[i] != 0) {
-				snd_printk(KERN_DEBUG "%u: %u",
-					   i, rec->byte_sizes[i]);
-				k++;
-			}
-		if (((k % 8) == 0) && (k != 0)) {
-			snd_printk(KERN_DEBUG "\n");
-			k = 0;
-		}
-	}
-	snd_printk(KERN_DEBUG "\n");
-	snd_printk(KERN_DEBUG "STAT: zero_sizes[]:\n");
-	for (j = 0; j < 8; j++) {
-		k = 0;
-		for (i = j * 8; i < (j + 1) * 8; i++)
-			if (rec->zero_sizes[i] != 0)
-				snd_printk(KERN_DEBUG "%u: %u",
-					   i, rec->zero_sizes[i]);
-			else
-				k++;
-		if (!k)
-			snd_printk(KERN_DEBUG "\n");
-	}
-	snd_printk(KERN_DEBUG "\n");
-	snd_printk(KERN_DEBUG "STAT: min_adds[]:\n");
-	for (j = 0; j < 8; j++) {
-		if (rec->min_adds[j] != 0)
-			snd_printk(KERN_DEBUG "%u: %u", j, rec->min_adds[j]);
-	}
-	snd_printk(KERN_DEBUG "\n");
-	snd_printk(KERN_DEBUG "STAT: mul_adds[]:\n");
-	for (j = 0; j < 8; j++) {
-		if (rec->mul_adds[j] != 0)
-			snd_printk(KERN_DEBUG "%u: %u", j, rec->mul_adds[j]);
-	}
-	snd_printk(KERN_DEBUG "\n");
-	snd_printk(KERN_DEBUG
-		   "STAT: zero_times_saved: %d, zero_times_notsaved: %d\n",
-		   rec->zero_times_saved, rec->zero_times_notsaved);
-	/* snd_printk(KERN_DEBUG "STAT: zero_times[]\n");
-	i = 0;
-	for (j = 0; j < 3750; j++) {
-		if (rec->zero_times[j] != 0) {
-			snd_printk(KERN_DEBUG "%u: %u", j, rec->zero_times[j]);
-			i++;
-		}
-		if (((i % 8) == 0) && (i != 0))
-			snd_printk(KERN_DEBUG "\n");
-	}
-	snd_printk(KERN_DEBUG "\n"); */
-	return;
-}
-#endif
-
-/*
- * _internal_ helper function for playback/capture transfer function
- */
-static void
-snd_pcm_indirect2_increase_min_periods(struct snd_pcm_substream *substream,
-				       struct snd_pcm_indirect2 *rec,
-				       int isplay, int iscopy,
-				       unsigned int bytes)
-{
-	if (rec->min_periods >= 0) {
-		if (iscopy) {
-			rec->sw_io += bytes;
-			if (rec->sw_io >= rec->sw_buffer_size)
-				rec->sw_io -= rec->sw_buffer_size;
-		} else if (isplay) {
-			/* If application does not write data in multiples of
-			 * a period, move sw_data to the next correctly aligned
-			 * position, so that sw_io can converge to it (in the
-			 * next step).
-			 */
-			if (!rec->check_alignment) {
-				if (rec->bytes2hw %
-				    snd_pcm_lib_period_bytes(substream)) {
-					unsigned bytes2hw_aligned =
-					    (1 +
-					     (rec->bytes2hw /
-					      snd_pcm_lib_period_bytes
-					      (substream))) *
-					    snd_pcm_lib_period_bytes
-					    (substream);
-					rec->sw_data =
-					    bytes2hw_aligned %
-					    rec->sw_buffer_size;
-#ifdef SND_PCM_INDIRECT2_STAT
-					snd_printk(KERN_DEBUG
-						   "STAT: @re-align: aligned "
-						   "bytes2hw to next period "
-						   "size boundary: %d "
-						   "(instead of %d)\n",
-						   bytes2hw_aligned,
-						   rec->bytes2hw);
-					snd_printk(KERN_DEBUG
-						   "STAT: @re-align: sw_data "
-						   "moves to: %d\n",
-						   rec->sw_data);
-#endif
-				}
-				rec->check_alignment = 1;
-			}
-			/* We are at the end and are copying zeros into the
-			 * fifo.
-			 * Now, we have to make sure that sw_io is increased
-			 * until the position of sw_data: Filling the fifo with
-			 * the first zeros means, the last bytes were played.
-			 */
-			if (rec->sw_io != rec->sw_data) {
-				unsigned int diff;
-				if (rec->sw_data > rec->sw_io)
-					diff = rec->sw_data - rec->sw_io;
-				else
-					diff = (rec->sw_buffer_size -
-						rec->sw_io) +
-						rec->sw_data;
-				if (bytes >= diff)
-					rec->sw_io = rec->sw_data;
-				else {
-					rec->sw_io += bytes;
-					if (rec->sw_io >= rec->sw_buffer_size)
-						rec->sw_io -=
-						    rec->sw_buffer_size;
-				}
-			}
-		}
-		rec->min_period_count += bytes;
-		if (rec->min_period_count >= (rec->hw_buffer_size / 2)) {
-			rec->min_periods += (rec->min_period_count /
-					     (rec->hw_buffer_size / 2));
-#ifdef SND_PCM_INDIRECT2_STAT
-			if ((rec->min_period_count /
-			     (rec->hw_buffer_size / 2)) > 7)
-				snd_printk(KERN_DEBUG
-					   "STAT: more than 7 (%d) min_adds "
-					   "at once - too big to save!\n",
-					   (rec->min_period_count /
-					    (rec->hw_buffer_size / 2)));
-			else
-				rec->min_adds[(rec->min_period_count /
-					       (rec->hw_buffer_size / 2))]++;
-#endif
-			rec->min_period_count = (rec->min_period_count %
-						 (rec->hw_buffer_size / 2));
-		}
-	} else if (isplay && iscopy)
-		rec->min_periods = 0;
-}
-
-/*
- * helper function for playback/capture pointer callback
- */
-snd_pcm_uframes_t
-snd_pcm_indirect2_pointer(struct snd_pcm_substream *substream,
-			  struct snd_pcm_indirect2 *rec)
-{
-#ifdef SND_PCM_INDIRECT2_STAT
-	rec->pointer_calls++;
-#endif
-	return bytes_to_frames(substream->runtime, rec->sw_io);
-}
-
-/*
- * _internal_ helper function for playback interrupt callback
- */
-static void
-snd_pcm_indirect2_playback_transfer(struct snd_pcm_substream *substream,
-				    struct snd_pcm_indirect2 *rec,
-				    snd_pcm_indirect2_copy_t copy,
-				    snd_pcm_indirect2_zero_t zero)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	snd_pcm_uframes_t appl_ptr = runtime->control->appl_ptr;
-
-	/* runtime->control->appl_ptr: position where ALSA will write next time
-	 * rec->appl_ptr: position where ALSA was last time
-	 * diff: obviously ALSA wrote that much bytes into the intermediate
-	 * buffer since we checked last time
-	 */
-	snd_pcm_sframes_t diff = appl_ptr - rec->appl_ptr;
-
-	if (diff) {
-#ifdef SND_PCM_INDIRECT2_STAT
-		rec->lastdifftime = jiffies;
-#endif
-		if (diff < -(snd_pcm_sframes_t) (runtime->boundary / 2))
-			diff += runtime->boundary;
-		/* number of bytes "added" by ALSA increases the number of
-		 * bytes which are ready to "be transferred to HW"/"played"
-		 * Then, set rec->appl_ptr to not count bytes twice next time.
-		 */
-		rec->sw_ready += (int)frames_to_bytes(runtime, diff);
-		rec->appl_ptr = appl_ptr;
-	}
-	if (rec->hw_ready && (rec->sw_ready <= 0)) {
-		unsigned int bytes;
-
-#ifdef SND_PCM_INDIRECT2_STAT
-		if (rec->firstzerotime == 0) {
-			rec->firstzerotime = jiffies;
-			snd_printk(KERN_DEBUG
-				   "STAT: @firstzerotime: mul_elapsed: %d, "
-				   "min_period_count: %d\n",
-				   rec->mul_elapsed, rec->min_period_count);
-			snd_printk(KERN_DEBUG
-				   "STAT: @firstzerotime: sw_io: %d, "
-				   "sw_data: %d, appl_ptr: %u\n",
-				   rec->sw_io, rec->sw_data,
-				   (unsigned int)appl_ptr);
-		}
-		if ((jiffies - rec->firstzerotime) < 3750) {
-			rec->zero_times[(jiffies - rec->firstzerotime)]++;
-			rec->zero_times_saved++;
-		} else
-			rec->zero_times_notsaved++;
-#endif
-		bytes = zero(substream, rec);
-
-#ifdef SND_PCM_INDIRECT2_STAT
-		rec->zeros2hw += bytes;
-		if (bytes < 64)
-			rec->zero_sizes[bytes]++;
-		else
-			snd_printk(KERN_DEBUG
-				   "STAT: %d zero Bytes copied to hardware at "
-				   "once - too big to save!\n",
-				   bytes);
-#endif
-		snd_pcm_indirect2_increase_min_periods(substream, rec, 1, 0,
-						       bytes);
-		return;
-	}
-	while (rec->hw_ready && (rec->sw_ready > 0)) {
-		/* sw_to_end: max. number of bytes that can be read/take from
-		 * the current position (sw_data) in _one_ step
-		 */
-		unsigned int sw_to_end = rec->sw_buffer_size - rec->sw_data;
-
-		/* bytes: number of bytes we have available (for reading) */
-		unsigned int bytes = rec->sw_ready;
-
-		if (sw_to_end < bytes)
-			bytes = sw_to_end;
-		if (!bytes)
-			break;
-
-#ifdef SND_PCM_INDIRECT2_STAT
-		if (rec->firstbytetime == 0)
-			rec->firstbytetime = jiffies;
-		rec->lastbytetime = jiffies;
-#endif
-		/* copy bytes from intermediate buffer position sw_data to the
-		 * HW and return number of bytes actually written
-		 * Furthermore, set hw_ready to 0, if the fifo isn't empty
-		 * now => more could be transferred to fifo
-		 */
-		bytes = copy(substream, rec, bytes);
-		rec->bytes2hw += bytes;
-
-#ifdef SND_PCM_INDIRECT2_STAT
-		if (bytes < 64)
-			rec->byte_sizes[bytes]++;
-		else
-			snd_printk(KERN_DEBUG
-				   "STAT: %d Bytes copied to hardware at once "
-				   "- too big to save!\n",
-				   bytes);
-#endif
-		/* increase sw_data by the number of actually written bytes
-		 * (= number of taken bytes from intermediate buffer)
-		 */
-		rec->sw_data += bytes;
-		if (rec->sw_data == rec->sw_buffer_size)
-			rec->sw_data = 0;
-		/* now sw_data is the position where ALSA is going to write
-		 * in the intermediate buffer next time = position we are going
-		 * to read from next time
-		 */
-
-		snd_pcm_indirect2_increase_min_periods(substream, rec, 1, 1,
-						       bytes);
-
-		/* we read bytes from intermediate buffer, so we need to say
-		 * that the number of bytes ready for transfer are decreased
-		 * now
-		 */
-		rec->sw_ready -= bytes;
-	}
-	return;
-}
-
-/*
- * helper function for playback interrupt routine
- */
-void
-snd_pcm_indirect2_playback_interrupt(struct snd_pcm_substream *substream,
-				     struct snd_pcm_indirect2 *rec,
-				     snd_pcm_indirect2_copy_t copy,
-				     snd_pcm_indirect2_zero_t zero)
-{
-#ifdef SND_PCM_INDIRECT2_STAT
-	rec->irq_occured++;
-#endif
-	/* hardware played some bytes, so there is room again (in fifo) */
-	rec->hw_ready = 1;
-
-	/* don't call ack() now, instead call transfer() function directly
-	 * (normally called by ack() )
-	 */
-	snd_pcm_indirect2_playback_transfer(substream, rec, copy, zero);
-
-	if (rec->min_periods >= rec->min_multiple) {
-#ifdef SND_PCM_INDIRECT2_STAT
-		if ((rec->min_periods / rec->min_multiple) > 7)
-			snd_printk(KERN_DEBUG
-				   "STAT: more than 7 (%d) mul_adds - too big "
-				   "to save!\n",
-				   (rec->min_periods / rec->min_multiple));
-		else
-			rec->mul_adds[(rec->min_periods /
-				       rec->min_multiple)]++;
-		rec->mul_elapsed_real += (rec->min_periods /
-					  rec->min_multiple);
-		rec->mul_elapsed++;
-#endif
-		rec->min_periods = (rec->min_periods % rec->min_multiple);
-		snd_pcm_period_elapsed(substream);
-	}
-}
-
-/*
- * _internal_ helper function for capture interrupt callback
- */
-static void
-snd_pcm_indirect2_capture_transfer(struct snd_pcm_substream *substream,
-				   struct snd_pcm_indirect2 *rec,
-				   snd_pcm_indirect2_copy_t copy,
-				   snd_pcm_indirect2_zero_t null)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	snd_pcm_uframes_t appl_ptr = runtime->control->appl_ptr;
-	snd_pcm_sframes_t diff = appl_ptr - rec->appl_ptr;
-
-	if (diff) {
-#ifdef SND_PCM_INDIRECT2_STAT
-		rec->lastdifftime = jiffies;
-#endif
-		if (diff < -(snd_pcm_sframes_t) (runtime->boundary / 2))
-			diff += runtime->boundary;
-		rec->sw_ready -= frames_to_bytes(runtime, diff);
-		rec->appl_ptr = appl_ptr;
-	}
-	/* if hardware has something, but the intermediate buffer is full
-	 * => skip contents of buffer
-	 */
-	if (rec->hw_ready && (rec->sw_ready >= (int)rec->sw_buffer_size)) {
-		unsigned int bytes;
-
-#ifdef SND_PCM_INDIRECT2_STAT
-		if (rec->firstzerotime == 0) {
-			rec->firstzerotime = jiffies;
-			snd_printk(KERN_DEBUG "STAT: (capture) "
-				   "@firstzerotime: mul_elapsed: %d, "
-				   "min_period_count: %d\n",
-				   rec->mul_elapsed, rec->min_period_count);
-			snd_printk(KERN_DEBUG "STAT: (capture) "
-				   "@firstzerotime: sw_io: %d, sw_data: %d, "
-				   "appl_ptr: %u\n",
-				   rec->sw_io, rec->sw_data,
-				   (unsigned int)appl_ptr);
-		}
-		if ((jiffies - rec->firstzerotime) < 3750) {
-			rec->zero_times[(jiffies - rec->firstzerotime)]++;
-			rec->zero_times_saved++;
-		} else
-			rec->zero_times_notsaved++;
-#endif
-		bytes = null(substream, rec);
-
-#ifdef SND_PCM_INDIRECT2_STAT
-		rec->zeros2hw += bytes;
-		if (bytes < 64)
-			rec->zero_sizes[bytes]++;
-		else
-			snd_printk(KERN_DEBUG
-				   "STAT: (capture) %d zero Bytes copied to "
-				   "hardware at once - too big to save!\n",
-				   bytes);
-#endif
-		snd_pcm_indirect2_increase_min_periods(substream, rec, 0, 0,
-						       bytes);
-		/* report an overrun */
-		rec->sw_io = SNDRV_PCM_POS_XRUN;
-		return;
-	}
-	while (rec->hw_ready && (rec->sw_ready < (int)rec->sw_buffer_size)) {
-		/* sw_to_end: max. number of bytes that we can write to the
-		 *  intermediate buffer (until it's end)
-		 */
-		size_t sw_to_end = rec->sw_buffer_size - rec->sw_data;
-
-		/* bytes: max. number of bytes, which may be copied to the
-		 *  intermediate buffer without overflow (in _one_ step)
-		 */
-		size_t bytes = rec->sw_buffer_size - rec->sw_ready;
-
-		/* limit number of bytes (for transfer) by available room in
-		 * the intermediate buffer
-		 */
-		if (sw_to_end < bytes)
-			bytes = sw_to_end;
-		if (!bytes)
-			break;
-
-#ifdef SND_PCM_INDIRECT2_STAT
-		if (rec->firstbytetime == 0)
-			rec->firstbytetime = jiffies;
-		rec->lastbytetime = jiffies;
-#endif
-		/* copy bytes from the intermediate buffer (position sw_data)
-		 * to the HW at most and return number of bytes actually copied
-		 * from HW
-		 * Furthermore, set hw_ready to 0, if the fifo is empty now.
-		 */
-		bytes = copy(substream, rec, bytes);
-		rec->bytes2hw += bytes;
-
-#ifdef SND_PCM_INDIRECT2_STAT
-		if (bytes < 64)
-			rec->byte_sizes[bytes]++;
-		else
-			snd_printk(KERN_DEBUG
-				   "STAT: (capture) %d Bytes copied to "
-				   "hardware at once - too big to save!\n",
-				   bytes);
-#endif
-		/* increase sw_data by the number of actually copied bytes from
-		 * HW
-		 */
-		rec->sw_data += bytes;
-		if (rec->sw_data == rec->sw_buffer_size)
-			rec->sw_data = 0;
-
-		snd_pcm_indirect2_increase_min_periods(substream, rec, 0, 1,
-						       bytes);
-
-		/* number of bytes in the intermediate buffer, which haven't
-		 * been fetched by ALSA yet.
-		 */
-		rec->sw_ready += bytes;
-	}
-	return;
-}
-
-/*
- * helper function for capture interrupt routine
- */
-void
-snd_pcm_indirect2_capture_interrupt(struct snd_pcm_substream *substream,
-				    struct snd_pcm_indirect2 *rec,
-				    snd_pcm_indirect2_copy_t copy,
-				    snd_pcm_indirect2_zero_t null)
-{
-#ifdef SND_PCM_INDIRECT2_STAT
-	rec->irq_occured++;
-#endif
-	/* hardware recorded some bytes, so there is something to read from the
-	 * record fifo:
-	 */
-	rec->hw_ready = 1;
-
-	/* don't call ack() now, instead call transfer() function directly
-	 * (normally called by ack() )
-	 */
-	snd_pcm_indirect2_capture_transfer(substream, rec, copy, null);
-
-	if (rec->min_periods >= rec->min_multiple) {
-
-#ifdef SND_PCM_INDIRECT2_STAT
-		if ((rec->min_periods / rec->min_multiple) > 7)
-			snd_printk(KERN_DEBUG
-				   "STAT: more than 7 (%d) mul_adds - "
-				   "too big to save!\n",
-				   (rec->min_periods / rec->min_multiple));
-		else
-			rec->mul_adds[(rec->min_periods /
-				       rec->min_multiple)]++;
-		rec->mul_elapsed_real += (rec->min_periods /
-					  rec->min_multiple);
-		rec->mul_elapsed++;
-#endif
-		rec->min_periods = (rec->min_periods % rec->min_multiple);
-		snd_pcm_period_elapsed(substream);
-	}
-}
diff --git a/sound/drivers/pcm-indirect2.h b/sound/drivers/pcm-indirect2.h
deleted file mode 100644
index 355ce76d2403..000000000000
--- a/sound/drivers/pcm-indirect2.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Helper functions for indirect PCM data transfer to a simple FIFO in
- * hardware (small, no possibility to read "hardware io position",
- * updating position done by interrupt, ...)
- *
- *  Copyright (c) by 2007  Joachim Foerster <JOFT@gmx.de>
- *
- *  Based on "pcm-indirect.h" (alsa-driver-1.0.13) by
- *
- *  Copyright (c) by Takashi Iwai <tiwai@suse.de>
- *                   Jaroslav Kysela <perex@suse.cz>
- */
-
-#ifndef __SOUND_PCM_INDIRECT2_H
-#define __SOUND_PCM_INDIRECT2_H
-
-/* struct snd_pcm_substream, struct snd_pcm_runtime, snd_pcm_uframes_t */
-#include <sound/pcm.h>
-
-/* Debug options for code which may be removed completely in a final version */
-#ifdef CONFIG_SND_DEBUG
-#define SND_PCM_INDIRECT2_STAT    /* turn on some "statistics" about the
-				   * process of copying bytes from the
-				   * intermediate buffer to the hardware
-				   * fifo and the other way round
-				   */
-#endif
-
-struct snd_pcm_indirect2 {
-	unsigned int hw_buffer_size;  /* Byte size of hardware buffer */
-	int hw_ready;		      /* playback: 1 = hw fifo has room left,
-				       * 0 = hw fifo is full
-				       */
-	unsigned int min_multiple;
-	int min_periods;	      /* counts number of min. periods until
-				       * min_multiple is reached
-				       */
-	int min_period_count;	      /* counts bytes to count number of
-				       * min. periods
-				       */
-
-	unsigned int sw_buffer_size;  /* Byte size of software buffer */
-
-	/* sw_data: position in intermediate buffer, where we will read (or
-	 *          write) from/to next time (to transfer data to/from HW)
-	 */
-	unsigned int sw_data;         /* Offset to next dst (or src) in sw
-				       * ring buffer
-				       */
-	/* easiest case (playback):
-	 * sw_data is nearly the same as ~ runtime->control->appl_ptr, with the
-	 * exception that sw_data is "behind" by the number if bytes ALSA wrote
-	 * to the intermediate buffer last time.
-	 * A call to ack() callback synchronizes both indirectly.
-	 */
-
-	/* We have no real sw_io pointer here. Usually sw_io is pointing to the
-	 * current playback/capture position _inside_ the hardware. Devices
-	 * with plain FIFOs often have no possibility to publish this position.
-	 * So we say: if sw_data is updated, that means bytes were copied to
-	 * the hardware, we increase sw_io by that amount, because there have
-	 * to be as much bytes which were played. So sw_io will stay behind
-	 * sw_data all the time and has to converge to sw_data at the end of
-	 * playback.
-	 */
-	unsigned int sw_io;           /* Current software pointer in bytes */
-
-	/* sw_ready: number of bytes ALSA copied to the intermediate buffer, so
-	 * it represents the number of bytes which wait for transfer to the HW
-	 */
-	int sw_ready;		  /* Bytes ready to be transferred to/from hw */
-
-	/* appl_ptr: last known position of ALSA (where ALSA is going to write
-	 * next time into the intermediate buffer
-	 */
-	snd_pcm_uframes_t appl_ptr;   /* Last seen appl_ptr */
-
-	unsigned int bytes2hw;
-	int check_alignment;
-
-#ifdef SND_PCM_INDIRECT2_STAT
-	unsigned int zeros2hw;
-	unsigned int mul_elapsed;
-	unsigned int mul_elapsed_real;
-	unsigned long firstbytetime;
-	unsigned long lastbytetime;
-	unsigned long firstzerotime;
-	unsigned int byte_sizes[64];
-	unsigned int zero_sizes[64];
-	unsigned int min_adds[8];
-	unsigned int mul_adds[8];
-	unsigned int zero_times[3750];	/* = 15s */
-	unsigned int zero_times_saved;
-	unsigned int zero_times_notsaved;
-	unsigned int irq_occured;
-	unsigned int pointer_calls;
-	unsigned int lastdifftime;
-#endif
-};
-
-typedef size_t (*snd_pcm_indirect2_copy_t) (struct snd_pcm_substream *substream,
-					   struct snd_pcm_indirect2 *rec,
-					   size_t bytes);
-typedef size_t (*snd_pcm_indirect2_zero_t) (struct snd_pcm_substream *substream,
-					   struct snd_pcm_indirect2 *rec);
-
-#ifdef SND_PCM_INDIRECT2_STAT
-void snd_pcm_indirect2_stat(struct snd_pcm_substream *substream,
-				   struct snd_pcm_indirect2 *rec);
-#endif
-
-snd_pcm_uframes_t
-snd_pcm_indirect2_pointer(struct snd_pcm_substream *substream,
-			  struct snd_pcm_indirect2 *rec);
-void
-snd_pcm_indirect2_playback_interrupt(struct snd_pcm_substream *substream,
-				     struct snd_pcm_indirect2 *rec,
-				     snd_pcm_indirect2_copy_t copy,
-				     snd_pcm_indirect2_zero_t zero);
-void
-snd_pcm_indirect2_capture_interrupt(struct snd_pcm_substream *substream,
-				    struct snd_pcm_indirect2 *rec,
-				    snd_pcm_indirect2_copy_t copy,
-				    snd_pcm_indirect2_zero_t null);
-
-#endif /* __SOUND_PCM_INDIRECT2_H */
-- 
2.26.0

