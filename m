Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id D7E8D27BDCF
	for <lists+alsa-devel@lfdr.de>; Tue, 29 Sep 2020 09:14:38 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id 523F61867;
	Tue, 29 Sep 2020 09:13:48 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz 523F61867
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1601363678;
	bh=cB1S83UqNFRYzH5Raaqw/kP/8xnxkSv9hqB6GrgHWig=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=s+uwU7RDTOu0croLj2awCipBamEuy9nMcgxVQ58doLNOVFZNG7vikXI8RAnO7upYH
	 OFBLSlEYYAhgZDMHwIOGmSkoUc59MsgIroCN+ENMcXljMog1pGpx+SxunZRNnwdEzC
	 uOZhO5ITF2/44Fa73TWEGnLBV55PYaFcafxD3GVc=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 825B0F8020C;
	Tue, 29 Sep 2020 09:12:57 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 0E1EFF801F5; Tue, 29 Sep 2020 09:12:55 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=RCVD_IN_MSPIKE_H3,
 RCVD_IN_MSPIKE_WL,SPF_HELO_NONE,SPF_PASS,URIBL_BLOCKED autolearn=disabled
 version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 6A645F800AB
 for <alsa-devel@alsa-project.org>; Tue, 29 Sep 2020 09:12:44 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 6A645F800AB
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id 68DF2B0B3;
 Tue, 29 Sep 2020 07:12:44 +0000 (UTC)
Date: Tue, 29 Sep 2020 09:12:44 +0200
Message-ID: <s5ho8lpkqdv.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: "Gyeongtaek Lee" <gt82.lee@samsung.com>
Subject: Re: [PATCH] ALSA: compress: allow pause and resume during draining
In-Reply-To: <000f01d69603$10573fb0$3105bf10$@samsung.com>
References: <CGME20200928105009epcas2p4a65d50d9d09800281395a490d1844ef3@epcas2p4.samsung.com>
 <000c01d69585$228db6b0$67a92410$@samsung.com>
 <7ba714ce-8b33-1b64-7503-6b155bf43909@perex.cz>
 <eaa35431-01f4-f858-0673-cc3b4ddf1c5a@linux.intel.com>
 <000f01d69603$10573fb0$3105bf10$@samsung.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: alsa-devel@alsa-project.org, khw0178.kim@samsung.com, lgirdwood@gmail.com,
 kimty@samsung.com, tiwai@suse.com,
 'Pierre-Louis Bossart' <pierre-louis.bossart@linux.intel.com>,
 vkoul@kernel.org, hmseo@samsung.com, tkjung@samsung.com,
 pilsun.jang@samsung.com, s47.kang@samsung.com
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Tue, 29 Sep 2020 03:51:35 +0200,
Gyeongtaek Lee wrote:
> 
> On 9/28/20 11:35 PM, Pierre-Louis Bossart wrote:
> >On 9/28/20 6:13 AM, Jaroslav Kysela wrote:
> >> Dne 28. 09. 20 v 12:50 Gyeongtaek Lee napsal(a):
> >>> With a stream with low bitrate, user can't pause or resume the stream
> >>> near the end of the stream because current ALSA doesn't allow it.
> >>> If the stream has very low bitrate enough to store whole stream into
> >>> the buffer, user can't do anything except stop the stream and then
> >>> restart it from the first.
> >>> If pause and resume is allowed during draining, user experience can be
> >>> enhanced.
> >> 
> >> It seems that we need a new state to handle the pause + drain condition for
> >> this case.
> >> 
> >> With this proposed change, the pause state in drain is invisible.
> >
> >Indeed it's be much nicer to have a new state, e..g 
> >SNDRV_PCM_STATE_DRAINING_PAUSED.
> Ok. I will add the new state.
> >
> >One concern is that states are defined in uapi/sound/asoc.h, so wouldn't 
> >this have impacts on userspace as well? We'd change the value of 
> >SNDRV_PCM_STATE_LAST.
> >
> I also agree that adding new state and increase LAST value in the header of uapi
> could be dangerous. So, I added it to comress_offload.h for now.
> It could be merged into snd_pcm_state_t in someday with big changes.
> Could you review the fixed patch below?

Hrm, this resulted in rather more complex changes than the original
patch.  It shows that introducing yet another state is no good idea
for this particular case.

Since the possible application's behavior after this pause is as same
as the normal pause (i.e. either resuming pause or dropping), I find
it OK to take the original approach.


thanks,

Takashi

> With a stream with low bitrate, user can't pause or resume the stream
> near the end of the stream because current ALSA doesn't allow it.
> If the stream has very low bitrate enough to store whole stream into
> the buffer, user can't do anything except stop the stream and then
> restart it from first.
> If pause, resume are allowed during draining, user experience can be
> enhanced.
> 
> New state for pause during draining is defined in compress_offload.h for
> now. If PCM_STATEs in uapi/sound/asound.h is changed, pcm libraries and
> userspace application will be affected.
> 
> Signed-off-by: Gyeongtaek Lee <gt82.lee@samsung.com>
> Cc: stable@vger.kernel.org
> ---
>  include/uapi/sound/compress_offload.h |  3 ++
>  sound/core/compress_offload.c         | 47 ++++++++++++++++++++++-----
>  2 files changed, 41 insertions(+), 9 deletions(-)
> 
> diff --git a/include/uapi/sound/compress_offload.h b/include/uapi/sound/compress_offload.h
> index 7184265c0b0d..f30b9851d1d7 100644
> --- a/include/uapi/sound/compress_offload.h
> +++ b/include/uapi/sound/compress_offload.h
> @@ -189,4 +189,7 @@ struct snd_compr_metadata {
>  #define SND_COMPR_TRIGGER_DRAIN 7 /*FIXME move this to pcm.h */
>  #define SND_COMPR_TRIGGER_NEXT_TRACK 8
>  #define SND_COMPR_TRIGGER_PARTIAL_DRAIN 9
> +
> +/* FIXME move this to asound.h */
> +#define	SNDRV_PCM_STATE_DRAINING_PAUSED	(SNDRV_PCM_STATE_LAST + 1)
>  #endif
> diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c
> index 0e53f6f31916..58fbe0d99431 100644
> --- a/sound/core/compress_offload.c
> +++ b/sound/core/compress_offload.c
> @@ -151,6 +151,7 @@ static int snd_compr_free(struct inode *inode, struct file *f)
>  	case SNDRV_PCM_STATE_RUNNING:
>  	case SNDRV_PCM_STATE_DRAINING:
>  	case SNDRV_PCM_STATE_PAUSED:
> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
>  		data->stream.ops->trigger(&data->stream, SNDRV_PCM_TRIGGER_STOP);
>  		break;
>  	default:
> @@ -431,6 +432,7 @@ static __poll_t snd_compr_poll(struct file *f, poll_table *wait)
>  	case SNDRV_PCM_STATE_RUNNING:
>  	case SNDRV_PCM_STATE_PREPARED:
>  	case SNDRV_PCM_STATE_PAUSED:
> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
>  		if (avail >= stream->runtime->fragment_size)
>  			retval = snd_compr_get_poll(stream);
>  		break;
> @@ -708,11 +710,23 @@ static int snd_compr_pause(struct snd_compr_stream *stream)
>  {
>  	int retval;
>  
> -	if (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)
> +	switch (stream->runtime->state) {
> +	case SNDRV_PCM_STATE_RUNNING:
> +		retval = stream->ops->trigger(stream,
> +			SNDRV_PCM_TRIGGER_PAUSE_PUSH);
> +		if (!retval)
> +			stream->runtime->state = SNDRV_PCM_STATE_PAUSED;
> +		break;
> +	case SNDRV_PCM_STATE_DRAINING:
> +		retval = stream->ops->trigger(stream,
> +			SNDRV_PCM_TRIGGER_PAUSE_PUSH);
> +		if (!retval)
> +			stream->runtime->state =
> +				SNDRV_PCM_STATE_DRAINING_PAUSED;
> +		break;
> +	default:
>  		return -EPERM;
> -	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);
> -	if (!retval)
> -		stream->runtime->state = SNDRV_PCM_STATE_PAUSED;
> +	}
>  	return retval;
>  }
>  
> @@ -720,11 +734,22 @@ static int snd_compr_resume(struct snd_compr_stream *stream)
>  {
>  	int retval;
>  
> -	if (stream->runtime->state != SNDRV_PCM_STATE_PAUSED)
> +	switch (stream->runtime->state) {
> +	case SNDRV_PCM_STATE_PAUSED:
> +		retval = stream->ops->trigger(stream,
> +			SNDRV_PCM_TRIGGER_PAUSE_RELEASE);
> +		if (!retval)
> +			stream->runtime->state = SNDRV_PCM_STATE_RUNNING;
> +		break;
> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
> +		retval = stream->ops->trigger(stream,
> +			SNDRV_PCM_TRIGGER_PAUSE_RELEASE);
> +		if (!retval)
> +			stream->runtime->state = SNDRV_PCM_STATE_DRAINING;
> +		break;
> +	default:
>  		return -EPERM;
> -	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_RELEASE);
> -	if (!retval)
> -		stream->runtime->state = SNDRV_PCM_STATE_RUNNING;
> +	}
>  	return retval;
>  }
>  
> @@ -835,7 +860,9 @@ static int snd_compress_wait_for_drain(struct snd_compr_stream *stream)
>  	 */
>  
>  	ret = wait_event_interruptible(stream->runtime->sleep,
> -			(stream->runtime->state != SNDRV_PCM_STATE_DRAINING));
> +			(stream->runtime->state != SNDRV_PCM_STATE_DRAINING) &&
> +			(stream->runtime->state !=
> +				SNDRV_PCM_STATE_DRAINING_PAUSED));
>  	if (ret == -ERESTARTSYS)
>  		pr_debug("wait aborted by a signal\n");
>  	else if (ret)
> @@ -857,6 +884,7 @@ static int snd_compr_drain(struct snd_compr_stream *stream)
>  	case SNDRV_PCM_STATE_SETUP:
>  	case SNDRV_PCM_STATE_PREPARED:
>  	case SNDRV_PCM_STATE_PAUSED:
> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
>  		return -EPERM;
>  	case SNDRV_PCM_STATE_XRUN:
>  		return -EPIPE;
> @@ -909,6 +937,7 @@ static int snd_compr_partial_drain(struct snd_compr_stream *stream)
>  	case SNDRV_PCM_STATE_SETUP:
>  	case SNDRV_PCM_STATE_PREPARED:
>  	case SNDRV_PCM_STATE_PAUSED:
> +	case SNDRV_PCM_STATE_DRAINING_PAUSED:
>  		return -EPERM;
>  	case SNDRV_PCM_STATE_XRUN:
>  		return -EPIPE;
> 
> base-commit: a1b8638ba1320e6684aa98233c15255eb803fac7
> -- 
> 2.21.0
> 
> 
