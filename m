Return-Path: <alsa-devel-bounces@alsa-project.org>
X-Original-To: lists+alsa-devel@lfdr.de
Delivered-To: lists+alsa-devel@lfdr.de
Received: from alsa0.perex.cz (alsa0.perex.cz [77.48.224.243])
	by mail.lfdr.de (Postfix) with ESMTPS id 81E6A363CA3
	for <lists+alsa-devel@lfdr.de>; Mon, 19 Apr 2021 09:36:19 +0200 (CEST)
Received: from alsa1.perex.cz (alsa1.perex.cz [207.180.221.201])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by alsa0.perex.cz (Postfix) with ESMTPS id EE63016B9;
	Mon, 19 Apr 2021 09:35:28 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa0.perex.cz EE63016B9
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=alsa-project.org;
	s=default; t=1618817779;
	bh=fxJ05bDnO28rWGeU89LWSKashBZmu4Ijl+ZywwSn6WI=;
	h=Date:From:To:Subject:In-Reply-To:References:Cc:List-Id:
	 List-Unsubscribe:List-Archive:List-Post:List-Help:List-Subscribe:
	 From;
	b=g4LFWWnLj+CO4PMXhoUBdgcxDhx8SttPq8a7CFOugh3HA3ytvTDT3MmyRSas2zTRr
	 3n9X8OPOyPHzazDJwKbQR7tpVbqQmXUan8of3IxeySdWLaYtJrytND7IW3SvB+yqm0
	 2+ubX432yEb6rav31rnzD7aPJeLUWnxMNZ5kJw4c=
Received: from alsa1.perex.cz (localhost.localdomain [127.0.0.1])
	by alsa1.perex.cz (Postfix) with ESMTP id 64F09F800C5;
	Mon, 19 Apr 2021 09:34:50 +0200 (CEST)
X-Original-To: alsa-devel@alsa-project.org
Delivered-To: alsa-devel@alsa-project.org
Received: by alsa1.perex.cz (Postfix, from userid 50401)
 id 33A75F80227; Mon, 19 Apr 2021 09:34:49 +0200 (CEST)
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on alsa1.perex.cz
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=SPF_HELO_NONE,SPF_NONE
 autolearn=disabled version=3.4.0
Received: from mx2.suse.de (mx2.suse.de [195.135.220.15])
 (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by alsa1.perex.cz (Postfix) with ESMTPS id 19394F800C5
 for <alsa-devel@alsa-project.org>; Mon, 19 Apr 2021 09:34:42 +0200 (CEST)
DKIM-Filter: OpenDKIM Filter v2.11.0 alsa1.perex.cz 19394F800C5
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
 by mx2.suse.de (Postfix) with ESMTP id 69E2AAEAA;
 Mon, 19 Apr 2021 07:34:42 +0000 (UTC)
Date: Mon, 19 Apr 2021 09:34:42 +0200
Message-ID: <s5hk0oyg225.wl-tiwai@suse.de>
From: Takashi Iwai <tiwai@suse.de>
To: David Henningsson <coding@diwic.se>
Subject: Re: [PATCH v5] sound: rawmidi: Add framing mode
In-Reply-To: <ba6c46da-4778-8bd7-d1ca-6bcc77137645@diwic.se>
References: <20210418151217.208582-1-coding@diwic.se>
 <a0928012-ff8d-3253-4cc6-89bf69d4cfdd@perex.cz>
 <ba6c46da-4778-8bd7-d1ca-6bcc77137645@diwic.se>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Cc: alsa-devel@alsa-project.org
X-BeenThere: alsa-devel@alsa-project.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: "Alsa-devel mailing list for ALSA developers -
 http://www.alsa-project.org" <alsa-devel.alsa-project.org>
List-Unsubscribe: <https://mailman.alsa-project.org/mailman/options/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=unsubscribe>
List-Archive: <http://mailman.alsa-project.org/pipermail/alsa-devel/>
List-Post: <mailto:alsa-devel@alsa-project.org>
List-Help: <mailto:alsa-devel-request@alsa-project.org?subject=help>
List-Subscribe: <https://mailman.alsa-project.org/mailman/listinfo/alsa-devel>, 
 <mailto:alsa-devel-request@alsa-project.org?subject=subscribe>
Errors-To: alsa-devel-bounces@alsa-project.org
Sender: "Alsa-devel" <alsa-devel-bounces@alsa-project.org>

On Mon, 19 Apr 2021 08:22:50 +0200,
David Henningsson wrote:
> 
> 
> On 2021-04-18 20:24, Jaroslav Kysela wrote:
> > Dne 18. 04. 21 v 17:12 David Henningsson napsal(a):
> >
> >> +#define SND_RAWMIDI_FRAMING_DATA_LENGTH 16
> > SNDRV_ prefix should be here.
> 
> Ack
> 
> >
> >> +
> >> +struct snd_rawmidi_framing_tstamp {
> >> +	/* For now, frame_type is always 0. Midi 2.0 is expected to add new
> >> +	 * types here. Applications are expected to skip unknown frame types.
> >> +	 */
> >> +	u8 frame_type;
> >> +	u8 length; /* number of valid bytes in data field */
> >> +	u8 reserved[2];
> >> +	u32 tv_nsec;		/* nanoseconds */
> >> +	u64 tv_sec;		/* seconds */
> >> +	u8 data[SND_RAWMIDI_FRAMING_DATA_LENGTH];
> > What about to move the fields to union (except for frame_type) like we do for
> > 'struct snd_ctl_event' in case when we need to reorganize the contents for
> > future types?
> 
> So the two degrees of freedom would be
> 
> 1) the SNDRV_RAWMIDI_MODE_FRAMING_32BYTES indicates that the frame
> size is 32 bytes and the first byte of that frame is frame_type
> 
> 2) the frame_type of every frame indicates the format of the other 31
> bytes, and an application is expected to ignore unknown frame_types,
> so we can add new frame_types in a backwards compatible way.
> 
> We'll end up with:
> 
> struct snd_rawmidi_framing_32bytes {
>     u8 frame_type;
>     union {
>         struct {
>             u8 length; /* number of valid bytes in data field */
>             u8 reserved[2];
>             u32 tv_nsec;        /* nanoseconds */
>             u64 tv_sec;        /* seconds */
>             u8 data[SNDRV_RAWMIDI_FRAMING_32BYTES_FOO_LENGTH];
>         } foo;
>         u8 reserved[31];
>     } data;
> };
> 
> ...except I don't know what we should replace foo with. We can't call
> it "midi1" or "type0" or such because many different frame_types might
> share the same interior format.

I thought of the use of union, but concluded that it doesn't give any
good benefit.  Practically seen, defining two structs would be far
easier, and if you want to code something in user-space for another
new frame format, you would just use the new struct as is, as long as
the size fits correctly.

If we think of the future-proof compatibility, you may align the
struct to a TLV pattern; the struct already shows a kind of that. But
it would work only if the kernel read side allows the partial read,
though.  So maybe it's not the case.

> >> +};
> >> +
> >>   struct snd_rawmidi_params {
> >>   	int stream;
> >>   	size_t buffer_size;		/* queue size in bytes */
> >>   	size_t avail_min;		/* minimum avail bytes for wakeup */
> >>   	unsigned int no_active_sensing: 1; /* do not send active sensing byte in close() */
> >> -	unsigned char reserved[16];	/* reserved for future use */
> >> +	unsigned char framing;		/* For input data only, frame incoming data */
> >> +	unsigned char clock_type;	/* Type of clock to use for framing, same as clockid_t */
> >> +	unsigned char reserved[14];	/* reserved for future use */
> > As I noted, I would prefer to add 'unsigned int mode;' and define
> > SNDRV_RAWMID_MODE_XXX bit flags and groups with framing and clock_type groups.
> > There's no reason to stick with 'clockid_t' (which is integer anyway). We're
> > using just a subset.
> >
> > #define SNDRV_RAWMIDI_MODE_FRAMING_MASK        (7<<0)
> > #define SNDRV_RAWMIDI_MODE_FRAMING_SHIFT       0
> > #define SNDRV_RAWMIDI_MODE_FRAMING_NONE	       (0<<0)
> > #define SNDRV_RAWMIDI_MODE_FRAMING_32BYTES     (1<<0)
> > #define SNDRV_RAWMIDI_MODE_CLOCK_MASK          (7<<3)
> > #define SNDRV_RAWMIDI_MODE_CLOCK_SHIFT         3
> > #define SNDRV_RAWMIDI_MODE_CLOCK_NONE	       (0<<3)
> > #define SNDRV_RAWMIDI_MODE_CLOCK_REALTIME      (1<<3)
> > #define SNDRV_RAWMIDI_MODE_CLOCK_MONOTONIC     (2<<3)
> > #define SNDRV_RAWMIDI_MODE_CLOCK_MONOTONIC_RAW (3<<3)
> >
> > In this case, we can use 26-bits in future for extensions.
> 
> Well, for me this is mostly bikeshedding. But as long as you and
> Takashi can't agree on whether bitfields/bimasks/etc are good or bad,
> I'm just stuck between the two of you and can't actually improve
> Linux's capability to be a great pro audio OS, and that is utterly
> frustrating. I don't care if the two of you decides who's going to win
> this through this list, a conference call, a game of SuperTuxKart or
> thumb wrestling, just reach consensus somehow. Okay?

Oh, don't get me wrong, I have no objection to the bit flags at all.
My objection was against the use of C language bit-fields
(e.g. unsigned int foo:5) as Jaroslav suggested in his earlier reply.
That's not portable, hence unsuitable for ioctl structs.  OTOH, the
explicit bit flags are very common in ABI definitions.

And I have no strong opinion on the flag definitions.  I find it OK to
keep two uchar fields (that are mostly enough for near future
extensions), but having a 32bit full bit flag would be of course OK
from ABI design POV (and one less code in the compat function).

That said, there is no disagreement about the flag definition at all.
You can pick up what you believe the best.


BTW, regarding the portability: it'd be safer to put __packed
attribute to the newly defined frame struct.  Although it's certainly
fit in the designed size with gcc, essentially a compiler is still
free to put any padding.  Unlike the ioctl struct, the difference of
the access size couldn't be caught easily for read syscall (as we
often allow partial reads).


thanks,

Takashi
